{
  "problems": [
    {
      "number": 501,
      "title": "Find Mode in Binary Search Tree",
      "titleSlug": "find-mode-in-binary-search-tree",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it. If the tree has more than one mode, return them in any order. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node&#39;s key. The right subtree of a node contains only nodes with keys greater than or equal to the node&#39;s key. Both the left and right subtrees must also be binary search trees. &nbsp; Example 1: Input: root = [1,null,2,2] Output: [2] Example 2: Input: root = [0] Output: [0] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. -105 &lt;= Node.val &lt;= 105 &nbsp; Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count)."
    },
    {
      "number": 502,
      "title": "IPO",
      "titleSlug": "ipo",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Greedy",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects. You are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it. Initially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital. Pick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital. The answer is guaranteed to fit in a 32-bit signed integer. &nbsp; Example 1: Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1] Output: 4 Explanation: Since your initial capital is 0, you can only start the project indexed 0. After finishing it you will obtain profit 1 and your capital becomes 1. With capital 1, you can either start the project indexed 1 or the project indexed 2. Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital. Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4. Example 2: Input: k = 3, w = 0, profits = [1,2,3], capital = [0,1,2] Output: 6 &nbsp; Constraints: 1 &lt;= k &lt;= 105 0 &lt;= w &lt;= 109 n == profits.length n == capital.length 1 &lt;= n &lt;= 105 0 &lt;= profits[i] &lt;= 104 0 &lt;= capital[i] &lt;= 109"
    },
    {
      "number": 503,
      "title": "Next Greater Element II",
      "titleSlug": "next-greater-element-ii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Stack",
        "Monotonic Stack"
      ],
      "description": "Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums. The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn&#39;t exist, return -1 for this number. &nbsp; Example 1: Input: nums = [1,2,1] Output: [2,-1,2] Explanation: The first 1&#39;s next greater number is 2; The number 2 can&#39;t find next greater number. The second 1&#39;s next greater number needs to search circularly, which is also 2. Example 2: Input: nums = [1,2,3,4,3] Output: [2,3,4,-1,4] &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109"
    },
    {
      "number": 504,
      "title": "Base 7",
      "titleSlug": "base-7",
      "difficulty": "Easy",
      "tags": [
        "Math"
      ],
      "description": "Given an integer num, return a string of its base 7 representation. &nbsp; Example 1: Input: num = 100 Output: \"202\" Example 2: Input: num = -7 Output: \"-10\" &nbsp; Constraints: -107 &lt;= num &lt;= 107"
    },
    {
      "number": 506,
      "title": "Relative Ranks",
      "titleSlug": "relative-ranks",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique. The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank: The 1st place athlete&#39;s rank is &quot;Gold Medal&quot;. The 2nd place athlete&#39;s rank is &quot;Silver Medal&quot;. The 3rd place athlete&#39;s rank is &quot;Bronze Medal&quot;. For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete&#39;s rank is &quot;x&quot;). Return an array answer of size n where answer[i] is the rank of the ith athlete. &nbsp; Example 1: Input: score = [5,4,3,2,1] Output: [&quot;Gold Medal&quot;,&quot;Silver Medal&quot;,&quot;Bronze Medal&quot;,&quot;4&quot;,&quot;5&quot;] Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th]. Example 2: Input: score = [10,3,8,9,4] Output: [&quot;Gold Medal&quot;,&quot;5&quot;,&quot;Bronze Medal&quot;,&quot;Silver Medal&quot;,&quot;4&quot;] Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th]. &nbsp; Constraints: n == score.length 1 &lt;= n &lt;= 104 0 &lt;= score[i] &lt;= 106 All the values in score are unique."
    },
    {
      "number": 507,
      "title": "Perfect Number",
      "titleSlug": "perfect-number",
      "difficulty": "Easy",
      "tags": [
        "Math"
      ],
      "description": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly. Given an integer n, return true if n is a perfect number, otherwise return false. &nbsp; Example 1: Input: num = 28 Output: true Explanation: 28 = 1 + 2 + 4 + 7 + 14 1, 2, 4, 7, and 14 are all divisors of 28. Example 2: Input: num = 7 Output: false &nbsp; Constraints: 1 &lt;= num &lt;= 108"
    },
    {
      "number": 508,
      "title": "Most Frequent Subtree Sum",
      "titleSlug": "most-frequent-subtree-sum",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return the most frequent subtree sum. If there is a tie, return all the values with the highest frequency in any order. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). &nbsp; Example 1: Input: root = [5,2,-3] Output: [2,-3,4] Example 2: Input: root = [5,2,-5] Output: [2] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. -105 &lt;= Node.val &lt;= 105"
    },
    {
      "number": 509,
      "title": "Fibonacci Number",
      "titleSlug": "fibonacci-number",
      "difficulty": "Easy",
      "tags": [
        "Math",
        "Dynamic Programming",
        "Recursion",
        "Memoization"
      ],
      "description": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n &gt; 1. Given n, calculate F(n). &nbsp; Example 1: Input: n = 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: Input: n = 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: Input: n = 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. &nbsp; Constraints: 0 &lt;= n &lt;= 30"
    },
    {
      "number": 511,
      "title": "Game Play Analysis I",
      "titleSlug": "game-play-analysis-i",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Activity +--------------+---------+ | Column Name | Type | +--------------+---------+ | player_id | int | | device_id | int | | event_date | date | | games_played | int | +--------------+---------+ (player_id, event_date) is the primary key (combination of columns with unique values) of this table. This table shows the activity of players of some games. Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on someday using some device. &nbsp; Write a solution to find the first login date for each player. Return the result table in any order. The result format is in the following example. &nbsp; Example 1: Input: Activity table: +-----------+-----------+------------+--------------+ | player_id | device_id | event_date | games_played | +-----------+-----------+------------+--------------+ | 1 | 2 | 2016-03-01 | 5 | | 1 | 2 | 2016-05-02 | 6 | | 2 | 3 | 2017-06-25 | 1 | | 3 | 1 | 2016-03-02 | 0 | | 3 | 4 | 2018-07-03 | 5 | +-----------+-----------+------------+--------------+ Output: +-----------+-------------+ | player_id | first_login | +-----------+-------------+ | 1 | 2016-03-01 | | 2 | 2017-06-25 | | 3 | 2016-03-02 | +-----------+-------------+"
    },
    {
      "number": 513,
      "title": "Find Bottom Left Tree Value",
      "titleSlug": "find-bottom-left-tree-value",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return the leftmost value in the last row of the tree. &nbsp; Example 1: Input: root = [2,1,3] Output: 1 Example 2: Input: root = [1,2,3,4,null,5,6,null,null,7] Output: 7 &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. -231 &lt;= Node.val &lt;= 231 - 1"
    },
    {
      "number": 514,
      "title": "Freedom Trail",
      "titleSlug": "freedom-trail",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming",
        "Depth-First Search",
        "Breadth-First Search"
      ],
      "description": "In the video game Fallout 4, the quest &quot;Road to Freedom&quot; requires players to reach a metal dial called the &quot;Freedom Trail Ring&quot; and use the dial to spell a specific keyword to open the door. Given a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword. Initially, the first character of the ring is aligned at the &quot;12:00&quot; direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the &quot;12:00&quot; direction and then by pressing the center button. At the stage of rotating the ring to spell the key character key[i]: You can rotate the ring clockwise or anticlockwise by one place, which counts as one step. The final purpose of the rotation is to align one of ring&#39;s characters at the &quot;12:00&quot; direction, where this character must equal key[i]. If the character key[i] has been aligned at the &quot;12:00&quot; direction, press the center button to spell, which also counts as one step. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling. &nbsp; Example 1: Input: ring = &quot;godding&quot;, key = &quot;gd&quot; Output: 4 Explanation: For the first key character &#39;g&#39;, since it is already in place, we just need 1 step to spell this character. For the second key character &#39;d&#39;, we need to rotate the ring &quot;godding&quot; anticlockwise by two steps to make it become &quot;ddinggo&quot;. Also, we need 1 more step for spelling. So the final output is 4. Example 2: Input: ring = &quot;godding&quot;, key = &quot;godding&quot; Output: 13 &nbsp; Constraints: 1 &lt;= ring.length, key.length &lt;= 100 ring and key consist of only lower case English letters. It is guaranteed that key could always be spelled by rotating ring."
    },
    {
      "number": 515,
      "title": "Find Largest Value in Each Tree Row",
      "titleSlug": "find-largest-value-in-each-tree-row",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed). &nbsp; Example 1: Input: root = [1,3,2,5,3,null,9] Output: [1,3,9] Example 2: Input: root = [1,2,3] Output: [1,3] &nbsp; Constraints: The number of nodes in the tree will be in the range [0, 104]. -231 &lt;= Node.val &lt;= 231 - 1"
    },
    {
      "number": 516,
      "title": "Longest Palindromic Subsequence",
      "titleSlug": "longest-palindromic-subsequence",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "Given a string s, find the longest palindromic subsequence&#39;s length in s. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. &nbsp; Example 1: Input: s = &quot;bbbab&quot; Output: 4 Explanation: One possible longest palindromic subsequence is &quot;bbbb&quot;. Example 2: Input: s = &quot;cbbd&quot; Output: 2 Explanation: One possible longest palindromic subsequence is &quot;bb&quot;. &nbsp; Constraints: 1 &lt;= s.length &lt;= 1000 s consists only of lowercase English letters."
    },
    {
      "number": 517,
      "title": "Super Washing Machines",
      "titleSlug": "super-washing-machines",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Greedy"
      ],
      "description": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty. For each move, you could choose any m (1 &lt;= m &lt;= n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time. Given an integer array machines representing the number of dresses in each washing machine from left to right on the line, return the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1. &nbsp; Example 1: Input: machines = [1,0,5] Output: 3 Explanation: 1st move: 1 0 &lt;-- 5 =&gt; 1 1 4 2nd move: 1 &lt;-- 1 &lt;-- 4 =&gt; 2 1 3 3rd move: 2 1 &lt;-- 3 =&gt; 2 2 2 Example 2: Input: machines = [0,3,0] Output: 2 Explanation: 1st move: 0 &lt;-- 3 0 =&gt; 1 2 0 2nd move: 1 2 --&gt; 0 =&gt; 1 1 1 Example 3: Input: machines = [0,2,0] Output: -1 Explanation: It&#39;s impossible to make all three washing machines have the same number of dresses. &nbsp; Constraints: n == machines.length 1 &lt;= n &lt;= 104 0 &lt;= machines[i] &lt;= 105"
    },
    {
      "number": 518,
      "title": "Coin Change II",
      "titleSlug": "coin-change-ii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0. You may assume that you have an infinite number of each kind of coin. The answer is guaranteed to fit into a signed 32-bit integer. &nbsp; Example 1: Input: amount = 5, coins = [1,2,5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 Example 2: Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2. Example 3: Input: amount = 10, coins = [10] Output: 1 &nbsp; Constraints: 1 &lt;= coins.length &lt;= 300 1 &lt;= coins[i] &lt;= 5000 All the values of coins are unique. 0 &lt;= amount &lt;= 5000"
    },
    {
      "number": 519,
      "title": "Random Flip Matrix",
      "titleSlug": "random-flip-matrix",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Math",
        "Reservoir Sampling",
        "Randomized"
      ],
      "description": "There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to randomly pick an index (i, j) where matrix[i][j] == 0 and flips it to 1. All the indices (i, j) where matrix[i][j] == 0 should be equally likely to be returned. Optimize your algorithm to minimize the number of calls made to the built-in random function of your language and optimize the time and space complexity. Implement the Solution class: Solution(int m, int n) Initializes the object with the size of the binary matrix m and n. int[] flip() Returns a random index [i, j] of the matrix where matrix[i][j] == 0 and flips it to 1. void reset() Resets all the values of the matrix to be 0. &nbsp; Example 1: Input [&quot;Solution&quot;, &quot;flip&quot;, &quot;flip&quot;, &quot;flip&quot;, &quot;reset&quot;, &quot;flip&quot;] [[3, 1], [], [], [], [], []] Output [null, [1, 0], [2, 0], [0, 0], null, [2, 0]] Explanation Solution solution = new Solution(3, 1); solution.flip(); // return [1, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned. solution.flip(); // return [2, 0], Since [1,0] was returned, [2,0] and [0,0] solution.flip(); // return [0, 0], Based on the previously returned indices, only [0,0] can be returned. solution.reset(); // All the values are reset to 0 and can be returned. solution.flip(); // return [2, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned. &nbsp; Constraints: 1 &lt;= m, n &lt;= 104 There will be at least one free cell for each call to flip. At most 1000 calls will be made to flip and reset."
    },
    {
      "number": 520,
      "title": "Detect Capital",
      "titleSlug": "detect-capital",
      "difficulty": "Easy",
      "tags": [
        "String"
      ],
      "description": "We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like &quot;USA&quot;. All letters in this word are not capitals, like &quot;leetcode&quot;. Only the first letter in this word is capital, like &quot;Google&quot;. Given a string word, return true if the usage of capitals in it is right. &nbsp; Example 1: Input: word = \"USA\" Output: true Example 2: Input: word = \"FlaG\" Output: false &nbsp; Constraints: 1 &lt;= word.length &lt;= 100 word consists of lowercase and uppercase English letters."
    },
    {
      "number": 521,
      "title": "Longest Uncommon Subsequence I",
      "titleSlug": "longest-uncommon-subsequence-i",
      "difficulty": "Easy",
      "tags": [
        "String"
      ],
      "description": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If no such uncommon subsequence exists, return -1. An uncommon subsequence between two strings is a string that is a subsequence of exactly one of them. &nbsp; Example 1: Input: a = &quot;aba&quot;, b = &quot;cdc&quot; Output: 3 Explanation: One longest uncommon subsequence is &quot;aba&quot; because &quot;aba&quot; is a subsequence of &quot;aba&quot; but not &quot;cdc&quot;. Note that &quot;cdc&quot; is also a longest uncommon subsequence. Example 2: Input: a = &quot;aaa&quot;, b = &quot;bbb&quot; Output: 3 Explanation:&nbsp;The longest uncommon subsequences are &quot;aaa&quot; and &quot;bbb&quot;. Example 3: Input: a = &quot;aaa&quot;, b = &quot;aaa&quot; Output: -1 Explanation:&nbsp;Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a. So the answer would be -1. &nbsp; Constraints: 1 &lt;= a.length, b.length &lt;= 100 a and b consist of lower-case English letters."
    },
    {
      "number": 522,
      "title": "Longest Uncommon Subsequence II",
      "titleSlug": "longest-uncommon-subsequence-ii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Two Pointers",
        "String",
        "Sorting"
      ],
      "description": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1. An uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others. A subsequence of a string s is a string that can be obtained after deleting any number of characters from s. For example, &quot;abc&quot; is a subsequence of &quot;aebdc&quot; because you can delete the underlined characters in &quot;aebdc&quot; to get &quot;abc&quot;. Other subsequences of &quot;aebdc&quot; include &quot;aebdc&quot;, &quot;aeb&quot;, and &quot;&quot; (empty string). &nbsp; Example 1: Input: strs = [\"aba\",\"cdc\",\"eae\"] Output: 3 Example 2: Input: strs = [\"aaa\",\"aaa\",\"aa\"] Output: -1 &nbsp; Constraints: 2 &lt;= strs.length &lt;= 50 1 &lt;= strs[i].length &lt;= 10 strs[i] consists of lowercase English letters."
    },
    {
      "number": 523,
      "title": "Continuous Subarray Sum",
      "titleSlug": "continuous-subarray-sum",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Math",
        "Prefix Sum"
      ],
      "description": "Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise. A good subarray is a subarray where: its length is at least two, and the sum of the elements of the subarray is a multiple of k. Note that: A subarray is a contiguous part of the array. An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k. &nbsp; Example 1: Input: nums = [23,2,4,6,7], k = 6 Output: true Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6. Example 2: Input: nums = [23,2,6,4,7], k = 6 Output: true Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42. 42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer. Example 3: Input: nums = [23,2,6,4,7], k = 13 Output: false &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 109 0 &lt;= sum(nums[i]) &lt;= 231 - 1 1 &lt;= k &lt;= 231 - 1"
    },
    {
      "number": 524,
      "title": "Longest Word in Dictionary through Deleting",
      "titleSlug": "longest-word-in-dictionary-through-deleting",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "String",
        "Sorting"
      ],
      "description": "Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string. &nbsp; Example 1: Input: s = &quot;abpcplea&quot;, dictionary = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;] Output: &quot;apple&quot; Example 2: Input: s = &quot;abpcplea&quot;, dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] Output: &quot;a&quot; &nbsp; Constraints: 1 &lt;= s.length &lt;= 1000 1 &lt;= dictionary.length &lt;= 1000 1 &lt;= dictionary[i].length &lt;= 1000 s and dictionary[i] consist of lowercase English letters."
    },
    {
      "number": 525,
      "title": "Contiguous Array",
      "titleSlug": "contiguous-array",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Prefix Sum"
      ],
      "description": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1. &nbsp; Example 1: Input: nums = [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1. Example 2: Input: nums = [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Example 3: Input: nums = [0,1,1,1,1,1,0,0,0] Output: 6 Explanation: [1,1,1,0,0,0] is the longest contiguous subarray with equal number of 0 and 1. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 nums[i] is either 0 or 1."
    },
    {
      "number": 526,
      "title": "Beautiful Arrangement",
      "titleSlug": "beautiful-arrangement",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Backtracking",
        "Bit Manipulation",
        "Bitmask"
      ],
      "description": "Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement if for every i (1 &lt;= i &lt;= n), either of the following is true: perm[i] is divisible by i. i is divisible by perm[i]. Given an integer n, return the number of the beautiful arrangements that you can construct. &nbsp; Example 1: Input: n = 2 Output: 2 Explanation: The first beautiful arrangement is [1,2]: - perm[1] = 1 is divisible by i = 1 - perm[2] = 2 is divisible by i = 2 The second beautiful arrangement is [2,1]: - perm[1] = 2 is divisible by i = 1 - i = 2 is divisible by perm[2] = 1 Example 2: Input: n = 1 Output: 1 &nbsp; Constraints: 1 &lt;= n &lt;= 15"
    },
    {
      "number": 528,
      "title": "Random Pick with Weight",
      "titleSlug": "random-pick-with-weight",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math",
        "Binary Search",
        "Prefix Sum",
        "Randomized"
      ],
      "description": "You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index. You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w). For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%). &nbsp; Example 1: Input [&quot;Solution&quot;,&quot;pickIndex&quot;] [[[1]],[]] Output [null,0] Explanation Solution solution = new Solution([1]); solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w. Example 2: Input [&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;] [[[1,3]],[],[],[],[],[]] Output [null,1,1,1,1,0] Explanation Solution solution = new Solution([1, 3]); solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4. solution.pickIndex(); // return 1 solution.pickIndex(); // return 1 solution.pickIndex(); // return 1 solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4. Since this is a randomization problem, multiple answers are allowed. All of the following outputs can be considered correct: [null,1,1,1,1,0] [null,1,1,1,1,1] [null,1,1,1,0,0] [null,1,1,1,0,1] [null,1,0,1,0,0] ...... and so on. &nbsp; Constraints: 1 &lt;= w.length &lt;= 104 1 &lt;= w[i] &lt;= 105 pickIndex will be called at most 104 times."
    },
    {
      "number": 529,
      "title": "Minesweeper",
      "titleSlug": "minesweeper",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Depth-First Search",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "Let&#39;s play the minesweeper game (Wikipedia, online game)! You are given an m x n char matrix board representing the game board where: &#39;M&#39; represents an unrevealed mine, &#39;E&#39; represents an unrevealed empty square, &#39;B&#39; represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals), digit (&#39;1&#39; to &#39;8&#39;) represents how many mines are adjacent to this revealed square, and &#39;X&#39; represents a revealed mine. You are also given an integer array click where click = [clickr, clickc] represents the next click position among all the unrevealed squares (&#39;M&#39; or &#39;E&#39;). Return the board after revealing this position according to the following rules: If a mine &#39;M&#39; is revealed, then the game is over. You should change it to &#39;X&#39;. If an empty square &#39;E&#39; with no adjacent mines is revealed, then change it to a revealed blank &#39;B&#39; and all of its adjacent unrevealed squares should be revealed recursively. If an empty square &#39;E&#39; with at least one adjacent mine is revealed, then change it to a digit (&#39;1&#39; to &#39;8&#39;) representing the number of adjacent mines. Return the board when no more squares will be revealed. &nbsp; Example 1: Input: board = [[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;M&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;]], click = [3,0] Output: [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;M&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]] Example 2: Input: board = [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;M&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]], click = [1,2] Output: [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;X&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]] &nbsp; Constraints: m == board.length n == board[i].length 1 &lt;= m, n &lt;= 50 board[i][j] is either &#39;M&#39;, &#39;E&#39;, &#39;B&#39;, or a digit from &#39;1&#39; to &#39;8&#39;. click.length == 2 0 &lt;= clickr &lt; m 0 &lt;= clickc &lt; n board[clickr][clickc] is either &#39;M&#39; or &#39;E&#39;."
    },
    {
      "number": 530,
      "title": "Minimum Absolute Difference in BST",
      "titleSlug": "minimum-absolute-difference-in-bst",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree. &nbsp; Example 1: Input: root = [4,2,6,1,3] Output: 1 Example 2: Input: root = [1,0,48,null,null,12,49] Output: 1 &nbsp; Constraints: The number of nodes in the tree is in the range [2, 104]. 0 &lt;= Node.val &lt;= 105 &nbsp; Note: This question is the same as 783: https://leetcode.com/problems/minimum-distance-between-bst-nodes/"
    },
    {
      "number": 532,
      "title": "K-diff Pairs in an Array",
      "titleSlug": "k-diff-pairs-in-an-array",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Two Pointers",
        "Binary Search",
        "Sorting"
      ],
      "description": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array. A k-diff pair is an integer pair (nums[i], nums[j]), where the following are true: 0 &lt;= i, j &lt; nums.length i != j |nums[i] - nums[j]| == k Notice that |val| denotes the absolute value of val. &nbsp; Example 1: Input: nums = [3,1,4,1,5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5). Although we have two 1s in the input, we should only return the number of unique pairs. Example 2: Input: nums = [1,2,3,4,5], k = 1 Output: 4 Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). Example 3: Input: nums = [1,3,1,5,4], k = 0 Output: 1 Explanation: There is one 0-diff pair in the array, (1, 1). &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 -107 &lt;= nums[i] &lt;= 107 0 &lt;= k &lt;= 107"
    },
    {
      "number": 535,
      "title": "Encode and Decode TinyURL",
      "titleSlug": "encode-and-decode-tinyurl",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Design",
        "Hash Function"
      ],
      "description": "Note: This is a companion problem to the System Design problem: Design TinyURL. TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL. Implement the Solution class: Solution() Initializes the object of the system. String encode(String longUrl) Returns a tiny URL for the given longUrl. String decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object. &nbsp; Example 1: Input: url = &quot;https://leetcode.com/problems/design-tinyurl&quot; Output: &quot;https://leetcode.com/problems/design-tinyurl&quot; Explanation: Solution obj = new Solution(); string tiny = obj.encode(url); // returns the encoded tiny url. string ans = obj.decode(tiny); // returns the original url after decoding it. &nbsp; Constraints: 1 &lt;= url.length &lt;= 104 url is guranteed to be a valid URL."
    },
    {
      "number": 537,
      "title": "Complex Number Multiplication",
      "titleSlug": "complex-number-multiplication",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "String",
        "Simulation"
      ],
      "description": "A complex number can be represented as a string on the form &quot;real+imaginaryi&quot; where: real is the real part and is an integer in the range [-100, 100]. imaginary is the imaginary part and is an integer in the range [-100, 100]. i2 == -1. Given two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications. &nbsp; Example 1: Input: num1 = &quot;1+1i&quot;, num2 = &quot;1+1i&quot; Output: &quot;0+2i&quot; Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i. Example 2: Input: num1 = &quot;1+-1i&quot;, num2 = &quot;1+-1i&quot; Output: &quot;0+-2i&quot; Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i. &nbsp; Constraints: num1 and num2 are valid complex numbers."
    },
    {
      "number": 538,
      "title": "Convert BST to Greater Tree",
      "titleSlug": "convert-bst-to-greater-tree",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only nodes with keys less than the node&#39;s key. The right subtree of a node contains only nodes with keys greater than the node&#39;s key. Both the left and right subtrees must also be binary search trees. &nbsp; Example 1: Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] Example 2: Input: root = [0,null,1] Output: [1,null,1] &nbsp; Constraints: The number of nodes in the tree is in the range [0, 104]. -104 &lt;= Node.val &lt;= 104 All the values in the tree are unique. root is guaranteed to be a valid binary search tree. &nbsp; Note: This question is the same as 1038: https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/"
    },
    {
      "number": 539,
      "title": "Minimum Time Difference",
      "titleSlug": "minimum-time-difference",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math",
        "String",
        "Sorting"
      ],
      "description": "Given a list of 24-hour clock time points in &quot;HH:MM&quot; format, return the minimum minutes difference between any two time-points in the list. &nbsp; Example 1: Input: timePoints = [\"23:59\",\"00:00\"] Output: 1 Example 2: Input: timePoints = [\"00:00\",\"23:59\",\"00:00\"] Output: 0 &nbsp; Constraints: 2 &lt;= timePoints.length &lt;= 2 * 104 timePoints[i] is in the format &quot;HH:MM&quot;."
    },
    {
      "number": 540,
      "title": "Single Element in a Sorted Array",
      "titleSlug": "single-element-in-a-sorted-array",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search"
      ],
      "description": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Return the single element that appears only once. Your solution must run in O(log n) time and O(1) space. &nbsp; Example 1: Input: nums = [1,1,2,3,3,4,4,8,8] Output: 2 Example 2: Input: nums = [3,3,7,7,10,11,11] Output: 10 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 105"
    },
    {
      "number": 541,
      "title": "Reverse String II",
      "titleSlug": "reverse-string-ii",
      "difficulty": "Easy",
      "tags": [
        "Two Pointers",
        "String"
      ],
      "description": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string. If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original. &nbsp; Example 1: Input: s = \"abcdefg\", k = 2 Output: \"bacdfeg\" Example 2: Input: s = \"abcd\", k = 2 Output: \"bacd\" &nbsp; Constraints: 1 &lt;= s.length &lt;= 104 s consists of only lowercase English letters. 1 &lt;= k &lt;= 104"
    },
    {
      "number": 542,
      "title": "01 Matrix",
      "titleSlug": "01-matrix",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell. The distance between two cells sharing a common edge is 1. &nbsp; Example 1: Input: mat = [[0,0,0],[0,1,0],[0,0,0]] Output: [[0,0,0],[0,1,0],[0,0,0]] Example 2: Input: mat = [[0,0,0],[0,1,0],[1,1,1]] Output: [[0,0,0],[0,1,0],[1,2,1]] &nbsp; Constraints: m == mat.length n == mat[i].length 1 &lt;= m, n &lt;= 104 1 &lt;= m * n &lt;= 104 mat[i][j] is either 0 or 1. There is at least one 0 in mat. &nbsp; Note: This question is the same as 1765: https://leetcode.com/problems/map-of-highest-peak/"
    },
    {
      "number": 543,
      "title": "Diameter of Binary Tree",
      "titleSlug": "diameter-of-binary-tree",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them. &nbsp; Example 1: Input: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3]. Example 2: Input: root = [1,2] Output: 1 &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. -100 &lt;= Node.val &lt;= 100"
    },
    {
      "number": 546,
      "title": "Remove Boxes",
      "titleSlug": "remove-boxes",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Memoization"
      ],
      "description": "You are given several boxes with different colors represented by different positive numbers. You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of k boxes, k &gt;= 1), remove them and get k * k points. Return the maximum points you can get. &nbsp; Example 1: Input: boxes = [1,3,2,2,2,3,4,3,1] Output: 23 Explanation: [1, 3, 2, 2, 2, 3, 4, 3, 1] ----&gt; [1, 3, 3, 4, 3, 1] (3*3=9 points) ----&gt; [1, 3, 3, 3, 1] (1*1=1 points) ----&gt; [1, 1] (3*3=9 points) ----&gt; [] (2*2=4 points) Example 2: Input: boxes = [1,1,1] Output: 9 Example 3: Input: boxes = [1] Output: 1 &nbsp; Constraints: 1 &lt;= boxes.length &lt;= 100 1 &lt;= boxes[i]&nbsp;&lt;= 100"
    },
    {
      "number": 547,
      "title": "Number of Provinces",
      "titleSlug": "number-of-provinces",
      "difficulty": "Medium",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Graph"
      ],
      "description": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise. Return the total number of provinces. &nbsp; Example 1: Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]] Output: 2 Example 2: Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]] Output: 3 &nbsp; Constraints: 1 &lt;= n &lt;= 200 n == isConnected.length n == isConnected[i].length isConnected[i][j] is 1 or 0. isConnected[i][i] == 1 isConnected[i][j] == isConnected[j][i]"
    },
    {
      "number": 550,
      "title": "Game Play Analysis IV",
      "titleSlug": "game-play-analysis-iv",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Activity +--------------+---------+ | Column Name | Type | +--------------+---------+ | player_id | int | | device_id | int | | event_date | date | | games_played | int | +--------------+---------+ (player_id, event_date) is the primary key (combination of columns with unique values) of this table. This table shows the activity of players of some games. Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on someday using some device. &nbsp; Write a&nbsp;solution&nbsp;to report the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number of players. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Activity table: +-----------+-----------+------------+--------------+ | player_id | device_id | event_date | games_played | +-----------+-----------+------------+--------------+ | 1 | 2 | 2016-03-01 | 5 | | 1 | 2 | 2016-03-02 | 6 | | 2 | 3 | 2017-06-25 | 1 | | 3 | 1 | 2016-03-02 | 0 | | 3 | 4 | 2018-07-03 | 5 | +-----------+-----------+------------+--------------+ Output: +-----------+ | fraction | +-----------+ | 0.33 | +-----------+ Explanation: Only the player with id 1 logged back in after the first day he had logged in so the answer is 1/3 = 0.33"
    },
    {
      "number": 551,
      "title": "Student Attendance Record I",
      "titleSlug": "student-attendance-record-i",
      "difficulty": "Easy",
      "tags": [
        "String"
      ],
      "description": "You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters: &#39;A&#39;: Absent. &#39;L&#39;: Late. &#39;P&#39;: Present. The student is eligible for an attendance award if they meet both of the following criteria: The student was absent (&#39;A&#39;) for strictly fewer than 2 days total. The student was never late (&#39;L&#39;) for 3 or more consecutive days. Return true if the student is eligible for an attendance award, or false otherwise. &nbsp; Example 1: Input: s = &quot;PPALLP&quot; Output: true Explanation: The student has fewer than 2 absences and was never late 3 or more consecutive days. Example 2: Input: s = &quot;PPALLL&quot; Output: false Explanation: The student was late 3 consecutive days in the last 3 days, so is not eligible for the award. &nbsp; Constraints: 1 &lt;= s.length &lt;= 1000 s[i] is either &#39;A&#39;, &#39;L&#39;, or &#39;P&#39;."
    },
    {
      "number": 552,
      "title": "Student Attendance Record II",
      "titleSlug": "student-attendance-record-ii",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters: &#39;A&#39;: Absent. &#39;L&#39;: Late. &#39;P&#39;: Present. Any student is eligible for an attendance award if they meet both of the following criteria: The student was absent (&#39;A&#39;) for strictly fewer than 2 days total. The student was never late (&#39;L&#39;) for 3 or more consecutive days. Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 109 + 7. &nbsp; Example 1: Input: n = 2 Output: 8 Explanation: There are 8 records with length 2 that are eligible for an award: &quot;PP&quot;, &quot;AP&quot;, &quot;PA&quot;, &quot;LP&quot;, &quot;PL&quot;, &quot;AL&quot;, &quot;LA&quot;, &quot;LL&quot; Only &quot;AA&quot; is not eligible because there are 2 absences (there need to be fewer than 2). Example 2: Input: n = 1 Output: 3 Example 3: Input: n = 10101 Output: 183236316 &nbsp; Constraints: 1 &lt;= n &lt;= 105"
    },
    {
      "number": 553,
      "title": "Optimal Division",
      "titleSlug": "optimal-division",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math",
        "Dynamic Programming"
      ],
      "description": "You are given an integer array nums. The adjacent integers in nums will perform the float division. For example, for nums = [2,3,4], we will evaluate the expression &quot;2/3/4&quot;. However, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum. Return the corresponding expression that has the maximum value in string format. Note: your expression should not contain redundant parenthesis. &nbsp; Example 1: Input: nums = [1000,100,10,2] Output: &quot;1000/(100/10/2)&quot; Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200 However, the bold parenthesis in &quot;1000/((100/10)/2)&quot; are redundant since they do not influence the operation priority. So you should return &quot;1000/(100/10/2)&quot;. Other cases: 1000/(100/10)/2 = 50 1000/(100/(10/2)) = 50 1000/100/10/2 = 0.5 1000/100/(10/2) = 2 Example 2: Input: nums = [2,3,4] Output: &quot;2/(3/4)&quot; Explanation: (2/(3/4)) = 8/3 = 2.667 It can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 10 2 &lt;= nums[i] &lt;= 1000 There is only one optimal division for the given input."
    },
    {
      "number": 554,
      "title": "Brick Wall",
      "titleSlug": "brick-wall",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table"
      ],
      "description": "There is a rectangular brick wall in front of you with n rows of bricks. The ith row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same. Draw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. Given the 2D array wall that contains the information about the wall, return the minimum number of crossed bricks after drawing such a vertical line. &nbsp; Example 1: Input: wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]] Output: 2 Example 2: Input: wall = [[1],[1],[1]] Output: 3 &nbsp; Constraints: n == wall.length 1 &lt;= n &lt;= 104 1 &lt;= wall[i].length &lt;= 104 1 &lt;= sum(wall[i].length) &lt;= 2 * 104 sum(wall[i]) is the same for each row i. 1 &lt;= wall[i][j] &lt;= 231 - 1"
    },
    {
      "number": 556,
      "title": "Next Greater Element III",
      "titleSlug": "next-greater-element-iii",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Two Pointers",
        "String"
      ],
      "description": "Given a positive integer n, find the smallest integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive integer exists, return -1. Note that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return -1. &nbsp; Example 1: Input: n = 12 Output: 21 Example 2: Input: n = 21 Output: -1 &nbsp; Constraints: 1 &lt;= n &lt;= 231 - 1"
    },
    {
      "number": 557,
      "title": "Reverse Words in a String III",
      "titleSlug": "reverse-words-in-a-string-iii",
      "difficulty": "Easy",
      "tags": [
        "Two Pointers",
        "String"
      ],
      "description": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. &nbsp; Example 1: Input: s = &quot;Let&#39;s take LeetCode contest&quot; Output: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot; Example 2: Input: s = &quot;Mr Ding&quot; Output: &quot;rM gniD&quot; &nbsp; Constraints: 1 &lt;= s.length &lt;= 5 * 104 s contains printable ASCII characters. s does not contain any leading or trailing spaces. There is at least one word in s. All the words in s are separated by a single space."
    },
    {
      "number": 558,
      "title": "Logical OR of Two Binary Grids Represented as Quad-Trees",
      "titleSlug": "logical-or-of-two-binary-grids-represented-as-quad-trees",
      "difficulty": "Medium",
      "tags": [
        "Divide and Conquer",
        "Tree"
      ],
      "description": "A Binary Matrix is a matrix in which all the elements are either 0 or 1. Given quadTree1 and quadTree2. quadTree1 represents a n * n binary matrix and quadTree2 represents another n * n binary matrix. Return a Quad-Tree representing the n * n binary matrix which is the result of logical bitwise OR of the two binary matrixes represented by quadTree1 and quadTree2. Notice that you can assign the value of a node to True or False when isLeaf is False, and both are accepted in the answer. A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes: val: True if the node represents a grid of 1&#39;s or False if the node represents a grid of 0&#39;s. isLeaf: True if the node is leaf node on the tree or False if the node has the four children. class Node { public boolean val; public boolean isLeaf; public Node topLeft; public Node topRight; public Node bottomLeft; public Node bottomRight; } We can construct a Quad-Tree from a two-dimensional area using the following steps: If the current grid has the same value (i.e all 1&#39;s or all 0&#39;s) set isLeaf True and set val to the value of the grid and set the four children to Null and stop. If the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo. Recurse for each of the children with the proper sub-grid. If you want to know more about the Quad-Tree, you can refer to the wiki. Quad-Tree format: The input/output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below. It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val]. If the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0. &nbsp; Example 1: Input: quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]] , quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]] Output: [[0,0],[1,1],[1,1],[1,1],[1,0]] Explanation: quadTree1 and quadTree2 are shown above. You can see the binary matrix which is represented by each Quad-Tree. If we apply logical bitwise OR on the two binary matrices we get the binary matrix below which is represented by the result Quad-Tree. Notice that the binary matrices shown are only for illustration, you don&#39;t have to construct the binary matrix to get the result tree. Example 2: Input: quadTree1 = [[1,0]], quadTree2 = [[1,0]] Output: [[1,0]] Explanation: Each tree represents a binary matrix of size 1*1. Each matrix contains only zero. The resulting matrix is of size 1*1 with also zero. &nbsp; Constraints: quadTree1 and quadTree2 are both valid Quad-Trees each representing a n * n grid. n == 2x where 0 &lt;= x &lt;= 9."
    },
    {
      "number": 559,
      "title": "Maximum Depth of N-ary Tree",
      "titleSlug": "maximum-depth-of-n-ary-tree",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search"
      ],
      "description": "Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). &nbsp; Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: 3 Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: 5 &nbsp; Constraints: The total number of nodes is in the range [0, 104]. The depth of the n-ary tree is less than or equal to 1000."
    },
    {
      "number": 560,
      "title": "Subarray Sum Equals K",
      "titleSlug": "subarray-sum-equals-k",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Prefix Sum"
      ],
      "description": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k. A subarray is a contiguous non-empty sequence of elements within an array. &nbsp; Example 1: Input: nums = [1,1,1], k = 2 Output: 2 Example 2: Input: nums = [1,2,3], k = 3 Output: 2 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 2 * 104 -1000 &lt;= nums[i] &lt;= 1000 -107 &lt;= k &lt;= 107"
    },
    {
      "number": 561,
      "title": "Array Partition",
      "titleSlug": "array-partition",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Greedy",
        "Sorting",
        "Counting Sort"
      ],
      "description": "Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum. &nbsp; Example 1: Input: nums = [1,4,3,2] Output: 4 Explanation: All possible pairings (ignoring the ordering of elements) are: 1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 3 2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 3 3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4 So the maximum possible sum is 4. Example 2: Input: nums = [6,2,6,5,1,2] Output: 9 Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9. &nbsp; Constraints: 1 &lt;= n &lt;= 104 nums.length == 2 * n -104 &lt;= nums[i] &lt;= 104"
    },
    {
      "number": 563,
      "title": "Binary Tree Tilt",
      "titleSlug": "binary-tree-tilt",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return the sum of every tree node&#39;s tilt. The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if the node does not have a right child. &nbsp; Example 1: Input: root = [1,2,3] Output: 1 Explanation: Tilt of node 2 : |0-0| = 0 (no children) Tilt of node 3 : |0-0| = 0 (no children) Tilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3) Sum of every tilt : 0 + 0 + 1 = 1 Example 2: Input: root = [4,2,9,3,5,null,7] Output: 15 Explanation: Tilt of node 3 : |0-0| = 0 (no children) Tilt of node 5 : |0-0| = 0 (no children) Tilt of node 7 : |0-0| = 0 (no children) Tilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5) Tilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7) Tilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16) Sum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15 Example 3: Input: root = [21,7,14,1,1,2,2,3,3] Output: 9 &nbsp; Constraints: The number of nodes in the tree is in the range [0, 104]. -1000 &lt;= Node.val &lt;= 1000"
    },
    {
      "number": 564,
      "title": "Find the Closest Palindrome",
      "titleSlug": "find-the-closest-palindrome",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "String"
      ],
      "description": "Given a string n representing an integer, return the closest integer (not including itself), which is a palindrome. If there is a tie, return the smaller one. The closest is defined as the absolute difference minimized between two integers. &nbsp; Example 1: Input: n = &quot;123&quot; Output: &quot;121&quot; Example 2: Input: n = &quot;1&quot; Output: &quot;0&quot; Explanation: 0 and 2 are the closest palindromes but we return the smallest which is 0. &nbsp; Constraints: 1 &lt;= n.length &lt;= 18 n consists of only digits. n does not have leading zeros. n is representing an integer in the range [1, 1018 - 1]."
    },
    {
      "number": 565,
      "title": "Array Nesting",
      "titleSlug": "array-nesting",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Depth-First Search"
      ],
      "description": "You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1]. You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule: The first element in s[k] starts with the selection of the element nums[k] of index = k. The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on. We stop adding right before a duplicate element occurs in s[k]. Return the longest length of a set s[k]. &nbsp; Example 1: Input: nums = [5,4,0,3,1,6,2] Output: 4 Explanation: nums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2. One of the longest sets s[k]: s[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0} Example 2: Input: nums = [0,1,2] Output: 1 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt; nums.length All the values of nums are unique."
    },
    {
      "number": 566,
      "title": "Reshape the Matrix",
      "titleSlug": "reshape-the-matrix",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Matrix",
        "Simulation"
      ],
      "description": "In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data. You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. &nbsp; Example 1: Input: mat = [[1,2],[3,4]], r = 1, c = 4 Output: [[1,2,3,4]] Example 2: Input: mat = [[1,2],[3,4]], r = 2, c = 4 Output: [[1,2],[3,4]] &nbsp; Constraints: m == mat.length n == mat[i].length 1 &lt;= m, n &lt;= 100 -1000 &lt;= mat[i][j] &lt;= 1000 1 &lt;= r, c &lt;= 300"
    },
    {
      "number": 567,
      "title": "Permutation in String",
      "titleSlug": "permutation-in-string",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Two Pointers",
        "String",
        "Sliding Window"
      ],
      "description": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1&#39;s permutations is the substring of s2. &nbsp; Example 1: Input: s1 = &quot;ab&quot;, s2 = &quot;eidbaooo&quot; Output: true Explanation: s2 contains one permutation of s1 (&quot;ba&quot;). Example 2: Input: s1 = &quot;ab&quot;, s2 = &quot;eidboaoo&quot; Output: false &nbsp; Constraints: 1 &lt;= s1.length, s2.length &lt;= 104 s1 and s2 consist of lowercase English letters."
    },
    {
      "number": 570,
      "title": "Managers with at Least 5 Direct Reports",
      "titleSlug": "managers-with-at-least-5-direct-reports",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Employee +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | name | varchar | | department | varchar | | managerId | int | +-------------+---------+ id is the primary key (column with unique values) for this table. Each row of this table indicates the name of an employee, their department, and the id of their manager. If managerId is null, then the employee does not have a manager. No employee will be the manager of themself. &nbsp; Write a solution to find managers with at least five direct reports. Return the result table in any order. The result format is in the following example. &nbsp; Example 1: Input: Employee table: +-----+-------+------------+-----------+ | id | name | department | managerId | +-----+-------+------------+-----------+ | 101 | John | A | null | | 102 | Dan | A | 101 | | 103 | James | A | 101 | | 104 | Amy | A | 101 | | 105 | Anne | A | 101 | | 106 | Ron | B | 101 | +-----+-------+------------+-----------+ Output: +------+ | name | +------+ | John | +------+"
    },
    {
      "number": 572,
      "title": "Subtree of Another Tree",
      "titleSlug": "subtree-of-another-tree",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "String Matching",
        "Binary Tree",
        "Hash Function"
      ],
      "description": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node&#39;s descendants. The tree tree could also be considered as a subtree of itself. &nbsp; Example 1: Input: root = [3,4,5,1,2], subRoot = [4,1,2] Output: true Example 2: Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] Output: false &nbsp; Constraints: The number of nodes in the root tree is in the range [1, 2000]. The number of nodes in the subRoot tree is in the range [1, 1000]. -104 &lt;= root.val &lt;= 104 -104 &lt;= subRoot.val &lt;= 104"
    },
    {
      "number": 575,
      "title": "Distribute Candies",
      "titleSlug": "distribute-candies",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table"
      ],
      "description": "Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor. The doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor&#39;s advice. Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them. &nbsp; Example 1: Input: candyType = [1,1,2,2,3,3] Output: 3 Explanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type. Example 2: Input: candyType = [1,1,2,3] Output: 2 Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types. Example 3: Input: candyType = [6,6,6,6] Output: 1 Explanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type. &nbsp; Constraints: n == candyType.length 2 &lt;= n &lt;= 104 n&nbsp;is even. -105 &lt;= candyType[i] &lt;= 105"
    },
    {
      "number": 576,
      "title": "Out of Boundary Paths",
      "titleSlug": "out-of-boundary-paths",
      "difficulty": "Medium",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn]. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball. Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo 109 + 7. &nbsp; Example 1: Input: m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0 Output: 6 Example 2: Input: m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1 Output: 12 &nbsp; Constraints: 1 &lt;= m, n &lt;= 50 0 &lt;= maxMove &lt;= 50 0 &lt;= startRow &lt; m 0 &lt;= startColumn &lt; n"
    },
    {
      "number": 577,
      "title": "Employee Bonus",
      "titleSlug": "employee-bonus",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Employee +-------------+---------+ | Column Name | Type | +-------------+---------+ | empId | int | | name | varchar | | supervisor | int | | salary | int | +-------------+---------+ empId is the column with unique values for this table. Each row of this table indicates the name and the ID of an employee in addition to their salary and the id of their manager. &nbsp; Table: Bonus +-------------+------+ | Column Name | Type | +-------------+------+ | empId | int | | bonus | int | +-------------+------+ empId is the column of unique values for this table. empId is a foreign key (reference column) to empId from the Employee table. Each row of this table contains the id of an employee and their respective bonus. &nbsp; Write a solution to report the name and bonus amount of each employee with a bonus less than 1000. Return the result table in any order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Employee table: +-------+--------+------------+--------+ | empId | name | supervisor | salary | +-------+--------+------------+--------+ | 3 | Brad | null | 4000 | | 1 | John | 3 | 1000 | | 2 | Dan | 3 | 2000 | | 4 | Thomas | 3 | 4000 | +-------+--------+------------+--------+ Bonus table: +-------+-------+ | empId | bonus | +-------+-------+ | 2 | 500 | | 4 | 2000 | +-------+-------+ Output: +------+-------+ | name | bonus | +------+-------+ | Brad | null | | John | null | | Dan | 500 | +------+-------+"
    },
    {
      "number": 581,
      "title": "Shortest Unsorted Continuous Subarray",
      "titleSlug": "shortest-unsorted-continuous-subarray",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Stack",
        "Greedy",
        "Sorting",
        "Monotonic Stack"
      ],
      "description": "Given an integer array nums, you need to find one continuous subarray such that if you only sort this subarray in non-decreasing order, then the whole array will be sorted in non-decreasing order. Return the shortest such subarray and output its length. &nbsp; Example 1: Input: nums = [2,6,4,8,10,9,15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Example 2: Input: nums = [1,2,3,4] Output: 0 Example 3: Input: nums = [1] Output: 0 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 -105 &lt;= nums[i] &lt;= 105 &nbsp; Follow up: Can you solve it in O(n) time complexity?"
    },
    {
      "number": 583,
      "title": "Delete Operation for Two Strings",
      "titleSlug": "delete-operation-for-two-strings",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same. In one step, you can delete exactly one character in either string. &nbsp; Example 1: Input: word1 = &quot;sea&quot;, word2 = &quot;eat&quot; Output: 2 Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;. Example 2: Input: word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot; Output: 4 &nbsp; Constraints: 1 &lt;= word1.length, word2.length &lt;= 500 word1 and word2 consist of only lowercase English letters."
    },
    {
      "number": 584,
      "title": "Find Customer Referee",
      "titleSlug": "find-customer-referee",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Customer +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | name | varchar | | referee_id | int | +-------------+---------+ In SQL, id is the primary key column for this table. Each row of this table indicates the id of a customer, their name, and the id of the customer who referred them. &nbsp; Find the names of the customer that are not referred by the customer with id = 2. Return the result table in any order. The result format is in the following example. &nbsp; Example 1: Input: Customer table: +----+------+------------+ | id | name | referee_id | +----+------+------------+ | 1 | Will | null | | 2 | Jane | null | | 3 | Alex | 2 | | 4 | Bill | null | | 5 | Zack | 1 | | 6 | Mark | 2 | +----+------+------------+ Output: +------+ | name | +------+ | Will | | Jane | | Bill | | Zack | +------+"
    },
    {
      "number": 585,
      "title": "Investments in 2016",
      "titleSlug": "investments-in-2016",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Insurance +-------------+-------+ | Column Name | Type | +-------------+-------+ | pid | int | | tiv_2015 | float | | tiv_2016 | float | | lat | float | | lon | float | +-------------+-------+ pid is the primary key (column with unique values) for this table. Each row of this table contains information about one policy where: pid is the policyholder&#39;s policy ID. tiv_2015 is the total investment value in 2015 and tiv_2016 is the total investment value in 2016. lat is the latitude of the policy holder&#39;s city. It&#39;s guaranteed that lat is not NULL. lon is the longitude of the policy holder&#39;s city. It&#39;s guaranteed that lon is not NULL. &nbsp; Write a solution to report the sum of all total investment values in 2016 tiv_2016, for all policyholders who: have the same tiv_2015 value as one or more other policyholders, and are not located in the same city as any other policyholder (i.e., the (lat, lon) attribute pairs must be unique). Round tiv_2016 to two decimal places. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Insurance table: +-----+----------+----------+-----+-----+ | pid | tiv_2015 | tiv_2016 | lat | lon | +-----+----------+----------+-----+-----+ | 1 | 10 | 5 | 10 | 10 | | 2 | 20 | 20 | 20 | 20 | | 3 | 10 | 30 | 20 | 20 | | 4 | 10 | 40 | 40 | 40 | +-----+----------+----------+-----+-----+ Output: +----------+ | tiv_2016 | +----------+ | 45.00 | +----------+ Explanation: The first record in the table, like the last record, meets both of the two criteria. The tiv_2015 value 10 is the same as the third and fourth records, and its location is unique. The second record does not meet any of the two criteria. Its tiv_2015 is not like any other policyholders and its location is the same as the third record, which makes the third record fail, too. So, the result is the sum of tiv_2016 of the first and last record, which is 45."
    },
    {
      "number": 586,
      "title": "Customer Placing the Largest Number of Orders",
      "titleSlug": "customer-placing-the-largest-number-of-orders",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Orders +-----------------+----------+ | Column Name | Type | +-----------------+----------+ | order_number | int | | customer_number | int | +-----------------+----------+ order_number is the primary key (column with unique values) for this table. This table contains information about the order ID and the customer ID. &nbsp; Write a solution to find the customer_number for the customer who has placed the largest number of orders. The test cases are generated so that exactly one customer will have placed more orders than any other customer. The result format is in the following example. &nbsp; Example 1: Input: Orders table: +--------------+-----------------+ | order_number | customer_number | +--------------+-----------------+ | 1 | 1 | | 2 | 2 | | 3 | 3 | | 4 | 3 | +--------------+-----------------+ Output: +-----------------+ | customer_number | +-----------------+ | 3 | +-----------------+ Explanation: The customer with number 3 has two orders, which is greater than either customer 1 or 2 because each of them only has one order. So the result is customer_number 3. &nbsp; Follow up: What if more than one customer has the largest number of orders, can you find all the customer_number in this case?"
    },
    {
      "number": 587,
      "title": "Erect the Fence",
      "titleSlug": "erect-the-fence",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Geometry"
      ],
      "description": "You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden. Fence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if all the trees are enclosed. Return the coordinates of trees that are exactly located on the fence perimeter. You may return the answer in any order. &nbsp; Example 1: Input: trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] Output: [[1,1],[2,0],[4,2],[3,3],[2,4]] Explanation: All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence. Example 2: Input: trees = [[1,2],[2,2],[4,2]] Output: [[4,2],[2,2],[1,2]] Explanation: The fence forms a line that passes through all the trees. &nbsp; Constraints: 1 &lt;= trees.length &lt;= 3000 trees[i].length == 2 0 &lt;= xi, yi &lt;= 100 All the given positions are unique."
    },
    {
      "number": 589,
      "title": "N-ary Tree Preorder Traversal",
      "titleSlug": "n-ary-tree-preorder-traversal",
      "difficulty": "Easy",
      "tags": [
        "Stack",
        "Tree",
        "Depth-First Search"
      ],
      "description": "Given the root of an n-ary tree, return the preorder traversal of its nodes&#39; values. Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples) &nbsp; Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: [1,3,5,6,2,4] Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10] &nbsp; Constraints: The number of nodes in the tree is in the range [0, 104]. 0 &lt;= Node.val &lt;= 104 The height of the n-ary tree is less than or equal to 1000. &nbsp; Follow up: Recursive solution is trivial, could you do it iteratively?"
    },
    {
      "number": 590,
      "title": "N-ary Tree Postorder Traversal",
      "titleSlug": "n-ary-tree-postorder-traversal",
      "difficulty": "Easy",
      "tags": [
        "Stack",
        "Tree",
        "Depth-First Search"
      ],
      "description": "Given the root of an n-ary tree, return the postorder traversal of its nodes&#39; values. Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples) &nbsp; Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: [5,6,3,2,4,1] Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1] &nbsp; Constraints: The number of nodes in the tree is in the range [0, 104]. 0 &lt;= Node.val &lt;= 104 The height of the n-ary tree is less than or equal to 1000. &nbsp; Follow up: Recursive solution is trivial, could you do it iteratively?"
    },
    {
      "number": 591,
      "title": "Tag Validator",
      "titleSlug": "tag-validator",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Stack"
      ],
      "description": "Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold: The code must be wrapped in a valid closed tag. Otherwise, the code is invalid. A closed tag (not necessarily valid) has exactly the following format : &lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;. Among them, &lt;TAG_NAME&gt; is the start tag, and &lt;/TAG_NAME&gt; is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid. A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid. A valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched &lt;, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested. A &lt; is unmatched if you cannot find a subsequent &gt;. And when you find a &lt; or &lt;/, all the subsequent characters until the next &gt; should be parsed as TAG_NAME (not necessarily valid). The cdata has the following format : &lt;![CDATA[CDATA_CONTENT]]&gt;. The range of CDATA_CONTENT is defined as the characters between &lt;![CDATA[ and the first subsequent ]]&gt;. CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters. &nbsp; Example 1: Input: code = &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;&quot; Output: true Explanation: The code is wrapped in a closed tag : &lt;DIV&gt; and &lt;/DIV&gt;. The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. Although CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true. Example 2: Input: code = &quot;&lt;DIV&gt;&gt;&gt; ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;&quot; Output: true Explanation: We first separate the code into : start_tag|tag_content|end_tag. start_tag -&gt; &quot;&lt;DIV&gt;&quot; end_tag -&gt; &quot;&lt;/DIV&gt;&quot; tag_content could also be separated into : text1|cdata|text2. text1 -&gt; &quot;&gt;&gt; ![cdata[]] &quot; cdata -&gt; &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot;, where the CDATA_CONTENT is &quot;&lt;div&gt;]&gt;&quot; text2 -&gt; &quot;]]&gt;&gt;]&quot; The reason why start_tag is NOT &quot;&lt;DIV&gt;&gt;&gt;&quot; is because of the rule 6. The reason why cdata is NOT &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot; is because of the rule 7. Example 3: Input: code = &quot;&lt;A&gt; &lt;B&gt; &lt;/A&gt; &lt;/B&gt;&quot; Output: false Explanation: Unbalanced. If &quot;&lt;A&gt;&quot; is closed, then &quot;&lt;B&gt;&quot; must be unmatched, and vice versa. &nbsp; Constraints: 1 &lt;= code.length &lt;= 500 code consists of English letters, digits, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;/&#39;, &#39;!&#39;, &#39;[&#39;, &#39;]&#39;, &#39;.&#39;, and &#39; &#39;."
    },
    {
      "number": 592,
      "title": "Fraction Addition and Subtraction",
      "titleSlug": "fraction-addition-and-subtraction",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "String",
        "Simulation"
      ],
      "description": "Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format. The final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1. &nbsp; Example 1: Input: expression = &quot;-1/2+1/2&quot; Output: &quot;0/1&quot; Example 2: Input: expression = &quot;-1/2+1/2+1/3&quot; Output: &quot;1/3&quot; Example 3: Input: expression = &quot;1/3-1/2&quot; Output: &quot;-1/6&quot; &nbsp; Constraints: The input string only contains &#39;0&#39; to &#39;9&#39;, &#39;/&#39;, &#39;+&#39; and &#39;-&#39;. So does the output. Each fraction (input and output) has the format &plusmn;numerator/denominator. If the first input fraction or the output is positive, then &#39;+&#39; will be omitted. The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range [1, 10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above. The number of given fractions will be in the range [1, 10]. The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int."
    },
    {
      "number": 593,
      "title": "Valid Square",
      "titleSlug": "valid-square",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Geometry"
      ],
      "description": "Given the coordinates of four points in 2D space p1, p2, p3 and p4, return true if the four points construct a square. The coordinate of a point pi is represented as [xi, yi]. The input is not given in any order. A valid square has four equal sides with positive length and four equal angles (90-degree angles). &nbsp; Example 1: Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] Output: true Example 2: Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12] Output: false Example 3: Input: p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1] Output: true &nbsp; Constraints: p1.length == p2.length == p3.length == p4.length == 2 -104 &lt;= xi, yi &lt;= 104"
    },
    {
      "number": 594,
      "title": "Longest Harmonious Subsequence",
      "titleSlug": "longest-harmonious-subsequence",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Sliding Window",
        "Sorting",
        "Counting"
      ],
      "description": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1. Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences. &nbsp; Example 1: Input: nums = [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3]. Example 2: Input: nums = [1,2,3,4] Output: 2 Explanation: The longest harmonious subsequences are [1,2], [2,3], and [3,4], all of which have a length of 2. Example 3: Input: nums = [1,1,1,1] Output: 0 Explanation: No harmonic subsequence exists. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 2 * 104 -109 &lt;= nums[i] &lt;= 109"
    },
    {
      "number": 595,
      "title": "Big Countries",
      "titleSlug": "big-countries",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: World +-------------+---------+ | Column Name | Type | +-------------+---------+ | name | varchar | | continent | varchar | | area | int | | population | int | | gdp | bigint | +-------------+---------+ name is the primary key (column with unique values) for this table. Each row of this table gives information about the name of a country, the continent to which it belongs, its area, the population, and its GDP value. &nbsp; A country is big if: it has an area of at least&nbsp;three million (i.e., 3000000 km2), or it has a population of at least&nbsp;twenty-five million (i.e., 25000000). Write a solution to find the name, population, and area of the big countries. Return the result table in any order. The result format is in the following example. &nbsp; Example 1: Input: World table: +-------------+-----------+---------+------------+--------------+ | name | continent | area | population | gdp | +-------------+-----------+---------+------------+--------------+ | Afghanistan | Asia | 652230 | 25500100 | 20343000000 | | Albania | Europe | 28748 | 2831741 | 12960000000 | | Algeria | Africa | 2381741 | 37100000 | 188681000000 | | Andorra | Europe | 468 | 78115 | 3712000000 | | Angola | Africa | 1246700 | 20609294 | 100990000000 | +-------------+-----------+---------+------------+--------------+ Output: +-------------+------------+---------+ | name | population | area | +-------------+------------+---------+ | Afghanistan | 25500100 | 652230 | | Algeria | 37100000 | 2381741 | +-------------+------------+---------+"
    },
    {
      "number": 596,
      "title": "Classes More Than 5 Students",
      "titleSlug": "classes-more-than-5-students",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Courses +-------------+---------+ | Column Name | Type | +-------------+---------+ | student | varchar | | class | varchar | +-------------+---------+ (student, class) is the primary key (combination of columns with unique values) for this table. Each row of this table indicates the name of a student and the class in which they are enrolled. &nbsp; Write a solution to find all the classes that have at least five students. Return the result table in any order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Courses table: +---------+----------+ | student | class | +---------+----------+ | A | Math | | B | English | | C | Math | | D | Biology | | E | Math | | F | Computer | | G | Math | | H | Math | | I | Math | +---------+----------+ Output: +---------+ | class | +---------+ | Math | +---------+ Explanation: - Math has 6 students, so we include it. - English has 1 student, so we do not include it. - Biology has 1 student, so we do not include it. - Computer has 1 student, so we do not include it."
    },
    {
      "number": 598,
      "title": "Range Addition II",
      "titleSlug": "range-addition-ii",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math"
      ],
      "description": "You are given an m x n matrix M initialized with all 0&#39;s and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 &lt;= x &lt; ai and 0 &lt;= y &lt; bi. Count and return the number of maximum integers in the matrix after performing all the operations. &nbsp; Example 1: Input: m = 3, n = 3, ops = [[2,2],[3,3]] Output: 4 Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4. Example 2: Input: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]] Output: 4 Example 3: Input: m = 3, n = 3, ops = [] Output: 9 &nbsp; Constraints: 1 &lt;= m, n &lt;= 4 * 104 0 &lt;= ops.length &lt;= 104 ops[i].length == 2 1 &lt;= ai &lt;= m 1 &lt;= bi &lt;= n"
    },
    {
      "number": 599,
      "title": "Minimum Index Sum of Two Lists",
      "titleSlug": "minimum-index-sum-of-two-lists",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "Given two arrays of strings list1 and list2, find the common strings with the least index sum. A common string is a string that appeared in both list1 and list2. A common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings. Return all the common strings with the least index sum. Return the answer in any order. &nbsp; Example 1: Input: list1 = [&quot;Shogun&quot;,&quot;Tapioca Express&quot;,&quot;Burger King&quot;,&quot;KFC&quot;], list2 = [&quot;Piatti&quot;,&quot;The Grill at Torrey Pines&quot;,&quot;Hungry Hunter Steakhouse&quot;,&quot;Shogun&quot;] Output: [&quot;Shogun&quot;] Explanation: The only common string is &quot;Shogun&quot;. Example 2: Input: list1 = [&quot;Shogun&quot;,&quot;Tapioca Express&quot;,&quot;Burger King&quot;,&quot;KFC&quot;], list2 = [&quot;KFC&quot;,&quot;Shogun&quot;,&quot;Burger King&quot;] Output: [&quot;Shogun&quot;] Explanation: The common string with the least index sum is &quot;Shogun&quot; with index sum = (0 + 1) = 1. Example 3: Input: list1 = [&quot;happy&quot;,&quot;sad&quot;,&quot;good&quot;], list2 = [&quot;sad&quot;,&quot;happy&quot;,&quot;good&quot;] Output: [&quot;sad&quot;,&quot;happy&quot;] Explanation: There are three common strings: &quot;happy&quot; with index sum = (0 + 1) = 1. &quot;sad&quot; with index sum = (1 + 0) = 1. &quot;good&quot; with index sum = (2 + 2) = 4. The strings with the least index sum are &quot;sad&quot; and &quot;happy&quot;. &nbsp; Constraints: 1 &lt;= list1.length, list2.length &lt;= 1000 1 &lt;= list1[i].length, list2[i].length &lt;= 30 list1[i] and list2[i] consist of spaces &#39; &#39; and English letters. All the strings of list1 are unique. All the strings of list2 are unique. There is at least a common string between list1 and list2."
    },
    {
      "number": 600,
      "title": "Non-negative Integers without Consecutive Ones",
      "titleSlug": "non-negative-integers-without-consecutive-ones",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "Given a positive integer n, return the number of the integers in the range [0, n] whose binary representations do not contain consecutive ones. &nbsp; Example 1: Input: n = 5 Output: 5 Explanation: Here are the non-negative integers &lt;= 5 with their corresponding binary representations: 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. Example 2: Input: n = 1 Output: 2 Example 3: Input: n = 2 Output: 3 &nbsp; Constraints: 1 &lt;= n &lt;= 109"
    },
    {
      "number": 601,
      "title": "Human Traffic of Stadium",
      "titleSlug": "human-traffic-of-stadium",
      "difficulty": "Hard",
      "tags": [
        "Database"
      ],
      "description": "Table: Stadium +---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | visit_date | date | | people | int | +---------------+---------+ visit_date is the column with unique values for this table. Each row of this table contains the visit date and visit id to the stadium with the number of people during the visit. As the id increases, the date increases as well. &nbsp; Write a solution to display the records with three or more rows with consecutive id&#39;s, and the number of people is greater than or equal to 100 for each. Return the result table ordered by visit_date in ascending order. The result format is in the following example. &nbsp; Example 1: Input: Stadium table: +------+------------+-----------+ | id | visit_date | people | +------+------------+-----------+ | 1 | 2017-01-01 | 10 | | 2 | 2017-01-02 | 109 | | 3 | 2017-01-03 | 150 | | 4 | 2017-01-04 | 99 | | 5 | 2017-01-05 | 145 | | 6 | 2017-01-06 | 1455 | | 7 | 2017-01-07 | 199 | | 8 | 2017-01-09 | 188 | +------+------------+-----------+ Output: +------+------------+-----------+ | id | visit_date | people | +------+------------+-----------+ | 5 | 2017-01-05 | 145 | | 6 | 2017-01-06 | 1455 | | 7 | 2017-01-07 | 199 | | 8 | 2017-01-09 | 188 | +------+------------+-----------+ Explanation: The four rows with ids 5, 6, 7, and 8 have consecutive ids and each of them has &gt;= 100 people attended. Note that row 8 was included even though the visit_date was not the next day after row 7. The rows with ids 2 and 3 are not included because we need at least three consecutive ids."
    },
    {
      "number": 602,
      "title": "Friend Requests II: Who Has the Most Friends",
      "titleSlug": "friend-requests-ii-who-has-the-most-friends",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: RequestAccepted +----------------+---------+ | Column Name | Type | +----------------+---------+ | requester_id | int | | accepter_id | int | | accept_date | date | +----------------+---------+ (requester_id, accepter_id) is the primary key (combination of columns with unique values) for this table. This table contains the ID of the user who sent the request, the ID of the user who received the request, and the date when the request was accepted. &nbsp; Write a solution to find the people who have the most friends and the most friends number. The test cases are generated so that only one person has the most friends. The result format is in the following example. &nbsp; Example 1: Input: RequestAccepted table: +--------------+-------------+-------------+ | requester_id | accepter_id | accept_date | +--------------+-------------+-------------+ | 1 | 2 | 2016/06/03 | | 1 | 3 | 2016/06/08 | | 2 | 3 | 2016/06/08 | | 3 | 4 | 2016/06/09 | +--------------+-------------+-------------+ Output: +----+-----+ | id | num | +----+-----+ | 3 | 3 | +----+-----+ Explanation: The person with id 3 is a friend of people 1, 2, and 4, so he has three friends in total, which is the most number than any others. &nbsp; Follow up: In the real world, multiple people could have the same most number of friends. Could you find all these people in this case?"
    },
    {
      "number": 605,
      "title": "Can Place Flowers",
      "titleSlug": "can-place-flowers",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Greedy"
      ],
      "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots. Given an integer array flowerbed containing 0&#39;s and 1&#39;s, where 0 means empty and 1 means not empty, and an integer n, return true&nbsp;if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise. &nbsp; Example 1: Input: flowerbed = [1,0,0,0,1], n = 1 Output: true Example 2: Input: flowerbed = [1,0,0,0,1], n = 2 Output: false &nbsp; Constraints: 1 &lt;= flowerbed.length &lt;= 2 * 104 flowerbed[i] is 0 or 1. There are no two adjacent flowers in flowerbed. 0 &lt;= n &lt;= flowerbed.length"
    },
    {
      "number": 606,
      "title": "Construct String from Binary Tree",
      "titleSlug": "construct-string-from-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root node of a binary tree, your task is to create a string representation of the tree following a specific set of formatting rules. The representation should be based on a preorder traversal of the binary tree and must adhere to the following guidelines: Node Representation: Each node in the tree should be represented by its integer value. Parentheses for Children: If a node has at least one child (either left or right), its children should be represented inside parentheses. Specifically: If a node has a left child, the value of the left child should be enclosed in parentheses immediately following the node&#39;s value. If a node has a right child, the value of the right child should also be enclosed in parentheses. The parentheses for the right child should follow those of the left child. Omitting Empty Parentheses: Any empty parentheses pairs (i.e., ()) should be omitted from the final string representation of the tree, with one specific exception: when a node has a right child but no left child. In such cases, you must include an empty pair of parentheses to indicate the absence of the left child. This ensures that the one-to-one mapping between the string representation and the original binary tree structure is maintained. In summary, empty parentheses pairs should be omitted when a node has only a left child or no children. However, when a node has a right child but no left child, an empty pair of parentheses must precede the representation of the right child to reflect the tree&#39;s structure accurately. &nbsp; Example 1: Input: root = [1,2,3,4] Output: &quot;1(2(4))(3)&quot; Explanation: Originally, it needs to be &quot;1(2(4)())(3()())&quot;, but you need to omit all the empty parenthesis pairs. And it will be &quot;1(2(4))(3)&quot;. Example 2: Input: root = [1,2,3,null,4] Output: &quot;1(2()(4))(3)&quot; Explanation: Almost the same as the first example, except the () after 2 is necessary to indicate the absence of a left child for 2 and the presence of a right child. &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. -1000 &lt;= Node.val &lt;= 1000"
    },
    {
      "number": 607,
      "title": "Sales Person",
      "titleSlug": "sales-person",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: SalesPerson +-----------------+---------+ | Column Name | Type | +-----------------+---------+ | sales_id | int | | name | varchar | | salary | int | | commission_rate | int | | hire_date | date | +-----------------+---------+ sales_id is the primary key (column with unique values) for this table. Each row of this table indicates the name and the ID of a salesperson alongside their salary, commission rate, and hire date. &nbsp; Table: Company +-------------+---------+ | Column Name | Type | +-------------+---------+ | com_id | int | | name | varchar | | city | varchar | +-------------+---------+ com_id is the primary key (column with unique values) for this table. Each row of this table indicates the name and the ID of a company and the city in which the company is located. &nbsp; Table: Orders +-------------+------+ | Column Name | Type | +-------------+------+ | order_id | int | | order_date | date | | com_id | int | | sales_id | int | | amount | int | +-------------+------+ order_id is the primary key (column with unique values) for this table. com_id is a foreign key (reference column) to com_id from the Company table. sales_id is a foreign key (reference column) to sales_id from the SalesPerson table. Each row of this table contains information about one order. This includes the ID of the company, the ID of the salesperson, the date of the order, and the amount paid. &nbsp; Write a solution to find the names of all the salespersons who did not have any orders related to the company with the name &quot;RED&quot;. Return the result table in any order. The result format is in the following example. &nbsp; Example 1: Input: SalesPerson table: +----------+------+--------+-----------------+------------+ | sales_id | name | salary | commission_rate | hire_date | +----------+------+--------+-----------------+------------+ | 1 | John | 100000 | 6 | 4/1/2006 | | 2 | Amy | 12000 | 5 | 5/1/2010 | | 3 | Mark | 65000 | 12 | 12/25/2008 | | 4 | Pam | 25000 | 25 | 1/1/2005 | | 5 | Alex | 5000 | 10 | 2/3/2007 | +----------+------+--------+-----------------+------------+ Company table: +--------+--------+----------+ | com_id | name | city | +--------+--------+----------+ | 1 | RED | Boston | | 2 | ORANGE | New York | | 3 | YELLOW | Boston | | 4 | GREEN | Austin | +--------+--------+----------+ Orders table: +----------+------------+--------+----------+--------+ | order_id | order_date | com_id | sales_id | amount | +----------+------------+--------+----------+--------+ | 1 | 1/1/2014 | 3 | 4 | 10000 | | 2 | 2/1/2014 | 4 | 5 | 5000 | | 3 | 3/1/2014 | 1 | 1 | 50000 | | 4 | 4/1/2014 | 1 | 4 | 25000 | +----------+------------+--------+----------+--------+ Output: +------+ | name | +------+ | Amy | | Mark | | Alex | +------+ Explanation: According to orders 3 and 4 in the Orders table, it is easy to tell that only salesperson John and Pam have sales to company RED, so we report all the other names in the table salesperson."
    },
    {
      "number": 608,
      "title": "Tree Node",
      "titleSlug": "tree-node",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Tree +-------------+------+ | Column Name | Type | +-------------+------+ | id | int | | p_id | int | +-------------+------+ id is the column with unique values for this table. Each row of this table contains information about the id of a node and the id of its parent node in a tree. The given structure is always a valid tree. &nbsp; Each node in the tree can be one of three types: &quot;Leaf&quot;: if the node is a leaf node. &quot;Root&quot;: if the node is the root of the tree. &quot;Inner&quot;: If the node is neither a leaf node nor a root node. Write a solution to report the type of each node in the tree. Return the result table in any order. The result format is in the following example. &nbsp; Example 1: Input: Tree table: +----+------+ | id | p_id | +----+------+ | 1 | null | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 2 | +----+------+ Output: +----+-------+ | id | type | +----+-------+ | 1 | Root | | 2 | Inner | | 3 | Leaf | | 4 | Leaf | | 5 | Leaf | +----+-------+ Explanation: Node 1 is the root node because its parent node is null and it has child nodes 2 and 3. Node 2 is an inner node because it has parent node 1 and child node 4 and 5. Nodes 3, 4, and 5 are leaf nodes because they have parent nodes and they do not have child nodes. Example 2: Input: Tree table: +----+------+ | id | p_id | +----+------+ | 1 | null | +----+------+ Output: +----+-------+ | id | type | +----+-------+ | 1 | Root | +----+-------+ Explanation: If there is only one node on the tree, you only need to output its root attributes. &nbsp; Note: This question is the same as 3054: Binary Tree Nodes."
    },
    {
      "number": 609,
      "title": "Find Duplicate File in System",
      "titleSlug": "find-duplicate-file-in-system",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order. A group of duplicate files consists of at least two files that have the same content. A single directory info string in the input list has the following format: &quot;root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)&quot; It means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory &quot;root/d1/d2/.../dm&quot;. Note that n &gt;= 1 and m &gt;= 0. If m = 0, it means the directory is just the root directory. The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: &quot;directory_path/file_name.txt&quot; &nbsp; Example 1: Input: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"] Output: [[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]] Example 2: Input: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"] Output: [[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]] &nbsp; Constraints: 1 &lt;= paths.length &lt;= 2 * 104 1 &lt;= paths[i].length &lt;= 3000 1 &lt;= sum(paths[i].length) &lt;= 5 * 105 paths[i] consist of English letters, digits, &#39;/&#39;, &#39;.&#39;, &#39;(&#39;, &#39;)&#39;, and &#39; &#39;. You may assume no files or directories share the same name in the same directory. You may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info. &nbsp; Follow up: Imagine you are given a real file system, how will you search files? DFS or BFS? If the file content is very large (GB level), how will you modify your solution? If you can only read the file by 1kb each time, how will you modify your solution? What is the time complexity of your modified solution? What is the most time-consuming part and memory-consuming part of it? How to optimize? How to make sure the duplicated files you find are not false positive?"
    },
    {
      "number": 610,
      "title": "Triangle Judgement",
      "titleSlug": "triangle-judgement",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Triangle +-------------+------+ | Column Name | Type | +-------------+------+ | x | int | | y | int | | z | int | +-------------+------+ In SQL, (x, y, z) is the primary key column for this table. Each row of this table contains the lengths of three line segments. &nbsp; Report for every three line segments whether they can form a triangle. Return the result table in any order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Triangle table: +----+----+----+ | x | y | z | +----+----+----+ | 13 | 15 | 30 | | 10 | 20 | 15 | +----+----+----+ Output: +----+----+----+----------+ | x | y | z | triangle | +----+----+----+----------+ | 13 | 15 | 30 | No | | 10 | 20 | 15 | Yes | +----+----+----+----------+"
    },
    {
      "number": 611,
      "title": "Valid Triangle Number",
      "titleSlug": "valid-triangle-number",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Binary Search",
        "Greedy",
        "Sorting"
      ],
      "description": "Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle. &nbsp; Example 1: Input: nums = [2,2,3,4] Output: 3 Explanation: Valid combinations are: 2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3 Example 2: Input: nums = [4,2,3,4] Output: 4 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000"
    },
    {
      "number": 617,
      "title": "Merge Two Binary Trees",
      "titleSlug": "merge-two-binary-trees",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "You are given two binary trees root1 and root2. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree. Note: The merging process must start from the root nodes of both trees. &nbsp; Example 1: Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] Output: [3,4,5,5,4,null,7] Example 2: Input: root1 = [1], root2 = [1,2] Output: [2,2] &nbsp; Constraints: The number of nodes in both trees is in the range [0, 2000]. -104 &lt;= Node.val &lt;= 104"
    },
    {
      "number": 619,
      "title": "Biggest Single Number",
      "titleSlug": "biggest-single-number",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: MyNumbers +-------------+------+ | Column Name | Type | +-------------+------+ | num | int | +-------------+------+ This table may contain duplicates (In other words, there is no primary key for this table in SQL). Each row of this table contains an integer. &nbsp; A single number is a number that appeared only once in the MyNumbers table. Find the largest single number. If there is no single number, report null. The result format is in the following example. &nbsp; Example 1: Input: MyNumbers table: +-----+ | num | +-----+ | 8 | | 8 | | 3 | | 3 | | 1 | | 4 | | 5 | | 6 | +-----+ Output: +-----+ | num | +-----+ | 6 | +-----+ Explanation: The single numbers are 1, 4, 5, and 6. Since 6 is the largest single number, we return it. Example 2: Input: MyNumbers table: +-----+ | num | +-----+ | 8 | | 8 | | 7 | | 7 | | 3 | | 3 | | 3 | +-----+ Output: +------+ | num | +------+ | null | +------+ Explanation: There are no single numbers in the input table so we return null."
    },
    {
      "number": 620,
      "title": "Not Boring Movies",
      "titleSlug": "not-boring-movies",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Cinema +----------------+----------+ | Column Name | Type | +----------------+----------+ | id | int | | movie | varchar | | description | varchar | | rating | float | +----------------+----------+ id is the primary key (column with unique values) for this table. Each row contains information about the name of a movie, its genre, and its rating. rating is a 2 decimal places float in the range [0, 10] &nbsp; Write a solution to report the movies with an odd-numbered ID and a description that is not &quot;boring&quot;. Return the result table ordered by rating in descending order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Cinema table: +----+------------+-------------+--------+ | id | movie | description | rating | +----+------------+-------------+--------+ | 1 | War | great 3D | 8.9 | | 2 | Science | fiction | 8.5 | | 3 | irish | boring | 6.2 | | 4 | Ice song | Fantacy | 8.6 | | 5 | House card | Interesting | 9.1 | +----+------------+-------------+--------+ Output: +----+------------+-------------+--------+ | id | movie | description | rating | +----+------------+-------------+--------+ | 5 | House card | Interesting | 9.1 | | 1 | War | great 3D | 8.9 | +----+------------+-------------+--------+ Explanation: We have three movies with odd-numbered IDs: 1, 3, and 5. The movie with ID = 3 is boring so we do not include it in the answer."
    },
    {
      "number": 621,
      "title": "Task Scheduler",
      "titleSlug": "task-scheduler",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Greedy",
        "Sorting",
        "Heap (Priority Queue)",
        "Counting"
      ],
      "description": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there&#39;s a constraint: there has to be a gap of at least n intervals between two tasks with the same label. Return the minimum number of CPU intervals required to complete all tasks. &nbsp; Example 1: Input: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2 Output: 8 Explanation: A possible sequence is: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B. After completing task A, you must wait two intervals before doing A again. The same applies to task B. In the 3rd interval, neither A nor B can be done, so you idle. By the 4th interval, you can do A again as 2 intervals have passed. Example 2: Input: tasks = [&quot;A&quot;,&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;D&quot;,&quot;B&quot;], n = 1 Output: 6 Explanation: A possible sequence is: A -&gt; B -&gt; C -&gt; D -&gt; A -&gt; B. With a cooling interval of 1, you can repeat a task after just one other task. Example 3: Input: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;, &quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 3 Output: 10 Explanation: A possible sequence is: A -&gt; B -&gt; idle -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; idle -&gt; A -&gt; B. There are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks. &nbsp; Constraints: 1 &lt;= tasks.length &lt;= 104 tasks[i] is an uppercase English letter. 0 &lt;= n &lt;= 100"
    },
    {
      "number": 622,
      "title": "Design Circular Queue",
      "titleSlug": "design-circular-queue",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Linked List",
        "Design",
        "Queue"
      ],
      "description": "Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle, and the last position is connected back to the first position to make a circle. It is also called &quot;Ring Buffer&quot;. One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Implement the MyCircularQueue class: MyCircularQueue(k) Initializes the object with the size of the queue to be k. int Front() Gets the front item from the queue. If the queue is empty, return -1. int Rear() Gets the last item from the queue. If the queue is empty, return -1. boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful. boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful. boolean isEmpty() Checks whether the circular queue is empty or not. boolean isFull() Checks whether the circular queue is full or not. You must solve the problem without using the built-in queue data structure in your programming language.&nbsp; &nbsp; Example 1: Input [&quot;MyCircularQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;, &quot;isFull&quot;, &quot;deQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;] [[3], [1], [2], [3], [4], [], [], [], [4], []] Output [null, true, true, true, false, 3, true, true, true, 4] Explanation MyCircularQueue myCircularQueue = new MyCircularQueue(3); myCircularQueue.enQueue(1); // return True myCircularQueue.enQueue(2); // return True myCircularQueue.enQueue(3); // return True myCircularQueue.enQueue(4); // return False myCircularQueue.Rear(); // return 3 myCircularQueue.isFull(); // return True myCircularQueue.deQueue(); // return True myCircularQueue.enQueue(4); // return True myCircularQueue.Rear(); // return 4 &nbsp; Constraints: 1 &lt;= k &lt;= 1000 0 &lt;= value &lt;= 1000 At most 3000 calls will be made to&nbsp;enQueue, deQueue,&nbsp;Front,&nbsp;Rear,&nbsp;isEmpty, and&nbsp;isFull."
    },
    {
      "number": 623,
      "title": "Add One Row to Tree",
      "titleSlug": "add-one-row-to-tree",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth. Note that the root node is at depth 1. The adding rule is: Given the integer depth, for each not null tree node cur at the depth depth - 1, create two tree nodes with value val as cur&#39;s left subtree root and right subtree root. cur&#39;s original left subtree should be the left subtree of the new left subtree root. cur&#39;s original right subtree should be the right subtree of the new right subtree root. If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root&#39;s left subtree. &nbsp; Example 1: Input: root = [4,2,6,3,1,5], val = 1, depth = 2 Output: [4,1,1,2,null,null,6,3,1,5] Example 2: Input: root = [4,2,null,3,1], val = 1, depth = 3 Output: [4,2,null,1,1,3,null,null,1] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. The depth of the tree is in the range [1, 104]. -100 &lt;= Node.val &lt;= 100 -105 &lt;= val &lt;= 105 1 &lt;= depth &lt;= the depth of tree + 1"
    },
    {
      "number": 624,
      "title": "Maximum Distance in Arrays",
      "titleSlug": "maximum-distance-in-arrays",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Greedy"
      ],
      "description": "You are given m arrays, where each array is sorted in ascending order. You can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a - b|. Return the maximum distance. &nbsp; Example 1: Input: arrays = [[1,2,3],[4,5],[1,2,3]] Output: 4 Explanation: One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array. Example 2: Input: arrays = [[1],[1]] Output: 0 &nbsp; Constraints: m == arrays.length 2 &lt;= m &lt;= 105 1 &lt;= arrays[i].length &lt;= 500 -104 &lt;= arrays[i][j] &lt;= 104 arrays[i] is sorted in ascending order. There will be at most 105 integers in all the arrays."
    },
    {
      "number": 626,
      "title": "Exchange Seats",
      "titleSlug": "exchange-seats",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Seat +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | student | varchar | +-------------+---------+ id is the primary key (unique value) column for this table. Each row of this table indicates the name and the ID of a student. The ID sequence always starts from 1 and increments continuously. &nbsp; Write a solution to swap the seat id of every two consecutive students. If the number of students is odd, the id of the last student is not swapped. Return the result table ordered by id in ascending order. The result format is in the following example. &nbsp; Example 1: Input: Seat table: +----+---------+ | id | student | +----+---------+ | 1 | Abbot | | 2 | Doris | | 3 | Emerson | | 4 | Green | | 5 | Jeames | +----+---------+ Output: +----+---------+ | id | student | +----+---------+ | 1 | Doris | | 2 | Abbot | | 3 | Green | | 4 | Emerson | | 5 | Jeames | +----+---------+ Explanation: Note that if the number of students is odd, there is no need to change the last one&#39;s seat."
    },
    {
      "number": 627,
      "title": "Swap Salary",
      "titleSlug": "swap-salary",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Salary +-------------+----------+ | Column Name | Type | +-------------+----------+ | id | int | | name | varchar | | sex | ENUM | | salary | int | +-------------+----------+ id is the primary key (column with unique values) for this table. The sex column is ENUM (category) value of type (&#39;m&#39;, &#39;f&#39;). The table contains information about an employee. &nbsp; Write a solution to swap all &#39;f&#39; and &#39;m&#39; values (i.e., change all &#39;f&#39; values to &#39;m&#39; and vice versa) with a single update statement and no intermediate temporary tables. Note that you must write a single update statement, do not write any select statement for this problem. The result format is in the following example. &nbsp; Example 1: Input: Salary table: +----+------+-----+--------+ | id | name | sex | salary | +----+------+-----+--------+ | 1 | A | m | 2500 | | 2 | B | f | 1500 | | 3 | C | m | 5500 | | 4 | D | f | 500 | +----+------+-----+--------+ Output: +----+------+-----+--------+ | id | name | sex | salary | +----+------+-----+--------+ | 1 | A | f | 2500 | | 2 | B | m | 1500 | | 3 | C | f | 5500 | | 4 | D | m | 500 | +----+------+-----+--------+ Explanation: (1, A) and (3, C) were changed from &#39;m&#39; to &#39;f&#39;. (2, B) and (4, D) were changed from &#39;f&#39; to &#39;m&#39;."
    },
    {
      "number": 628,
      "title": "Maximum Product of Three Numbers",
      "titleSlug": "maximum-product-of-three-numbers",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math",
        "Sorting"
      ],
      "description": "Given an integer array nums, find three numbers whose product is maximum and return the maximum product. &nbsp; Example 1: Input: nums = [1,2,3] Output: 6 Example 2: Input: nums = [1,2,3,4] Output: 24 Example 3: Input: nums = [-1,-2,-3] Output: -6 &nbsp; Constraints: 3 &lt;= nums.length &lt;=&nbsp;104 -1000 &lt;= nums[i] &lt;= 1000"
    },
    {
      "number": 629,
      "title": "K Inverse Pairs Array",
      "titleSlug": "k-inverse-pairs-array",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 &lt;= i &lt; j &lt; nums.length and nums[i] &gt; nums[j]. Given two integers n and k, return the number of different arrays consisting of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 109 + 7. &nbsp; Example 1: Input: n = 3, k = 0 Output: 1 Explanation: Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs. Example 2: Input: n = 3, k = 1 Output: 2 Explanation: The array [1,3,2] and [2,1,3] have exactly 1 inverse pair. &nbsp; Constraints: 1 &lt;= n &lt;= 1000 0 &lt;= k &lt;= 1000"
    },
    {
      "number": 630,
      "title": "Course Schedule III",
      "titleSlug": "course-schedule-iii",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Greedy",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "There are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi. You will start on the 1st day and you cannot take two or more courses simultaneously. Return the maximum number of courses that you can take. &nbsp; Example 1: Input: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]] Output: 3 Explanation: There are totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date. Example 2: Input: courses = [[1,2]] Output: 1 Example 3: Input: courses = [[3,2],[4,3]] Output: 0 &nbsp; Constraints: 1 &lt;= courses.length &lt;= 104 1 &lt;= durationi, lastDayi &lt;= 104"
    },
    {
      "number": 632,
      "title": "Smallest Range Covering Elements from K Lists",
      "titleSlug": "smallest-range-covering-elements-from-k-lists",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Greedy",
        "Sliding Window",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "You have k lists of sorted integers in non-decreasing&nbsp;order. Find the smallest range that includes at least one number from each of the k lists. We define the range [a, b] is smaller than range [c, d] if b - a &lt; d - c or a &lt; c if b - a == d - c. &nbsp; Example 1: Input: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]] Output: [20,24] Explanation: List 1: [4, 10, 15, 24,26], 24 is in range [20,24]. List 2: [0, 9, 12, 20], 20 is in range [20,24]. List 3: [5, 18, 22, 30], 22 is in range [20,24]. Example 2: Input: nums = [[1,2,3],[1,2,3],[1,2,3]] Output: [1,1] &nbsp; Constraints: nums.length == k 1 &lt;= k &lt;= 3500 1 &lt;= nums[i].length &lt;= 50 -105 &lt;= nums[i][j] &lt;= 105 nums[i]&nbsp;is sorted in non-decreasing order."
    },
    {
      "number": 633,
      "title": "Sum of Square Numbers",
      "titleSlug": "sum-of-square-numbers",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Two Pointers",
        "Binary Search"
      ],
      "description": "Given a non-negative integer c, decide whether there&#39;re two integers a and b such that a2 + b2 = c. &nbsp; Example 1: Input: c = 5 Output: true Explanation: 1 * 1 + 2 * 2 = 5 Example 2: Input: c = 3 Output: false &nbsp; Constraints: 0 &lt;= c &lt;= 231 - 1"
    },
    {
      "number": 636,
      "title": "Exclusive Time of Functions",
      "titleSlug": "exclusive-time-of-functions",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Stack"
      ],
      "description": "On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1. Function calls are stored in a call stack: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp. You are given a list logs, where logs[i] represents the ith log message formatted as a string &quot;{function_id}:{&quot;start&quot; | &quot;end&quot;}:{timestamp}&quot;. For example, &quot;0:start:3&quot; means a function call with function ID 0 started at the beginning of timestamp 3, and &quot;1:end:2&quot; means a function call with function ID 1 ended at the end of timestamp 2. Note that a function can be called multiple times, possibly recursively. A function&#39;s exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1 = 3. Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i. &nbsp; Example 1: Input: n = 2, logs = [&quot;0:start:0&quot;,&quot;1:start:2&quot;,&quot;1:end:5&quot;,&quot;0:end:6&quot;] Output: [3,4] Explanation: Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1. Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5. Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time. So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing. Example 2: Input: n = 1, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;0:start:6&quot;,&quot;0:end:6&quot;,&quot;0:end:7&quot;] Output: [8] Explanation: Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself. Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time. Function 0 (initial call) resumes execution then immediately calls itself again. Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time. Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time. So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing. Example 3: Input: n = 2, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:6&quot;,&quot;1:end:6&quot;,&quot;0:end:7&quot;] Output: [7,1] Explanation: Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself. Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time. Function 0 (initial call) resumes execution then immediately calls function 1. Function 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6. Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time. So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing. &nbsp; Constraints: 1 &lt;= n &lt;= 100 1 &lt;= logs.length &lt;= 500 0 &lt;= function_id &lt; n 0 &lt;= timestamp &lt;= 109 No two start events will happen at the same timestamp. No two end events will happen at the same timestamp. Each function has an &quot;end&quot; log for each &quot;start&quot; log."
    },
    {
      "number": 637,
      "title": "Average of Levels in Binary Tree",
      "titleSlug": "average-of-levels-in-binary-tree",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted. &nbsp; Example 1: Input: root = [3,9,20,null,null,15,7] Output: [3.00000,14.50000,11.00000] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Example 2: Input: root = [3,9,20,15,7] Output: [3.00000,14.50000,11.00000] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. -231 &lt;= Node.val &lt;= 231 - 1"
    },
    {
      "number": 638,
      "title": "Shopping Offers",
      "titleSlug": "shopping-offers",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Backtracking",
        "Bit Manipulation",
        "Memoization",
        "Bitmask"
      ],
      "description": "In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price. You are given an integer array price where price[i] is the price of the ith item, and an integer array needs where needs[i] is the number of pieces of the ith item you want to buy. You are also given an array special where special[i] is of size n + 1 where special[i][j] is the number of pieces of the jth item in the ith offer and special[i][n] (i.e., the last integer in the array) is the price of the ith offer. Return the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want. &nbsp; Example 1: Input: price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2] Output: 14 Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. In special offer 1, you can pay $5 for 3A and 0B In special offer 2, you can pay $10 for 1A and 2B. You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A. Example 2: Input: price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1] Output: 11 Explanation: The price of A is $2, and $3 for B, $4 for C. You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. You cannot add more items, though only $9 for 2A ,2B and 1C. &nbsp; Constraints: n == price.length == needs.length 1 &lt;= n &lt;= 6 0 &lt;= price[i], needs[i] &lt;= 10 1 &lt;= special.length &lt;= 100 special[i].length == n + 1 0 &lt;= special[i][j] &lt;= 50 The input is generated that at least one of special[i][j] is non-zero for 0 &lt;= j &lt;= n - 1."
    },
    {
      "number": 639,
      "title": "Decode Ways II",
      "titleSlug": "decode-ways-ii",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping: &#39;A&#39; -&gt; &quot;1&quot; &#39;B&#39; -&gt; &quot;2&quot; ... &#39;Z&#39; -&gt; &quot;26&quot; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &quot;11106&quot; can be mapped into: &quot;AAJF&quot; with the grouping (1 1 10 6) &quot;KJF&quot; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because &quot;06&quot; cannot be mapped into &#39;F&#39; since &quot;6&quot; is different from &quot;06&quot;. In addition to the mapping above, an encoded message may contain the &#39;*&#39; character, which can represent any digit from &#39;1&#39; to &#39;9&#39; (&#39;0&#39; is excluded). For example, the encoded message &quot;1*&quot; may represent any of the encoded messages &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, or &quot;19&quot;. Decoding &quot;1*&quot; is equivalent to decoding any of the encoded messages it can represent. Given a string s consisting of digits and &#39;*&#39; characters, return the number of ways to decode it. Since the answer may be very large, return it modulo 109 + 7. &nbsp; Example 1: Input: s = &quot;*&quot; Output: 9 Explanation: The encoded message can represent any of the encoded messages &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, or &quot;9&quot;. Each of these can be decoded to the strings &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, and &quot;I&quot; respectively. Hence, there are a total of 9 ways to decode &quot;*&quot;. Example 2: Input: s = &quot;1*&quot; Output: 18 Explanation: The encoded message can represent any of the encoded messages &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, or &quot;19&quot;. Each of these encoded messages have 2 ways to be decoded (e.g. &quot;11&quot; can be decoded to &quot;AA&quot; or &quot;K&quot;). Hence, there are a total of 9 * 2 = 18 ways to decode &quot;1*&quot;. Example 3: Input: s = &quot;2*&quot; Output: 15 Explanation: The encoded message can represent any of the encoded messages &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;26&quot;, &quot;27&quot;, &quot;28&quot;, or &quot;29&quot;. &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, and &quot;26&quot; have 2 ways of being decoded, but &quot;27&quot;, &quot;28&quot;, and &quot;29&quot; only have 1 way. Hence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode &quot;2*&quot;. &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s[i] is a digit or &#39;*&#39;."
    },
    {
      "number": 640,
      "title": "Solve the Equation",
      "titleSlug": "solve-the-equation",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "String",
        "Simulation"
      ],
      "description": "Solve a given equation and return the value of &#39;x&#39; in the form of a string &quot;x=#value&quot;. The equation contains only &#39;+&#39;, &#39;-&#39; operation, the variable &#39;x&#39; and its coefficient. You should return &quot;No solution&quot; if there is no solution for the equation, or &quot;Infinite solutions&quot; if there are infinite solutions for the equation. If there is exactly one solution for the equation, we ensure that the value of &#39;x&#39; is an integer. &nbsp; Example 1: Input: equation = &quot;x+5-3+x=6+x-2&quot; Output: &quot;x=2&quot; Example 2: Input: equation = &quot;x=x&quot; Output: &quot;Infinite solutions&quot; Example 3: Input: equation = &quot;2x=x&quot; Output: &quot;x=0&quot; &nbsp; Constraints: 3 &lt;= equation.length &lt;= 1000 equation has exactly one &#39;=&#39;. equation consists of integers with an absolute value in the range [0, 100] without any leading zeros, and the variable &#39;x&#39;. The input is generated that if there is a single solution, it will be an integer."
    },
    {
      "number": 641,
      "title": "Design Circular Deque",
      "titleSlug": "design-circular-deque",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Linked List",
        "Design",
        "Queue"
      ],
      "description": "Design your implementation of the circular double-ended queue (deque). Implement the MyCircularDeque class: MyCircularDeque(int k) Initializes the deque with a maximum size of k. boolean insertFront() Adds an item at the front of Deque. Returns true if the operation is successful, or false otherwise. boolean insertLast() Adds an item at the rear of Deque. Returns true if the operation is successful, or false otherwise. boolean deleteFront() Deletes an item from the front of Deque. Returns true if the operation is successful, or false otherwise. boolean deleteLast() Deletes an item from the rear of Deque. Returns true if the operation is successful, or false otherwise. int getFront() Returns the front item from the Deque. Returns -1 if the deque is empty. int getRear() Returns the last item from Deque. Returns -1 if the deque is empty. boolean isEmpty() Returns true if the deque is empty, or false otherwise. boolean isFull() Returns true if the deque is full, or false otherwise. &nbsp; Example 1: Input [&quot;MyCircularDeque&quot;, &quot;insertLast&quot;, &quot;insertLast&quot;, &quot;insertFront&quot;, &quot;insertFront&quot;, &quot;getRear&quot;, &quot;isFull&quot;, &quot;deleteLast&quot;, &quot;insertFront&quot;, &quot;getFront&quot;] [[3], [1], [2], [3], [4], [], [], [], [4], []] Output [null, true, true, true, false, 2, true, true, true, 4] Explanation MyCircularDeque myCircularDeque = new MyCircularDeque(3); myCircularDeque.insertLast(1); // return True myCircularDeque.insertLast(2); // return True myCircularDeque.insertFront(3); // return True myCircularDeque.insertFront(4); // return False, the queue is full. myCircularDeque.getRear(); // return 2 myCircularDeque.isFull(); // return True myCircularDeque.deleteLast(); // return True myCircularDeque.insertFront(4); // return True myCircularDeque.getFront(); // return 4 &nbsp; Constraints: 1 &lt;= k &lt;= 1000 0 &lt;= value &lt;= 1000 At most 2000 calls will be made to insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull."
    },
    {
      "number": 643,
      "title": "Maximum Average Subarray I",
      "titleSlug": "maximum-average-subarray-i",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Sliding Window"
      ],
      "description": "You are given an integer array nums consisting of n elements, and an integer k. Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted. &nbsp; Example 1: Input: nums = [1,12,-5,-6,50,3], k = 4 Output: 12.75000 Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75 Example 2: Input: nums = [5], k = 1 Output: 5.00000 &nbsp; Constraints: n == nums.length 1 &lt;= k &lt;= n &lt;= 105 -104 &lt;= nums[i] &lt;= 104"
    },
    {
      "number": 645,
      "title": "Set Mismatch",
      "titleSlug": "set-mismatch",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Bit Manipulation",
        "Sorting"
      ],
      "description": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array nums representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array. &nbsp; Example 1: Input: nums = [1,2,2,4] Output: [2,3] Example 2: Input: nums = [1,1] Output: [1,2] &nbsp; Constraints: 2 &lt;= nums.length &lt;= 104 1 &lt;= nums[i] &lt;= 104"
    },
    {
      "number": 646,
      "title": "Maximum Length of Pair Chain",
      "titleSlug": "maximum-length-of-pair-chain",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Greedy",
        "Sorting"
      ],
      "description": "You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti &lt; righti. A pair p2 = [c, d] follows a pair p1 = [a, b] if b &lt; c. A chain of pairs can be formed in this fashion. Return the length longest chain which can be formed. You do not need to use up all the given intervals. You can select pairs in any order. &nbsp; Example 1: Input: pairs = [[1,2],[2,3],[3,4]] Output: 2 Explanation: The longest chain is [1,2] -&gt; [3,4]. Example 2: Input: pairs = [[1,2],[7,8],[4,5]] Output: 3 Explanation: The longest chain is [1,2] -&gt; [4,5] -&gt; [7,8]. &nbsp; Constraints: n == pairs.length 1 &lt;= n &lt;= 1000 -1000 &lt;= lefti &lt; righti &lt;= 1000"
    },
    {
      "number": 647,
      "title": "Palindromic Substrings",
      "titleSlug": "palindromic-substrings",
      "difficulty": "Medium",
      "tags": [
        "Two Pointers",
        "String",
        "Dynamic Programming"
      ],
      "description": "Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string. &nbsp; Example 1: Input: s = &quot;abc&quot; Output: 3 Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;. Example 2: Input: s = &quot;aaa&quot; Output: 6 Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;. &nbsp; Constraints: 1 &lt;= s.length &lt;= 1000 s consists of lowercase English letters."
    },
    {
      "number": 648,
      "title": "Replace Words",
      "titleSlug": "replace-words",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Trie"
      ],
      "description": "In English, we have a concept called root, which can be followed by some other word to form another longer word - let&#39;s call this word derivative. For example, when the root &quot;help&quot; is followed by the word &quot;ful&quot;, we can form a derivative &quot;helpful&quot;. Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the derivatives in the sentence with the root forming it. If a derivative can be replaced by more than one root, replace it with the root that has the shortest length. Return the sentence after the replacement. &nbsp; Example 1: Input: dictionary = [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot; Output: &quot;the cat was rat by the bat&quot; Example 2: Input: dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], sentence = &quot;aadsfasf absbs bbab cadsfafs&quot; Output: &quot;a a b c&quot; &nbsp; Constraints: 1 &lt;= dictionary.length &lt;= 1000 1 &lt;= dictionary[i].length &lt;= 100 dictionary[i] consists of only lower-case letters. 1 &lt;= sentence.length &lt;= 106 sentence consists of only lower-case letters and spaces. The number of words in sentence is in the range [1, 1000] The length of each word in sentence is in the range [1, 1000] Every two consecutive words in sentence will be separated by exactly one space. sentence does not have leading or trailing spaces."
    },
    {
      "number": 649,
      "title": "Dota2 Senate",
      "titleSlug": "dota2-senate",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Greedy",
        "Queue"
      ],
      "description": "In the world of Dota2, there are two parties: the Radiant and the Dire. The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights: Ban one senator&#39;s right: A senator can make another senator lose all his rights in this and all the following rounds. Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game. Given a string senate representing each senator&#39;s party belonging. The character &#39;R&#39; and &#39;D&#39; represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n. The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure. Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be &quot;Radiant&quot; or &quot;Dire&quot;. &nbsp; Example 1: Input: senate = &quot;RD&quot; Output: &quot;Radiant&quot; Explanation: The first senator comes from Radiant and he can just ban the next senator&#39;s right in round 1. And the second senator can&#39;t exercise any rights anymore since his right has been banned. And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote. Example 2: Input: senate = &quot;RDD&quot; Output: &quot;Dire&quot; Explanation: The first senator comes from Radiant and he can just ban the next senator&#39;s right in round 1. And the second senator can&#39;t exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator&#39;s right in round 1. And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote. &nbsp; Constraints: n == senate.length 1 &lt;= n &lt;= 104 senate[i] is either &#39;R&#39; or &#39;D&#39;."
    },
    {
      "number": 650,
      "title": "2 Keys Keyboard",
      "titleSlug": "2-keys-keyboard",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Dynamic Programming"
      ],
      "description": "There is only one character &#39;A&#39; on the screen of a notepad. You can perform one of two operations on this notepad for each step: Copy All: You can copy all the characters present on the screen (a partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given an integer n, return the minimum number of operations to get the character &#39;A&#39; exactly n times on the screen. &nbsp; Example 1: Input: n = 3 Output: 3 Explanation: Initially, we have one character &#39;A&#39;. In step 1, we use Copy All operation. In step 2, we use Paste operation to get &#39;AA&#39;. In step 3, we use Paste operation to get &#39;AAA&#39;. Example 2: Input: n = 1 Output: 0 &nbsp; Constraints: 1 &lt;= n &lt;= 1000"
    },
    {
      "number": 652,
      "title": "Find Duplicate Subtrees",
      "titleSlug": "find-duplicate-subtrees",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root&nbsp;of a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with the same node values. &nbsp; Example 1: Input: root = [1,2,3,4,null,2,4,null,null,4] Output: [[2,4],[4]] Example 2: Input: root = [2,1,1] Output: [[1]] Example 3: Input: root = [2,2,2,3,null,3,null] Output: [[2,3],[3]] &nbsp; Constraints: The number of the nodes in the tree will be in the range [1, 5000] -200 &lt;= Node.val &lt;= 200"
    },
    {
      "number": 653,
      "title": "Two Sum IV - Input is a BST",
      "titleSlug": "two-sum-iv-input-is-a-bst",
      "difficulty": "Easy",
      "tags": [
        "Hash Table",
        "Two Pointers",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise. &nbsp; Example 1: Input: root = [5,3,6,2,4,null,7], k = 9 Output: true Example 2: Input: root = [5,3,6,2,4,null,7], k = 28 Output: false &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. -104 &lt;= Node.val &lt;= 104 root is guaranteed to be a valid binary search tree. -105 &lt;= k &lt;= 105"
    },
    {
      "number": 654,
      "title": "Maximum Binary Tree",
      "titleSlug": "maximum-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Divide and Conquer",
        "Stack",
        "Tree",
        "Monotonic Stack",
        "Binary Tree"
      ],
      "description": "You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm: Create a root node whose value is the maximum value in nums. Recursively build the left subtree on the subarray prefix to the left of the maximum value. Recursively build the right subtree on the subarray suffix to the right of the maximum value. Return the maximum binary tree built from nums. &nbsp; Example 1: Input: nums = [3,2,1,6,0,5] Output: [6,3,5,null,2,0,null,null,1] Explanation: The recursive calls are as follow: - The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5]. - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1]. - Empty array, so no child. - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1]. - Empty array, so no child. - Only one element, so child is a node with value 1. - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is []. - Only one element, so child is a node with value 0. - Empty array, so no child. Example 2: Input: nums = [3,2,1] Output: [3,null,2,null,1] &nbsp; Constraints: 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 All integers in nums are unique."
    },
    {
      "number": 655,
      "title": "Print Binary Tree",
      "titleSlug": "print-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, construct a 0-indexed m x n string matrix res that represents a formatted layout of the tree. The formatted layout matrix should be constructed using the following rules: The height of the tree is height&nbsp;and the number of rows m should be equal to height + 1. The number of columns n should be equal to 2height+1 - 1. Place the root node in the middle of the top row (more formally, at location res[0][(n-1)/2]). For each node that has been placed in the matrix at position res[r][c], place its left child at res[r+1][c-2height-r-1] and its right child at res[r+1][c+2height-r-1]. Continue this process until all the nodes in the tree have been placed. Any empty cells should contain the empty string &quot;&quot;. Return the constructed matrix res. &nbsp; Example 1: Input: root = [1,2] Output: [[&quot;&quot;,&quot;1&quot;,&quot;&quot;], &nbsp;[&quot;2&quot;,&quot;&quot;,&quot;&quot;]] Example 2: Input: root = [1,2,3,null,4] Output: [[&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;1&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;], &nbsp;[&quot;&quot;,&quot;2&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;3&quot;,&quot;&quot;], &nbsp;[&quot;&quot;,&quot;&quot;,&quot;4&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 210]. -99 &lt;= Node.val &lt;= 99 The depth of the tree will be in the range [1, 10]."
    },
    {
      "number": 657,
      "title": "Robot Return to Origin",
      "titleSlug": "robot-return-to-origin",
      "difficulty": "Easy",
      "tags": [
        "String",
        "Simulation"
      ],
      "description": "There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. You are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are &#39;R&#39; (right), &#39;L&#39; (left), &#39;U&#39; (up), and &#39;D&#39; (down). Return true if the robot returns to the origin after it finishes all of its moves, or false otherwise. Note: The way that the robot is &quot;facing&quot; is irrelevant. &#39;R&#39; will always make the robot move to the right once, &#39;L&#39; will always make it move left, etc. Also, assume that the magnitude of the robot&#39;s movement is the same for each move. &nbsp; Example 1: Input: moves = &quot;UD&quot; Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true. Example 2: Input: moves = &quot;LL&quot; Output: false Explanation: The robot moves left twice. It ends up two &quot;moves&quot; to the left of the origin. We return false because it is not at the origin at the end of its moves. &nbsp; Constraints: 1 &lt;= moves.length &lt;= 2 * 104 moves only contains the characters &#39;U&#39;, &#39;D&#39;, &#39;L&#39; and &#39;R&#39;."
    },
    {
      "number": 658,
      "title": "Find K Closest Elements",
      "titleSlug": "find-k-closest-elements",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Binary Search",
        "Sliding Window",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order. An integer a is closer to x than an integer b if: |a - x| &lt; |b - x|, or |a - x| == |b - x| and a &lt; b &nbsp; Example 1: Input: arr = [1,2,3,4,5], k = 4, x = 3 Output: [1,2,3,4] Example 2: Input: arr = [1,1,2,3,4,5], k = 4, x = -1 Output: [1,1,2,3] &nbsp; Constraints: 1 &lt;= k &lt;= arr.length 1 &lt;= arr.length &lt;= 104 arr is sorted in ascending order. -104 &lt;= arr[i], x &lt;= 104"
    },
    {
      "number": 659,
      "title": "Split Array into Consecutive Subsequences",
      "titleSlug": "split-array-into-consecutive-subsequences",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Greedy",
        "Heap (Priority Queue)"
      ],
      "description": "You are given an integer array nums that is sorted in non-decreasing order. Determine if it is possible to split nums into one or more subsequences such that both of the following conditions are true: Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer). All subsequences have a length of 3 or more. Return true if you can split nums according to the above conditions, or false otherwise. A subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not). &nbsp; Example 1: Input: nums = [1,2,3,3,4,5] Output: true Explanation: nums can be split into the following subsequences: [1,2,3,3,4,5] --&gt; 1, 2, 3 [1,2,3,3,4,5] --&gt; 3, 4, 5 Example 2: Input: nums = [1,2,3,3,4,4,5,5] Output: true Explanation: nums can be split into the following subsequences: [1,2,3,3,4,4,5,5] --&gt; 1, 2, 3, 4, 5 [1,2,3,3,4,4,5,5] --&gt; 3, 4, 5 Example 3: Input: nums = [1,2,3,4,4,5] Output: false Explanation: It is impossible to split nums into consecutive increasing subsequences of length 3 or more. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 -1000 &lt;= nums[i] &lt;= 1000 nums is sorted in non-decreasing order."
    },
    {
      "number": 661,
      "title": "Image Smoother",
      "titleSlug": "image-smoother",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Matrix"
      ],
      "description": "An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother). Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it. &nbsp; Example 1: Input: img = [[1,1,1],[1,0,1],[1,1,1]] Output: [[0,0,0],[0,0,0],[0,0,0]] Explanation: For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0 Example 2: Input: img = [[100,200,100],[200,50,200],[100,200,100]] Output: [[137,141,137],[141,138,141],[137,141,137]] Explanation: For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137 For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141 For the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138 &nbsp; Constraints: m == img.length n == img[i].length 1 &lt;= m, n &lt;= 200 0 &lt;= img[i][j] &lt;= 255"
    },
    {
      "number": 662,
      "title": "Maximum Width of Binary Tree",
      "titleSlug": "maximum-width-of-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation. It is guaranteed that the answer will in the range of a 32-bit signed integer. &nbsp; Example 1: Input: root = [1,3,2,5,3,null,9] Output: 4 Explanation: The maximum width exists in the third level with length 4 (5,3,null,9). Example 2: Input: root = [1,3,2,5,null,null,9,6,null,7] Output: 7 Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7). Example 3: Input: root = [1,3,2,5] Output: 2 Explanation: The maximum width exists in the second level with length 2 (3,2). &nbsp; Constraints: The number of nodes in the tree is in the range [1, 3000]. -100 &lt;= Node.val &lt;= 100"
    },
    {
      "number": 664,
      "title": "Strange Printer",
      "titleSlug": "strange-printer",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "There is a strange printer with the following two special properties: The printer can only print a sequence of the same character each time. At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters. Given a string s, return the minimum number of turns the printer needed to print it. &nbsp; Example 1: Input: s = &quot;aaabbb&quot; Output: 2 Explanation: Print &quot;aaa&quot; first and then print &quot;bbb&quot;. Example 2: Input: s = &quot;aba&quot; Output: 2 Explanation: Print &quot;aaa&quot; first and then print &quot;b&quot; from the second place of the string, which will cover the existing character &#39;a&#39;. &nbsp; Constraints: 1 &lt;= s.length &lt;= 100 s consists of lowercase English letters."
    },
    {
      "number": 665,
      "title": "Non-decreasing Array",
      "titleSlug": "non-decreasing-array",
      "difficulty": "Medium",
      "tags": [
        "Array"
      ],
      "description": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element. We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2). &nbsp; Example 1: Input: nums = [4,2,3] Output: true Explanation: You could modify the first 4 to 1 to get a non-decreasing array. Example 2: Input: nums = [4,2,1] Output: false Explanation: You cannot get a non-decreasing array by modifying at most one element. &nbsp; Constraints: n == nums.length 1 &lt;= n &lt;= 104 -105 &lt;= nums[i] &lt;= 105"
    },
    {
      "number": 667,
      "title": "Beautiful Arrangement II",
      "titleSlug": "beautiful-arrangement-ii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math"
      ],
      "description": "Given two integers n and k, construct a list answer that contains n different positive integers ranging from 1 to n and obeys the following requirement: Suppose this list is answer =&nbsp;[a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers. Return the list answer. If there multiple valid answers, return any of them. &nbsp; Example 1: Input: n = 3, k = 1 Output: [1,2,3] Explanation: The [1,2,3] has three different positive integers ranging from 1 to 3, and the [1,1] has exactly 1 distinct integer: 1 Example 2: Input: n = 3, k = 2 Output: [1,3,2] Explanation: The [1,3,2] has three different positive integers ranging from 1 to 3, and the [2,1] has exactly 2 distinct integers: 1 and 2. &nbsp; Constraints: 1 &lt;= k &lt; n &lt;= 104"
    },
    {
      "number": 668,
      "title": "Kth Smallest Number in Multiplication Table",
      "titleSlug": "kth-smallest-number-in-multiplication-table",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "Binary Search"
      ],
      "description": "Nearly everyone has used the Multiplication Table. The multiplication table of size m x n is an integer matrix mat where mat[i][j] == i * j (1-indexed). Given three integers m, n, and k, return the kth smallest element in the m x n multiplication table. &nbsp; Example 1: Input: m = 3, n = 3, k = 5 Output: 3 Explanation: The 5th smallest number is 3. Example 2: Input: m = 2, n = 3, k = 6 Output: 6 Explanation: The 6th smallest number is 6. &nbsp; Constraints: 1 &lt;= m, n &lt;= 3 * 104 1 &lt;= k &lt;= m * n"
    },
    {
      "number": 669,
      "title": "Trim a Binary Search Tree",
      "titleSlug": "trim-a-binary-search-tree",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&#39;s descendant should remain a descendant). It can be proven that there is a unique answer. Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds. &nbsp; Example 1: Input: root = [1,0,2], low = 1, high = 2 Output: [1,null,2] Example 2: Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3 Output: [3,2,null,1] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. 0 &lt;= Node.val &lt;= 104 The value of each node in the tree is unique. root is guaranteed to be a valid binary search tree. 0 &lt;= low &lt;= high &lt;= 104"
    },
    {
      "number": 670,
      "title": "Maximum Swap",
      "titleSlug": "maximum-swap",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Greedy"
      ],
      "description": "You are given an integer num. You can swap two digits at most once to get the maximum valued number. Return the maximum valued number you can get. &nbsp; Example 1: Input: num = 2736 Output: 7236 Explanation: Swap the number 2 and the number 7. Example 2: Input: num = 9973 Output: 9973 Explanation: No swap. &nbsp; Constraints: 0 &lt;= num &lt;= 108"
    },
    {
      "number": 671,
      "title": "Second Minimum Node In a Binary Tree",
      "titleSlug": "second-minimum-node-in-a-binary-tree",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node&#39;s value is the smaller value among its two sub-nodes. More formally, the property&nbsp;root.val = min(root.left.val, root.right.val)&nbsp;always holds. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes&#39; value in the whole tree. If no such second minimum value exists, output -1 instead. &nbsp; &nbsp; Example 1: Input: root = [2,2,5,null,null,5,7] Output: 5 Explanation: The smallest value is 2, the second smallest value is 5. Example 2: Input: root = [2,2,2] Output: -1 Explanation: The smallest value is 2, but there isn&#39;t any second smallest value. &nbsp; Constraints: The number of nodes in the tree is in the range [1, 25]. 1 &lt;= Node.val &lt;= 231 - 1 root.val == min(root.left.val, root.right.val)&nbsp;for each internal node of the tree."
    },
    {
      "number": 672,
      "title": "Bulb Switcher II",
      "titleSlug": "bulb-switcher-ii",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Bit Manipulation",
        "Depth-First Search",
        "Breadth-First Search"
      ],
      "description": "There is a room with n bulbs labeled from 1 to n that all are turned on initially, and four buttons on the wall. Each of the four buttons has a different functionality where: Button 1: Flips the status of all the bulbs. Button 2: Flips the status of all the bulbs with even labels (i.e., 2, 4, ...). Button 3: Flips the status of all the bulbs with odd labels (i.e., 1, 3, ...). Button 4: Flips the status of all the bulbs with a label j = 3k + 1 where k = 0, 1, 2, ... (i.e., 1, 4, 7, 10, ...). You must make exactly presses button presses in total. For each press, you may pick any of the four buttons to press. Given the two integers n and presses, return the number of different possible statuses after performing all presses button presses. &nbsp; Example 1: Input: n = 1, presses = 1 Output: 2 Explanation: Status can be: - [off] by pressing button 1 - [on] by pressing button 2 Example 2: Input: n = 2, presses = 1 Output: 3 Explanation: Status can be: - [off, off] by pressing button 1 - [on, off] by pressing button 2 - [off, on] by pressing button 3 Example 3: Input: n = 3, presses = 1 Output: 4 Explanation: Status can be: - [off, off, off] by pressing button 1 - [off, on, off] by pressing button 2 - [on, off, on] by pressing button 3 - [off, on, on] by pressing button 4 &nbsp; Constraints: 1 &lt;= n &lt;= 1000 0 &lt;= presses &lt;= 1000"
    },
    {
      "number": 673,
      "title": "Number of Longest Increasing Subsequence",
      "titleSlug": "number-of-longest-increasing-subsequence",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Binary Indexed Tree",
        "Segment Tree"
      ],
      "description": "Given an integer array&nbsp;nums, return the number of longest increasing subsequences. Notice that the sequence has to be strictly increasing. &nbsp; Example 1: Input: nums = [1,3,5,4,7] Output: 2 Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7]. Example 2: Input: nums = [2,2,2,2,2] Output: 5 Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 2000 -106 &lt;= nums[i] &lt;= 106 The answer is guaranteed to fit inside a 32-bit integer."
    },
    {
      "number": 674,
      "title": "Longest Continuous Increasing Subsequence",
      "titleSlug": "longest-continuous-increasing-subsequence",
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "description": "Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing. A continuous increasing subsequence is defined by two indices l and r (l &lt; r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l &lt;= i &lt; r, nums[i] &lt; nums[i + 1]. &nbsp; Example 1: Input: nums = [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3. Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element 4. Example 2: Input: nums = [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly increasing. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109"
    },
    {
      "number": 675,
      "title": "Cut Off Trees for Golf Event",
      "titleSlug": "cut-off-trees-for-golf-event",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Breadth-First Search",
        "Heap (Priority Queue)",
        "Matrix"
      ],
      "description": "You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an m x n matrix. In this matrix: 0 means the cell cannot be walked through. 1 represents an empty cell that can be walked through. A number greater than 1 represents a tree in a cell that can be walked through, and this number is the tree&#39;s height. In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off. You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes 1 (an empty cell). Starting from the point (0, 0), return the minimum steps you need to walk to cut off all the trees. If you cannot cut off all the trees, return -1. Note: The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off. &nbsp; Example 1: Input: forest = [[1,2,3],[0,0,4],[7,6,5]] Output: 6 Explanation: Following the path above allows you to cut off the trees from shortest to tallest in 6 steps. Example 2: Input: forest = [[1,2,3],[0,0,0],[7,6,5]] Output: -1 Explanation: The trees in the bottom row cannot be accessed as the middle row is blocked. Example 3: Input: forest = [[2,3,4],[0,0,5],[8,7,6]] Output: 6 Explanation: You can follow the same path as Example 1 to cut off all the trees. Note that you can cut off the first tree at (0, 0) before making any steps. &nbsp; Constraints: m == forest.length n == forest[i].length 1 &lt;= m, n &lt;= 50 0 &lt;= forest[i][j] &lt;= 109 Heights of all trees are distinct."
    },
    {
      "number": 676,
      "title": "Implement Magic Dictionary",
      "titleSlug": "implement-magic-dictionary",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Depth-First Search",
        "Design",
        "Trie"
      ],
      "description": "Design a data structure that is initialized with a list of different words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure. Implement the&nbsp;MagicDictionary&nbsp;class: MagicDictionary()&nbsp;Initializes the object. void buildDict(String[]&nbsp;dictionary)&nbsp;Sets the data structure&nbsp;with an array of distinct strings dictionary. bool search(String searchWord) Returns true if you can change exactly one character in searchWord to match any string in the data structure, otherwise returns false. &nbsp; Example 1: Input [&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;] [[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]] Output [null, null, false, true, false, false] Explanation MagicDictionary magicDictionary = new MagicDictionary(); magicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]); magicDictionary.search(&quot;hello&quot;); // return False magicDictionary.search(&quot;hhllo&quot;); // We can change the second &#39;h&#39; to &#39;e&#39; to match &quot;hello&quot; so we return True magicDictionary.search(&quot;hell&quot;); // return False magicDictionary.search(&quot;leetcoded&quot;); // return False &nbsp; Constraints: 1 &lt;=&nbsp;dictionary.length &lt;= 100 1 &lt;=&nbsp;dictionary[i].length &lt;= 100 dictionary[i] consists of only lower-case English letters. All the strings in&nbsp;dictionary&nbsp;are distinct. 1 &lt;=&nbsp;searchWord.length &lt;= 100 searchWord&nbsp;consists of only lower-case English letters. buildDict&nbsp;will be called only once before search. At most 100 calls will be made to search."
    },
    {
      "number": 677,
      "title": "Map Sum Pairs",
      "titleSlug": "map-sum-pairs",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Design",
        "Trie"
      ],
      "description": "Design a map that allows you to do the following: Maps a string key to a given value. Returns the sum of the values that have a key with a prefix equal to a given string. Implement the MapSum class: MapSum() Initializes the MapSum object. void insert(String key, int val) Inserts the key-val pair into the map. If the key already existed, the original key-value pair will be overridden to the new one. int sum(string prefix) Returns the sum of all the pairs&#39; value whose key starts with the prefix. &nbsp; Example 1: Input [&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;] [[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]] Output [null, null, 3, null, 5] Explanation MapSum mapSum = new MapSum(); mapSum.insert(&quot;apple&quot;, 3); mapSum.sum(&quot;ap&quot;); // return 3 (apple = 3) mapSum.insert(&quot;app&quot;, 2); mapSum.sum(&quot;ap&quot;); // return 5 (apple + app = 3 + 2 = 5) &nbsp; Constraints: 1 &lt;= key.length, prefix.length &lt;= 50 key and prefix consist of only lowercase English letters. 1 &lt;= val &lt;= 1000 At most 50 calls will be made to insert and sum."
    },
    {
      "number": 678,
      "title": "Valid Parenthesis String",
      "titleSlug": "valid-parenthesis-string",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Dynamic Programming",
        "Stack",
        "Greedy"
      ],
      "description": "Given a string s containing only three types of characters: &#39;(&#39;, &#39;)&#39; and &#39;*&#39;, return true if s is valid. The following rules define a valid string: Any left parenthesis &#39;(&#39; must have a corresponding right parenthesis &#39;)&#39;. Any right parenthesis &#39;)&#39; must have a corresponding left parenthesis &#39;(&#39;. Left parenthesis &#39;(&#39; must go before the corresponding right parenthesis &#39;)&#39;. &#39;*&#39; could be treated as a single right parenthesis &#39;)&#39; or a single left parenthesis &#39;(&#39; or an empty string &quot;&quot;. &nbsp; Example 1: Input: s = \"()\" Output: true Example 2: Input: s = \"(*)\" Output: true Example 3: Input: s = \"(*))\" Output: true &nbsp; Constraints: 1 &lt;= s.length &lt;= 100 s[i] is &#39;(&#39;, &#39;)&#39; or &#39;*&#39;."
    },
    {
      "number": 679,
      "title": "24 Game",
      "titleSlug": "24-game",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Backtracking"
      ],
      "description": "You are given an integer array cards of length 4. You have four cards, each containing a number in the range [1, 9]. You should arrange the numbers on these cards in a mathematical expression using the operators [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;] and the parentheses &#39;(&#39; and &#39;)&#39; to get the value 24. You are restricted with the following rules: The division operator &#39;/&#39; represents real division, not integer division. For example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12. Every operation done is between two numbers. In particular, we cannot use &#39;-&#39; as a unary operator. For example, if cards = [1, 1, 1, 1], the expression &quot;-1 - 1 - 1 - 1&quot; is not allowed. You cannot concatenate numbers together For example, if cards = [1, 2, 1, 2], the expression &quot;12 + 12&quot; is not valid. Return true if you can get such expression that evaluates to 24, and false otherwise. &nbsp; Example 1: Input: cards = [4,1,8,7] Output: true Explanation: (8-4) * (7-1) = 24 Example 2: Input: cards = [1,2,1,2] Output: false &nbsp; Constraints: cards.length == 4 1 &lt;= cards[i] &lt;= 9"
    },
    {
      "number": 680,
      "title": "Valid Palindrome II",
      "titleSlug": "valid-palindrome-ii",
      "difficulty": "Easy",
      "tags": [
        "Two Pointers",
        "String",
        "Greedy"
      ],
      "description": "Given a string s, return true if the s can be palindrome after deleting at most one character from it. &nbsp; Example 1: Input: s = &quot;aba&quot; Output: true Example 2: Input: s = &quot;abca&quot; Output: true Explanation: You could delete the character &#39;c&#39;. Example 3: Input: s = &quot;abc&quot; Output: false &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s consists of lowercase English letters."
    },
    {
      "number": 682,
      "title": "Baseball Game",
      "titleSlug": "baseball-game",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Stack",
        "Simulation"
      ],
      "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record. You are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following: An integer x. Record a new score of x. &#39;+&#39;. Record a new score that is the sum of the previous two scores. &#39;D&#39;. Record a new score that is the double of the previous score. &#39;C&#39;. Invalidate the previous score, removing it from the record. Return the sum of all the scores on the record after applying all the operations. The test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid. &nbsp; Example 1: Input: ops = [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;] Output: 30 Explanation: &quot;5&quot; - Add 5 to the record, record is now [5]. &quot;2&quot; - Add 2 to the record, record is now [5, 2]. &quot;C&quot; - Invalidate and remove the previous score, record is now [5]. &quot;D&quot; - Add 2 * 5 = 10 to the record, record is now [5, 10]. &quot;+&quot; - Add 5 + 10 = 15 to the record, record is now [5, 10, 15]. The total sum is 5 + 10 + 15 = 30. Example 2: Input: ops = [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;] Output: 27 Explanation: &quot;5&quot; - Add 5 to the record, record is now [5]. &quot;-2&quot; - Add -2 to the record, record is now [5, -2]. &quot;4&quot; - Add 4 to the record, record is now [5, -2, 4]. &quot;C&quot; - Invalidate and remove the previous score, record is now [5, -2]. &quot;D&quot; - Add 2 * -2 = -4 to the record, record is now [5, -2, -4]. &quot;9&quot; - Add 9 to the record, record is now [5, -2, -4, 9]. &quot;+&quot; - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5]. &quot;+&quot; - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14]. The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27. Example 3: Input: ops = [&quot;1&quot;,&quot;C&quot;] Output: 0 Explanation: &quot;1&quot; - Add 1 to the record, record is now [1]. &quot;C&quot; - Invalidate and remove the previous score, record is now []. Since the record is empty, the total sum is 0. &nbsp; Constraints: 1 &lt;= operations.length &lt;= 1000 operations[i] is &quot;C&quot;, &quot;D&quot;, &quot;+&quot;, or a string representing an integer in the range [-3 * 104, 3 * 104]. For operation &quot;+&quot;, there will always be at least two previous scores on the record. For operations &quot;C&quot; and &quot;D&quot;, there will always be at least one previous score on the record."
    },
    {
      "number": 684,
      "title": "Redundant Connection",
      "titleSlug": "redundant-connection",
      "difficulty": "Medium",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Graph"
      ],
      "description": "In this problem, a tree is an undirected graph that is connected and has no cycles. You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph. Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input. &nbsp; Example 1: Input: edges = [[1,2],[1,3],[2,3]] Output: [2,3] Example 2: Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]] Output: [1,4] &nbsp; Constraints: n == edges.length 3 &lt;= n &lt;= 1000 edges[i].length == 2 1 &lt;= ai &lt; bi &lt;= edges.length ai != bi There are no repeated edges. The given graph is connected."
    },
    {
      "number": 685,
      "title": "Redundant Connection II",
      "titleSlug": "redundant-connection-ii",
      "difficulty": "Hard",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Graph"
      ],
      "description": "In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents. The given input is a directed graph that started as a rooted tree with n nodes (with distinct values from 1 to n), with one additional directed edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [ui, vi] that represents a directed edge connecting nodes ui and vi, where ui is a parent of child vi. Return an edge that can be removed so that the resulting graph is a rooted tree of n nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. &nbsp; Example 1: Input: edges = [[1,2],[1,3],[2,3]] Output: [2,3] Example 2: Input: edges = [[1,2],[2,3],[3,4],[4,1],[1,5]] Output: [4,1] &nbsp; Constraints: n == edges.length 3 &lt;= n &lt;= 1000 edges[i].length == 2 1 &lt;= ui, vi &lt;= n ui != vi"
    },
    {
      "number": 686,
      "title": "Repeated String Match",
      "titleSlug": "repeated-string-match",
      "difficulty": "Medium",
      "tags": [
        "String",
        "String Matching"
      ],
      "description": "Given two strings a and b, return the minimum number of times you should repeat string a so that string b is a substring of it. If it is impossible for b to be a substring of a after repeating it, return -1. Notice: string &quot;abc&quot; repeated 0 times is &quot;&quot;, repeated 1 time is &quot;abc&quot; and repeated 2 times is &quot;abcabc&quot;. &nbsp; Example 1: Input: a = &quot;abcd&quot;, b = &quot;cdabcdab&quot; Output: 3 Explanation: We return 3 because by repeating a three times &quot;abcdabcdabcd&quot;, b is a substring of it. Example 2: Input: a = &quot;a&quot;, b = &quot;aa&quot; Output: 2 &nbsp; Constraints: 1 &lt;= a.length, b.length &lt;= 104 a and b consist of lowercase English letters."
    },
    {
      "number": 687,
      "title": "Longest Univalue Path",
      "titleSlug": "longest-univalue-path",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return the length of the longest path, where each node in the path has the same value. This path may or may not pass through the root. The length of the path between two nodes is represented by the number of edges between them. &nbsp; Example 1: Input: root = [5,4,5,1,1,null,5] Output: 2 Explanation: The shown image shows that the longest path of the same value (i.e. 5). Example 2: Input: root = [1,4,5,4,4,null,5] Output: 2 Explanation: The shown image shows that the longest path of the same value (i.e. 4). &nbsp; Constraints: The number of nodes in the tree is in the range [0, 104]. -1000 &lt;= Node.val &lt;= 1000 The depth of the tree will not exceed 1000."
    },
    {
      "number": 688,
      "title": "Knight Probability in Chessboard",
      "titleSlug": "knight-probability-in-chessboard",
      "difficulty": "Medium",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1). A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction. Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there. The knight continues moving until it has made exactly k moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving. &nbsp; Example 1: Input: n = 3, k = 2, row = 0, column = 0 Output: 0.06250 Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board. From each of those positions, there are also two moves that will keep the knight on the board. The total probability the knight stays on the board is 0.0625. Example 2: Input: n = 1, k = 0, row = 0, column = 0 Output: 1.00000 &nbsp; Constraints: 1 &lt;= n &lt;= 25 0 &lt;= k &lt;= 100 0 &lt;= row, column &lt;= n - 1"
    },
    {
      "number": 689,
      "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
      "titleSlug": "maximum-sum-of-3-non-overlapping-subarrays",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Sliding Window",
        "Prefix Sum"
      ],
      "description": "Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with maximum sum and return them. Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one. &nbsp; Example 1: Input: nums = [1,2,1,2,6,7,5,1], k = 2 Output: [0,3,5] Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5]. We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically smaller. Example 2: Input: nums = [1,2,1,2,1,2,1,2,1], k = 2 Output: [0,2,4] &nbsp; Constraints: 1 &lt;= nums.length &lt;= 2 * 104 1 &lt;= nums[i] &lt;&nbsp;216 1 &lt;= k &lt;= floor(nums.length / 3)"
    },
    {
      "number": 690,
      "title": "Employee Importance",
      "titleSlug": "employee-importance",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search"
      ],
      "description": "You have a data structure of employee information, including the employee&#39;s unique ID, importance value, and direct subordinates&#39; IDs. You are given an array of employees employees where: employees[i].id is the ID of the ith employee. employees[i].importance is the importance value of the ith employee. employees[i].subordinates is a list of the IDs of the direct subordinates of the ith employee. Given an integer id that represents an employee&#39;s ID, return the total importance value of this employee and all their direct and indirect subordinates. &nbsp; Example 1: Input: employees = [[1,5,[2,3]],[2,3,[]],[3,3,[]]], id = 1 Output: 11 Explanation: Employee 1 has an importance value of 5 and has two direct subordinates: employee 2 and employee 3. They both have an importance value of 3. Thus, the total importance value of employee 1 is 5 + 3 + 3 = 11. Example 2: Input: employees = [[1,2,[5]],[5,-3,[]]], id = 5 Output: -3 Explanation: Employee 5 has an importance value of -3 and has no direct subordinates. Thus, the total importance value of employee 5 is -3. &nbsp; Constraints: 1 &lt;= employees.length &lt;= 2000 1 &lt;= employees[i].id &lt;= 2000 All employees[i].id are unique. -100 &lt;= employees[i].importance &lt;= 100 One employee has at most one direct leader and may have several subordinates. The IDs in employees[i].subordinates are valid IDs."
    },
    {
      "number": 691,
      "title": "Stickers to Spell Word",
      "titleSlug": "stickers-to-spell-word",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Dynamic Programming",
        "Backtracking",
        "Bit Manipulation",
        "Memoization",
        "Bitmask"
      ],
      "description": "We are given n different types of stickers. Each sticker has a lowercase English word on it. You would like to spell out the given string target by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker. Return the minimum number of stickers that you need to spell out target. If the task is impossible, return -1. Note: In all test cases, all words were chosen randomly from the 1000 most common US English words, and target was chosen as a concatenation of two random words. &nbsp; Example 1: Input: stickers = [&quot;with&quot;,&quot;example&quot;,&quot;science&quot;], target = &quot;thehat&quot; Output: 3 Explanation: We can use 2 &quot;with&quot; stickers, and 1 &quot;example&quot; sticker. After cutting and rearrange the letters of those stickers, we can form the target &quot;thehat&quot;. Also, this is the minimum number of stickers necessary to form the target string. Example 2: Input: stickers = [&quot;notice&quot;,&quot;possible&quot;], target = &quot;basicbasic&quot; Output: -1 Explanation: We cannot form the target &quot;basicbasic&quot; from cutting letters from the given stickers. &nbsp; Constraints: n == stickers.length 1 &lt;= n &lt;= 50 1 &lt;= stickers[i].length &lt;= 10 1 &lt;= target.length &lt;= 15 stickers[i] and target consist of lowercase English letters."
    },
    {
      "number": 692,
      "title": "Top K Frequent Words",
      "titleSlug": "top-k-frequent-words",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Trie",
        "Sorting",
        "Heap (Priority Queue)",
        "Bucket Sort",
        "Counting"
      ],
      "description": "Given an array of strings words and an integer k, return the k most frequent strings. Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order. &nbsp; Example 1: Input: words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;i&quot;,&quot;love&quot;,&quot;coding&quot;], k = 2 Output: [&quot;i&quot;,&quot;love&quot;] Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words. Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order. Example 2: Input: words = [&quot;the&quot;,&quot;day&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;the&quot;,&quot;the&quot;,&quot;the&quot;,&quot;sunny&quot;,&quot;is&quot;,&quot;is&quot;], k = 4 Output: [&quot;the&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;day&quot;] Explanation: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively. &nbsp; Constraints: 1 &lt;= words.length &lt;= 500 1 &lt;= words[i].length &lt;= 10 words[i] consists of lowercase English letters. k is in the range [1, The number of unique words[i]] &nbsp; Follow-up: Could you solve it in O(n log(k)) time and O(n) extra space?"
    },
    {
      "number": 693,
      "title": "Binary Number with Alternating Bits",
      "titleSlug": "binary-number-with-alternating-bits",
      "difficulty": "Easy",
      "tags": [
        "Bit Manipulation"
      ],
      "description": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. &nbsp; Example 1: Input: n = 5 Output: true Explanation: The binary representation of 5 is: 101 Example 2: Input: n = 7 Output: false Explanation: The binary representation of 7 is: 111. Example 3: Input: n = 11 Output: false Explanation: The binary representation of 11 is: 1011. &nbsp; Constraints: 1 &lt;= n &lt;= 231 - 1"
    },
    {
      "number": 695,
      "title": "Max Area of Island",
      "titleSlug": "max-area-of-island",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Matrix"
      ],
      "description": "You are given an m x n binary matrix grid. An island is a group of 1&#39;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0. &nbsp; Example 1: Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] Output: 6 Explanation: The answer is not 11, because the island must be connected 4-directionally. Example 2: Input: grid = [[0,0,0,0,0,0,0,0]] Output: 0 &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 50 grid[i][j] is either 0 or 1."
    },
    {
      "number": 696,
      "title": "Count Binary Substrings",
      "titleSlug": "count-binary-substrings",
      "difficulty": "Easy",
      "tags": [
        "Two Pointers",
        "String"
      ],
      "description": "Given a binary string s, return the number of non-empty substrings that have the same number of 0&#39;s and 1&#39;s, and all the 0&#39;s and all the 1&#39;s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. &nbsp; Example 1: Input: s = &quot;00110011&quot; Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1&#39;s and 0&#39;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;. Notice that some of these substrings repeat and are counted the number of times they occur. Also, &quot;00110011&quot; is not a valid substring because all the 0&#39;s (and 1&#39;s) are not grouped together. Example 2: Input: s = &quot;10101&quot; Output: 4 Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1&#39;s and 0&#39;s. &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s[i] is either &#39;0&#39; or &#39;1&#39;."
    },
    {
      "number": 697,
      "title": "Degree of an Array",
      "titleSlug": "degree-of-an-array",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table"
      ],
      "description": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. &nbsp; Example 1: Input: nums = [1,2,2,3,1] Output: 2 Explanation: The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2. Example 2: Input: nums = [1,2,2,3,1,4,2] Output: 6 Explanation: The degree is 3 because the element 2 is repeated 3 times. So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6. &nbsp; Constraints: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999."
    },
    {
      "number": 698,
      "title": "Partition to K Equal Sum Subsets",
      "titleSlug": "partition-to-k-equal-sum-subsets",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Backtracking",
        "Bit Manipulation",
        "Memoization",
        "Bitmask"
      ],
      "description": "Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal. &nbsp; Example 1: Input: nums = [4,3,2,3,5,2,1], k = 4 Output: true Explanation: It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. Example 2: Input: nums = [1,2,3,4], k = 3 Output: false &nbsp; Constraints: 1 &lt;= k &lt;= nums.length &lt;= 16 1 &lt;= nums[i] &lt;= 104 The frequency of each element is in the range [1, 4]."
    },
    {
      "number": 699,
      "title": "Falling Squares",
      "titleSlug": "falling-squares",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Segment Tree",
        "Ordered Set"
      ],
      "description": "There are several squares being dropped onto the X-axis of a 2D plane. You are given a 2D integer array positions where positions[i] = [lefti, sideLengthi] represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti. Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved. After each square is dropped, you must record the height of the current tallest stack of squares. Return an integer array ans where ans[i] represents the height described above after dropping the ith square. &nbsp; Example 1: Input: positions = [[1,2],[2,3],[6,1]] Output: [2,5,5] Explanation: After the first drop, the tallest stack is square 1 with a height of 2. After the second drop, the tallest stack is squares 1 and 2 with a height of 5. After the third drop, the tallest stack is still squares 1 and 2 with a height of 5. Thus, we return an answer of [2, 5, 5]. Example 2: Input: positions = [[100,100],[200,100]] Output: [100,100] Explanation: After the first drop, the tallest stack is square 1 with a height of 100. After the second drop, the tallest stack is either square 1 or square 2, both with heights of 100. Thus, we return an answer of [100, 100]. Note that square 2 only brushes the right side of square 1, which does not count as landing on it. &nbsp; Constraints: 1 &lt;= positions.length &lt;= 1000 1 &lt;= lefti &lt;= 108 1 &lt;= sideLengthi &lt;= 106"
    },
    {
      "number": 700,
      "title": "Search in a Binary Search Tree",
      "titleSlug": "search-in-a-binary-search-tree",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node&#39;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null. &nbsp; Example 1: Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Example 2: Input: root = [4,2,7,1,3], val = 5 Output: [] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 5000]. 1 &lt;= Node.val &lt;= 107 root is a binary search tree. 1 &lt;= val &lt;= 107"
    },
    {
      "number": 701,
      "title": "Insert into a Binary Search Tree",
      "titleSlug": "insert-into-a-binary-search-tree",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Notice&nbsp;that there may exist&nbsp;multiple valid ways for the&nbsp;insertion, as long as the tree remains a BST after insertion. You can return any of them. &nbsp; Example 1: Input: root = [4,2,7,1,3], val = 5 Output: [4,2,7,1,3,5] Explanation: Another accepted tree is: Example 2: Input: root = [40,20,60,10,30,50,70], val = 25 Output: [40,20,60,10,30,50,70,null,null,25] Example 3: Input: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5 Output: [4,2,7,1,3,5] &nbsp; Constraints: The number of nodes in&nbsp;the tree will be in the range [0,&nbsp;104]. -108 &lt;= Node.val &lt;= 108 All the values Node.val are unique. -108 &lt;= val &lt;= 108 It&#39;s guaranteed that val does not exist in the original BST."
    },
    {
      "number": 703,
      "title": "Kth Largest Element in a Stream",
      "titleSlug": "kth-largest-element-in-a-stream",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Design",
        "Binary Search Tree",
        "Heap (Priority Queue)",
        "Binary Tree",
        "Data Stream"
      ],
      "description": "You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores. You are tasked to implement a class which, for a given integer&nbsp;k, maintains a stream of test scores and continuously returns the&nbsp;kth highest test score&nbsp;after&nbsp;a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores. Implement the&nbsp;KthLargest class: KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of test scores&nbsp;nums. int add(int val) Adds a new test score&nbsp;val to the stream and returns the element representing the kth largest element in the pool of test scores so far. &nbsp; Example 1: Input: [&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output: [null, 4, 5, 5, 8, 8] Explanation: KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 Example 2: Input: [&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;] [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]] Output: [null, 7, 7, 7, 8] Explanation: KthLargest kthLargest = new KthLargest(4, [7, 7, 7, 7, 8, 3]); kthLargest.add(2); // return 7 kthLargest.add(10); // return 7 kthLargest.add(9); // return 7 kthLargest.add(9); // return 8 &nbsp; Constraints: 0 &lt;= nums.length &lt;= 104 1 &lt;= k &lt;= nums.length + 1 -104 &lt;= nums[i] &lt;= 104 -104 &lt;= val &lt;= 104 At most 104 calls will be made to add."
    },
    {
      "number": 704,
      "title": "Binary Search",
      "titleSlug": "binary-search",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Binary Search"
      ],
      "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity. &nbsp; Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 -104 &lt; nums[i], target &lt; 104 All the integers in nums are unique. nums is sorted in ascending order."
    },
    {
      "number": 705,
      "title": "Design HashSet",
      "titleSlug": "design-hashset",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Linked List",
        "Design",
        "Hash Function"
      ],
      "description": "Design a HashSet without using any built-in hash table libraries. Implement MyHashSet class: void add(key) Inserts the value key into the HashSet. bool contains(key) Returns whether the value key exists in the HashSet or not. void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing. &nbsp; Example 1: Input [&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;] [[], [1], [2], [1], [3], [2], [2], [2], [2]] Output [null, null, null, true, false, null, true, null, false] Explanation MyHashSet myHashSet = new MyHashSet(); myHashSet.add(1); // set = [1] myHashSet.add(2); // set = [1, 2] myHashSet.contains(1); // return True myHashSet.contains(3); // return False, (not found) myHashSet.add(2); // set = [1, 2] myHashSet.contains(2); // return True myHashSet.remove(2); // set = [1] myHashSet.contains(2); // return False, (already removed) &nbsp; Constraints: 0 &lt;= key &lt;= 106 At most 104 calls will be made to add, remove, and contains."
    },
    {
      "number": 706,
      "title": "Design HashMap",
      "titleSlug": "design-hashmap",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Linked List",
        "Design",
        "Hash Function"
      ],
      "description": "Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class: MyHashMap() initializes the object with an empty map. void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value. int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. void remove(key) removes the key and its corresponding value if the map contains the mapping for the key. &nbsp; Example 1: Input [&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;] [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]] Output [null, null, null, 1, -1, null, 1, null, -1] Explanation MyHashMap myHashMap = new MyHashMap(); myHashMap.put(1, 1); // The map is now [[1,1]] myHashMap.put(2, 2); // The map is now [[1,1], [2,2]] myHashMap.get(1); // return 1, The map is now [[1,1], [2,2]] myHashMap.get(3); // return -1 (i.e., not found), The map is now [[1,1], [2,2]] myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value) myHashMap.get(2); // return 1, The map is now [[1,1], [2,1]] myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]] myHashMap.get(2); // return -1 (i.e., not found), The map is now [[1,1]] &nbsp; Constraints: 0 &lt;= key, value &lt;= 106 At most 104 calls will be made to put, get, and remove."
    },
    {
      "number": 707,
      "title": "Design Linked List",
      "titleSlug": "design-linked-list",
      "difficulty": "Medium",
      "tags": [
        "Linked List",
        "Design"
      ],
      "description": "Design your implementation of the linked list. You can choose to use a singly or doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement the MyLinkedList class: MyLinkedList() Initializes the MyLinkedList object. int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1. void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. void addAtTail(int val) Append a node of value val as the last element of the linked list. void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted. void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid. &nbsp; Example 1: Input [&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;] [[], [1], [3], [1, 2], [1], [1], [1]] Output [null, null, null, null, 2, null, 3] Explanation MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addAtHead(1); myLinkedList.addAtTail(3); myLinkedList.addAtIndex(1, 2); // linked list becomes 1-&gt;2-&gt;3 myLinkedList.get(1); // return 2 myLinkedList.deleteAtIndex(1); // now the linked list is 1-&gt;3 myLinkedList.get(1); // return 3 &nbsp; Constraints: 0 &lt;= index, val &lt;= 1000 Please do not use the built-in LinkedList library. At most 2000 calls will be made to get, addAtHead, addAtTail, addAtIndex and deleteAtIndex."
    },
    {
      "number": 709,
      "title": "To Lower Case",
      "titleSlug": "to-lower-case",
      "difficulty": "Easy",
      "tags": [
        "String"
      ],
      "description": "Given a string s, return the string after replacing every uppercase letter with the same lowercase letter. &nbsp; Example 1: Input: s = &quot;Hello&quot; Output: &quot;hello&quot; Example 2: Input: s = &quot;here&quot; Output: &quot;here&quot; Example 3: Input: s = &quot;LOVELY&quot; Output: &quot;lovely&quot; &nbsp; Constraints: 1 &lt;= s.length &lt;= 100 s consists of printable ASCII characters."
    },
    {
      "number": 710,
      "title": "Random Pick with Blacklist",
      "titleSlug": "random-pick-with-blacklist",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Math",
        "Binary Search",
        "Sorting",
        "Randomized"
      ],
      "description": "You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a random integer in the range [0, n - 1] that is not in blacklist. Any integer that is in the mentioned range and not in blacklist should be equally likely to be returned. Optimize your algorithm such that it minimizes the number of calls to the built-in random function of your language. Implement the Solution class: Solution(int n, int[] blacklist) Initializes the object with the integer n and the blacklisted integers blacklist. int pick() Returns a random integer in the range [0, n - 1] and not in blacklist. &nbsp; Example 1: Input [&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;] [[7, [2, 3, 5]], [], [], [], [], [], [], []] Output [null, 0, 4, 1, 6, 1, 0, 4] Explanation Solution solution = new Solution(7, [2, 3, 5]); solution.pick(); // return 0, any integer from [0,1,4,6] should be ok. Note that for every call of pick, // 0, 1, 4, and 6 must be equally likely to be returned (i.e., with probability 1/4). solution.pick(); // return 4 solution.pick(); // return 1 solution.pick(); // return 6 solution.pick(); // return 1 solution.pick(); // return 0 solution.pick(); // return 4 &nbsp; Constraints: 1 &lt;= n &lt;= 109 0 &lt;= blacklist.length &lt;= min(105, n - 1) 0 &lt;= blacklist[i] &lt; n All the values of blacklist are unique. At most 2 * 104 calls will be made to pick."
    },
    {
      "number": 712,
      "title": "Minimum ASCII Delete Sum for Two Strings",
      "titleSlug": "minimum-ascii-delete-sum-for-two-strings",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "Given two strings s1 and&nbsp;s2, return the lowest ASCII sum of deleted characters to make two strings equal. &nbsp; Example 1: Input: s1 = &quot;sea&quot;, s2 = &quot;eat&quot; Output: 231 Explanation: Deleting &quot;s&quot; from &quot;sea&quot; adds the ASCII value of &quot;s&quot; (115) to the sum. Deleting &quot;t&quot; from &quot;eat&quot; adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this. Example 2: Input: s1 = &quot;delete&quot;, s2 = &quot;leet&quot; Output: 403 Explanation: Deleting &quot;dee&quot; from &quot;delete&quot; to turn the string into &quot;let&quot;, adds 100[d] + 101[e] + 101[e] to the sum. Deleting &quot;e&quot; from &quot;leet&quot; adds 101[e] to the sum. At the end, both strings are equal to &quot;let&quot;, and the answer is 100+101+101+101 = 403. If instead we turned both strings into &quot;lee&quot; or &quot;eet&quot;, we would get answers of 433 or 417, which are higher. &nbsp; Constraints: 1 &lt;= s1.length, s2.length &lt;= 1000 s1 and s2 consist of lowercase English letters."
    },
    {
      "number": 713,
      "title": "Subarray Product Less Than K",
      "titleSlug": "subarray-product-less-than-k",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search",
        "Sliding Window",
        "Prefix Sum"
      ],
      "description": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k. &nbsp; Example 1: Input: nums = [10,5,2,6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6] Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k. Example 2: Input: nums = [1,2,3], k = 0 Output: 0 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 3 * 104 1 &lt;= nums[i] &lt;= 1000 0 &lt;= k &lt;= 106"
    },
    {
      "number": 714,
      "title": "Best Time to Buy and Sell Stock with Transaction Fee",
      "titleSlug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Greedy"
      ],
      "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee. Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). The transaction fee is only charged once for each stock purchase and sale. &nbsp; Example 1: Input: prices = [1,3,2,8,4,9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: - Buying at prices[0] = 1 - Selling at prices[3] = 8 - Buying at prices[4] = 4 - Selling at prices[5] = 9 The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. Example 2: Input: prices = [1,3,7,5,10,3], fee = 3 Output: 6 &nbsp; Constraints: 1 &lt;= prices.length &lt;= 5 * 104 1 &lt;= prices[i] &lt; 5 * 104 0 &lt;= fee &lt; 5 * 104"
    },
    {
      "number": 715,
      "title": "Range Module",
      "titleSlug": "range-module",
      "difficulty": "Hard",
      "tags": [
        "Design",
        "Segment Tree",
        "Ordered Set"
      ],
      "description": "A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as half-open intervals and query about them. A half-open interval [left, right) denotes all the real numbers x where left &lt;= x &lt; right. Implement the RangeModule class: RangeModule() Initializes the object of the data structure. void addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked. boolean queryRange(int left, int right) Returns true if every real number in the interval [left, right) is currently being tracked, and false otherwise. void removeRange(int left, int right) Stops tracking every real number currently being tracked in the half-open interval [left, right). &nbsp; Example 1: Input [&quot;RangeModule&quot;, &quot;addRange&quot;, &quot;removeRange&quot;, &quot;queryRange&quot;, &quot;queryRange&quot;, &quot;queryRange&quot;] [[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]] Output [null, null, null, true, false, true] Explanation RangeModule rangeModule = new RangeModule(); rangeModule.addRange(10, 20); rangeModule.removeRange(14, 16); rangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is being tracked) rangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked) rangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is still being tracked, despite the remove operation) &nbsp; Constraints: 1 &lt;= left &lt; right &lt;= 109 At most 104 calls will be made to addRange, queryRange, and removeRange."
    },
    {
      "number": 717,
      "title": "1-bit and 2-bit Characters",
      "titleSlug": "1-bit-and-2-bit-characters",
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "description": "We have two special characters: The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11). Given a binary array bits that ends with 0, return true if the last character must be a one-bit character. &nbsp; Example 1: Input: bits = [1,0,0] Output: true Explanation: The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character. Example 2: Input: bits = [1,1,1,0] Output: false Explanation: The only way to decode it is two-bit character and two-bit character. So the last character is not one-bit character. &nbsp; Constraints: 1 &lt;= bits.length &lt;= 1000 bits[i] is either 0 or 1."
    },
    {
      "number": 718,
      "title": "Maximum Length of Repeated Subarray",
      "titleSlug": "maximum-length-of-repeated-subarray",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search",
        "Dynamic Programming",
        "Sliding Window",
        "Rolling Hash",
        "Hash Function"
      ],
      "description": "Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays. &nbsp; Example 1: Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7] Output: 3 Explanation: The repeated subarray with maximum length is [3,2,1]. Example 2: Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0] Output: 5 Explanation: The repeated subarray with maximum length is [0,0,0,0,0]. &nbsp; Constraints: 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 100"
    },
    {
      "number": 719,
      "title": "Find K-th Smallest Pair Distance",
      "titleSlug": "find-k-th-smallest-pair-distance",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Two Pointers",
        "Binary Search",
        "Sorting"
      ],
      "description": "The distance of a pair of integers a and b is defined as the absolute difference between a and b. Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 &lt;= i &lt; j &lt; nums.length. &nbsp; Example 1: Input: nums = [1,3,1], k = 1 Output: 0 Explanation: Here are all the pairs: (1,3) -&gt; 2 (1,1) -&gt; 0 (3,1) -&gt; 2 Then the 1st smallest distance pair is (1,1), and its distance is 0. Example 2: Input: nums = [1,1,1], k = 2 Output: 0 Example 3: Input: nums = [1,6,1], k = 3 Output: 5 &nbsp; Constraints: n == nums.length 2 &lt;= n &lt;= 104 0 &lt;= nums[i] &lt;= 106 1 &lt;= k &lt;= n * (n - 1) / 2"
    },
    {
      "number": 720,
      "title": "Longest Word in Dictionary",
      "titleSlug": "longest-word-in-dictionary",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Trie",
        "Sorting"
      ],
      "description": "Given an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string. Note that the word should be built from left to right with each additional character being added to the end of a previous word.&nbsp; &nbsp; Example 1: Input: words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;,&quot;world&quot;] Output: &quot;world&quot; Explanation: The word &quot;world&quot; can be built one character at a time by &quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, and &quot;worl&quot;. Example 2: Input: words = [&quot;a&quot;,&quot;banana&quot;,&quot;app&quot;,&quot;appl&quot;,&quot;ap&quot;,&quot;apply&quot;,&quot;apple&quot;] Output: &quot;apple&quot; Explanation: Both &quot;apply&quot; and &quot;apple&quot; can be built from other words in the dictionary. However, &quot;apple&quot; is lexicographically smaller than &quot;apply&quot;. &nbsp; Constraints: 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 30 words[i] consists of lowercase English letters."
    },
    {
      "number": 721,
      "title": "Accounts Merge",
      "titleSlug": "accounts-merge",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Sorting"
      ],
      "description": "Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order. &nbsp; Example 1: Input: accounts = [[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john_newyork@mail.com&quot;],[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john00@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]] Output: [[&quot;John&quot;,&quot;john00@mail.com&quot;,&quot;john_newyork@mail.com&quot;,&quot;johnsmith@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]] Explanation: The first and second John&#39;s are the same person as they have the common email &quot;johnsmith@mail.com&quot;. The third John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [[&#39;Mary&#39;, &#39;mary@mail.com&#39;], [&#39;John&#39;, &#39;johnnybravo@mail.com&#39;], [&#39;John&#39;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;]] would still be accepted. Example 2: Input: accounts = [[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe3@m.co&quot;,&quot;Gabe1@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;,&quot;Kevin0@m.co&quot;],[&quot;Ethan&quot;,&quot;Ethan5@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan0@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo3@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo0@m.co&quot;],[&quot;Fern&quot;,&quot;Fern5@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern0@m.co&quot;]] Output: [[&quot;Ethan&quot;,&quot;Ethan0@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan5@m.co&quot;],[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe1@m.co&quot;,&quot;Gabe3@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo0@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo3@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin0@m.co&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;],[&quot;Fern&quot;,&quot;Fern0@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern5@m.co&quot;]] &nbsp; Constraints: 1 &lt;= accounts.length &lt;= 1000 2 &lt;= accounts[i].length &lt;= 10 1 &lt;= accounts[i][j].length &lt;= 30 accounts[i][0] consists of English letters. accounts[i][j] (for j &gt; 0) is a valid email."
    },
    {
      "number": 722,
      "title": "Remove Comments",
      "titleSlug": "remove-comments",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "String"
      ],
      "description": "Given a C++ program, remove comments from it. The program source is an array of strings source where source[i] is the ith line of the source code. This represents the result of splitting the original source code string by the newline character &#39;\\n&#39;. In C++, there are two types of comments, line comments, and block comments. The string &quot;//&quot; denotes a line comment, which represents that it and the rest of the characters to the right of it in the same line should be ignored. The string &quot;/*&quot; denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of &quot;*/&quot; should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string &quot;/*/&quot; does not yet end the block comment, as the ending would be overlapping the beginning. The first effective comment takes precedence over others. For example, if the string &quot;//&quot; occurs in a block comment, it is ignored. Similarly, if the string &quot;/*&quot; occurs in a line or block comment, it is also ignored. If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty. There will be no control characters, single quote, or double quote characters. For example, source = &quot;string s = &quot;/* Not a comment. */&quot;;&quot; will not be a test case. Also, nothing else such as defines or macros will interfere with the comments. It is guaranteed that every open block comment will eventually be closed, so &quot;/*&quot; outside of a line or block comment always starts a new comment. Finally, implicit newline characters can be deleted by block comments. Please see the examples below for details. After removing the comments from the source code, return the source code in the same format. &nbsp; Example 1: Input: source = [&quot;/*Test program */&quot;, &quot;int main()&quot;, &quot;{ &quot;, &quot; // variable declaration &quot;, &quot;int a, b, c;&quot;, &quot;/* This is a test&quot;, &quot; multiline &quot;, &quot; comment for &quot;, &quot; testing */&quot;, &quot;a = b + c;&quot;, &quot;}&quot;] Output: [&quot;int main()&quot;,&quot;{ &quot;,&quot; &quot;,&quot;int a, b, c;&quot;,&quot;a = b + c;&quot;,&quot;}&quot;] Explanation: The line by line code is visualized as below: /*Test program */ int main() { // variable declaration int a, b, c; /* This is a test multiline comment for testing */ a = b + c; } The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments. The line by line output code is visualized as below: int main() { int a, b, c; a = b + c; } Example 2: Input: source = [&quot;a/*comment&quot;, &quot;line&quot;, &quot;more_comment*/b&quot;] Output: [&quot;ab&quot;] Explanation: The original source string is &quot;a/*comment\\nline\\nmore_comment*/b&quot;, where we have bolded the newline characters. After deletion, the implicit newline characters are deleted, leaving the string &quot;ab&quot;, which when delimited by newline characters becomes [&quot;ab&quot;]. &nbsp; Constraints: 1 &lt;= source.length &lt;= 100 0 &lt;= source[i].length &lt;= 80 source[i] consists of printable ASCII characters. Every open block comment is eventually closed. There are no single-quote or&nbsp;double-quote in the input."
    },
    {
      "number": 724,
      "title": "Find Pivot Index",
      "titleSlug": "find-pivot-index",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Prefix Sum"
      ],
      "description": "Given an array of integers nums, calculate the pivot index of this array. The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index&#39;s right. If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array. Return the leftmost pivot index. If no such index exists, return -1. &nbsp; Example 1: Input: nums = [1,7,3,6,5,6] Output: 3 Explanation: The pivot index is 3. Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 Right sum = nums[4] + nums[5] = 5 + 6 = 11 Example 2: Input: nums = [1,2,3] Output: -1 Explanation: There is no index that satisfies the conditions in the problem statement. Example 3: Input: nums = [2,1,-1] Output: 0 Explanation: The pivot index is 0. Left sum = 0 (no elements to the left of index 0) Right sum = nums[1] + nums[2] = 1 + -1 = 0 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 -1000 &lt;= nums[i] &lt;= 1000 &nbsp; Note: This question is the same as&nbsp;1991:&nbsp;https://leetcode.com/problems/find-the-middle-index-in-array/"
    },
    {
      "number": 725,
      "title": "Split Linked List in Parts",
      "titleSlug": "split-linked-list-in-parts",
      "difficulty": "Medium",
      "tags": [
        "Linked List"
      ],
      "description": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts. The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null. The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later. Return an array of the k parts. &nbsp; Example 1: Input: head = [1,2,3], k = 5 Output: [[1],[2],[3],[],[]] Explanation: The first element output[0] has output[0].val = 1, output[0].next = null. The last element output[4] is null, but its string representation as a ListNode is []. Example 2: Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3 Output: [[1,2,3,4],[5,6,7],[8,9,10]] Explanation: The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts. &nbsp; Constraints: The number of nodes in the list is in the range [0, 1000]. 0 &lt;= Node.val &lt;= 1000 1 &lt;= k &lt;= 50"
    },
    {
      "number": 726,
      "title": "Number of Atoms",
      "titleSlug": "number-of-atoms",
      "difficulty": "Hard",
      "tags": [
        "Hash Table",
        "String",
        "Stack",
        "Sorting"
      ],
      "description": "Given a string formula representing a chemical formula, return the count of each atom. The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name. One or more digits representing that element&#39;s count may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, &quot;H2O&quot; and &quot;H2O2&quot; are possible, but &quot;H1O2&quot; is impossible. Two formulas are concatenated together to produce another formula. For example, &quot;H2O2He3Mg4&quot; is also a formula. A formula placed in parentheses, and a count (optionally added) is also a formula. For example, &quot;(H2O2)&quot; and &quot;(H2O2)3&quot; are formulas. Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on. The test cases are generated so that all the values in the output fit in a 32-bit integer. &nbsp; Example 1: Input: formula = &quot;H2O&quot; Output: &quot;H2O&quot; Explanation: The count of elements are {&#39;H&#39;: 2, &#39;O&#39;: 1}. Example 2: Input: formula = &quot;Mg(OH)2&quot; Output: &quot;H2MgO2&quot; Explanation: The count of elements are {&#39;H&#39;: 2, &#39;Mg&#39;: 1, &#39;O&#39;: 2}. Example 3: Input: formula = &quot;K4(ON(SO3)2)2&quot; Output: &quot;K4N2O14S4&quot; Explanation: The count of elements are {&#39;K&#39;: 4, &#39;N&#39;: 2, &#39;O&#39;: 14, &#39;S&#39;: 4}. &nbsp; Constraints: 1 &lt;= formula.length &lt;= 1000 formula consists of English letters, digits, &#39;(&#39;, and &#39;)&#39;. formula is always valid."
    },
    {
      "number": 728,
      "title": "Self Dividing Numbers",
      "titleSlug": "self-dividing-numbers",
      "difficulty": "Easy",
      "tags": [
        "Math"
      ],
      "description": "A self-dividing number is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. A self-dividing number is not allowed to contain the digit zero. Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right] (both inclusive). &nbsp; Example 1: Input: left = 1, right = 22 Output: [1,2,3,4,5,6,7,8,9,11,12,15,22] Example 2: Input: left = 47, right = 85 Output: [48,55,66,77] &nbsp; Constraints: 1 &lt;= left &lt;= right &lt;= 104"
    },
    {
      "number": 729,
      "title": "My Calendar I",
      "titleSlug": "my-calendar-i",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search",
        "Design",
        "Segment Tree",
        "Ordered Set"
      ],
      "description": "You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking. A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.). The event can be represented as a pair of integers startTime and endTime that represents a booking on the half-open interval [startTime, endTime), the range of real numbers x such that startTime &lt;= x &lt; endTime. Implement the MyCalendar class: MyCalendar() Initializes the calendar object. boolean book(int startTime, int endTime) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar. &nbsp; Example 1: Input [&quot;MyCalendar&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;] [[], [10, 20], [15, 25], [20, 30]] Output [null, true, false, true] Explanation MyCalendar myCalendar = new MyCalendar(); myCalendar.book(10, 20); // return True myCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event. myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20. &nbsp; Constraints: 0 &lt;= start &lt; end &lt;= 109 At most 1000 calls will be made to book."
    },
    {
      "number": 730,
      "title": "Count Different Palindromic Subsequences",
      "titleSlug": "count-different-palindromic-subsequences",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "Given a string s, return the number of different non-empty palindromic subsequences in s. Since the answer may be very large, return it modulo 109 + 7. A subsequence of a string is obtained by deleting zero or more characters from the string. A sequence is palindromic if it is equal to the sequence reversed. Two sequences a1, a2, ... and b1, b2, ... are different if there is some i for which ai != bi. &nbsp; Example 1: Input: s = &quot;bccb&quot; Output: 6 Explanation: The 6 different non-empty palindromic subsequences are &#39;b&#39;, &#39;c&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;bcb&#39;, &#39;bccb&#39;. Note that &#39;bcb&#39; is counted only once, even though it occurs twice. Example 2: Input: s = &quot;abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba&quot; Output: 104860361 Explanation: There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 109 + 7. &nbsp; Constraints: 1 &lt;= s.length &lt;= 1000 s[i] is either &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, or &#39;d&#39;."
    },
    {
      "number": 731,
      "title": "My Calendar II",
      "titleSlug": "my-calendar-ii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search",
        "Design",
        "Segment Tree",
        "Prefix Sum",
        "Ordered Set"
      ],
      "description": "You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking. A triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.). The event can be represented as a pair of integers startTime and endTime that represents a booking on the half-open interval [startTime, endTime), the range of real numbers x such that startTime &lt;= x &lt; endTime. Implement the MyCalendarTwo class: MyCalendarTwo() Initializes the calendar object. boolean book(int startTime, int endTime) Returns true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar. &nbsp; Example 1: Input [&quot;MyCalendarTwo&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;] [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]] Output [null, true, true, true, false, true, true] Explanation MyCalendarTwo myCalendarTwo = new MyCalendarTwo(); myCalendarTwo.book(10, 20); // return True, The event can be booked. myCalendarTwo.book(50, 60); // return True, The event can be booked. myCalendarTwo.book(10, 40); // return True, The event can be double booked. myCalendarTwo.book(5, 15); // return False, The event cannot be booked, because it would result in a triple booking. myCalendarTwo.book(5, 10); // return True, The event can be booked, as it does not use time 10 which is already double booked. myCalendarTwo.book(25, 55); // return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event. &nbsp; Constraints: 0 &lt;= start &lt; end &lt;= 109 At most 1000 calls will be made to book."
    },
    {
      "number": 732,
      "title": "My Calendar III",
      "titleSlug": "my-calendar-iii",
      "difficulty": "Hard",
      "tags": [
        "Binary Search",
        "Design",
        "Segment Tree",
        "Prefix Sum",
        "Ordered Set"
      ],
      "description": "A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is common to all k events.) You are given some events [startTime, endTime), after each given event, return an integer k representing the maximum k-booking between all the previous events. Implement the MyCalendarThree class: MyCalendarThree() Initializes the object. int book(int startTime, int endTime) Returns an integer k representing the largest integer such that there exists a k-booking in the calendar. &nbsp; Example 1: Input [&quot;MyCalendarThree&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;] [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]] Output [null, 1, 1, 2, 3, 3, 3] Explanation MyCalendarThree myCalendarThree = new MyCalendarThree(); myCalendarThree.book(10, 20); // return 1 myCalendarThree.book(50, 60); // return 1 myCalendarThree.book(10, 40); // return 2 myCalendarThree.book(5, 15); // return 3 myCalendarThree.book(5, 10); // return 3 myCalendarThree.book(25, 55); // return 3 &nbsp; Constraints: 0 &lt;= startTime &lt; endTime &lt;= 109 At most 400 calls will be made to book."
    },
    {
      "number": 733,
      "title": "Flood Fill",
      "titleSlug": "flood-fill",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Depth-First Search",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "You are given an image represented by an m x n grid of integers image, where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and color. Your task is to perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill: Begin with the starting pixel and change its color to color. Perform the same process for each pixel that is directly adjacent (pixels that share a side with the original pixel, either horizontally or vertically) and shares the same color as the starting pixel. Keep repeating this process by checking neighboring pixels of the updated pixels&nbsp;and modifying their color if it matches the original color of the starting pixel. The process stops when there are no more adjacent pixels of the original color to update. Return the modified image after performing the flood fill. &nbsp; Example 1: Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color. Note the bottom corner is not colored 2, because it is not horizontally or vertically connected to the starting pixel. Example 2: Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0 Output: [[0,0,0],[0,0,0]] Explanation: The starting pixel is already colored with 0, which is the same as the target color. Therefore, no changes are made to the image. &nbsp; Constraints: m == image.length n == image[i].length 1 &lt;= m, n &lt;= 50 0 &lt;= image[i][j], color &lt; 216 0 &lt;= sr &lt; m 0 &lt;= sc &lt; n"
    },
    {
      "number": 735,
      "title": "Asteroid Collision",
      "titleSlug": "asteroid-collision",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Stack",
        "Simulation"
      ],
      "description": "We are given an array asteroids of integers representing asteroids in a row. The indices of the asteriod in the array represent their relative position in space. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet. &nbsp; Example 1: Input: asteroids = [5,10,-5] Output: [5,10] Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide. Example 2: Input: asteroids = [8,-8] Output: [] Explanation: The 8 and -8 collide exploding each other. Example 3: Input: asteroids = [10,2,-5] Output: [10] Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10. &nbsp; Constraints: 2 &lt;= asteroids.length &lt;= 104 -1000 &lt;= asteroids[i] &lt;= 1000 asteroids[i] != 0"
    },
    {
      "number": 736,
      "title": "Parse Lisp Expression",
      "titleSlug": "parse-lisp-expression",
      "difficulty": "Hard",
      "tags": [
        "Hash Table",
        "String",
        "Stack",
        "Recursion"
      ],
      "description": "You are given a string expression representing a Lisp-like expression to return the integer value of. The syntax for these expressions is given as follows. An expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer. (An integer could be positive or negative.) A let expression takes the form &quot;(let v1 e1 v2 e2 ... vn en expr)&quot;, where let is always the string &quot;let&quot;, then there are one or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let expression is the value of the expression expr. An add expression takes the form &quot;(add e1 e2)&quot; where add is always the string &quot;add&quot;, there are always two expressions e1, e2 and the result is the addition of the evaluation of e1 and the evaluation of e2. A mult expression takes the form &quot;(mult e1 e2)&quot; where mult is always the string &quot;mult&quot;, there are always two expressions e1, e2 and the result is the multiplication of the evaluation of e1 and the evaluation of e2. For this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally, for your convenience, the names &quot;add&quot;, &quot;let&quot;, and &quot;mult&quot; are protected and will never be used as variable names. Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope. &nbsp; Example 1: Input: expression = &quot;(let x 2 (mult x (let x 3 y 4 (add x y))))&quot; Output: 14 Explanation: In the expression (add x y), when checking for the value of the variable x, we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate. Since x = 3 is found first, the value of x is 3. Example 2: Input: expression = &quot;(let x 3 x 2 x)&quot; Output: 2 Explanation: Assignment in let statements is processed sequentially. Example 3: Input: expression = &quot;(let x 1 y 2 x (add x y) (add x y))&quot; Output: 5 Explanation: The first (add x y) evaluates as 3, and is assigned to x. The second (add x y) evaluates as 3+2 = 5. &nbsp; Constraints: 1 &lt;= expression.length &lt;= 2000 There are no leading or trailing spaces in expression. All tokens are separated by a single space in expression. The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer. The expression is guaranteed to be legal and evaluate to an integer."
    },
    {
      "number": 738,
      "title": "Monotone Increasing Digits",
      "titleSlug": "monotone-increasing-digits",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Greedy"
      ],
      "description": "An integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x &lt;= y. Given an integer n, return the largest number that is less than or equal to n with monotone increasing digits. &nbsp; Example 1: Input: n = 10 Output: 9 Example 2: Input: n = 1234 Output: 1234 Example 3: Input: n = 332 Output: 299 &nbsp; Constraints: 0 &lt;= n &lt;= 109"
    },
    {
      "number": 739,
      "title": "Daily Temperatures",
      "titleSlug": "daily-temperatures",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Stack",
        "Monotonic Stack"
      ],
      "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead. &nbsp; Example 1: Input: temperatures = [73,74,75,71,69,72,76,73] Output: [1,1,4,2,1,1,0,0] Example 2: Input: temperatures = [30,40,50,60] Output: [1,1,1,0] Example 3: Input: temperatures = [30,60,90] Output: [1,1,0] &nbsp; Constraints: 1 &lt;=&nbsp;temperatures.length &lt;= 105 30 &lt;=&nbsp;temperatures[i] &lt;= 100"
    },
    {
      "number": 740,
      "title": "Delete and Earn",
      "titleSlug": "delete-and-earn",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Dynamic Programming"
      ],
      "description": "You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times: Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1. Return the maximum number of points you can earn by applying the above operation some number of times. &nbsp; Example 1: Input: nums = [3,4,2] Output: 6 Explanation: You can perform the following operations: - Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2]. - Delete 2 to earn 2 points. nums = []. You earn a total of 6 points. Example 2: Input: nums = [2,2,3,3,3,4] Output: 9 Explanation: You can perform the following operations: - Delete a 3 to earn 3 points. All 2&#39;s and 4&#39;s are also deleted. nums = [3,3]. - Delete a 3 again to earn 3 points. nums = [3]. - Delete a 3 once more to earn 3 points. nums = []. You earn a total of 9 points. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 2 * 104 1 &lt;= nums[i] &lt;= 104"
    },
    {
      "number": 741,
      "title": "Cherry Pickup",
      "titleSlug": "cherry-pickup",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Matrix"
      ],
      "description": "You are given an n x n grid representing a field of cherries, each cell is one of three possible integers. 0 means the cell is empty, so you can pass through, 1 means the cell contains a cherry that you can pick up and pass through, or -1 means the cell contains a thorn that blocks your way. Return the maximum number of cherries you can collect by following the rules below: Starting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1). After reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells. When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0. If there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected. &nbsp; Example 1: Input: grid = [[0,1,-1],[1,0,-1],[1,1,1]] Output: 5 Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2). 4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]]. Then, the player went left, up, up, left to return home, picking up one more cherry. The total number of cherries picked up is 5, and this is the maximum possible. Example 2: Input: grid = [[1,1,-1],[1,-1,1],[-1,1,1]] Output: 0 &nbsp; Constraints: n == grid.length n == grid[i].length 1 &lt;= n &lt;= 50 grid[i][j] is -1, 0, or 1. grid[0][0] != -1 grid[n - 1][n - 1] != -1"
    },
    {
      "number": 743,
      "title": "Network Delay Time",
      "titleSlug": "network-delay-time",
      "difficulty": "Medium",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Graph",
        "Heap (Priority Queue)",
        "Shortest Path"
      ],
      "description": "You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target. We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1. &nbsp; Example 1: Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 Output: 2 Example 2: Input: times = [[1,2,1]], n = 2, k = 1 Output: 1 Example 3: Input: times = [[1,2,1]], n = 2, k = 2 Output: -1 &nbsp; Constraints: 1 &lt;= k &lt;= n &lt;= 100 1 &lt;= times.length &lt;= 6000 times[i].length == 3 1 &lt;= ui, vi &lt;= n ui != vi 0 &lt;= wi &lt;= 100 All the pairs (ui, vi) are unique. (i.e., no multiple edges.)"
    },
    {
      "number": 744,
      "title": "Find Smallest Letter Greater Than Target",
      "titleSlug": "find-smallest-letter-greater-than-target",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Binary Search"
      ],
      "description": "You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters. Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters. &nbsp; Example 1: Input: letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;a&quot; Output: &quot;c&quot; Explanation: The smallest character that is lexicographically greater than &#39;a&#39; in letters is &#39;c&#39;. Example 2: Input: letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;c&quot; Output: &quot;f&quot; Explanation: The smallest character that is lexicographically greater than &#39;c&#39; in letters is &#39;f&#39;. Example 3: Input: letters = [&quot;x&quot;,&quot;x&quot;,&quot;y&quot;,&quot;y&quot;], target = &quot;z&quot; Output: &quot;x&quot; Explanation: There are no characters in letters that is lexicographically greater than &#39;z&#39; so we return letters[0]. &nbsp; Constraints: 2 &lt;= letters.length &lt;= 104 letters[i] is a lowercase English letter. letters is sorted in non-decreasing order. letters contains at least two different characters. target is a lowercase English letter."
    },
    {
      "number": 745,
      "title": "Prefix and Suffix Search",
      "titleSlug": "prefix-and-suffix-search",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Design",
        "Trie"
      ],
      "description": "Design a special dictionary that searches the words in it by a prefix and a suffix. Implement the WordFilter class: WordFilter(string[] words) Initializes the object with the words in the dictionary. f(string pref, string suff) Returns the index of the word in the dictionary, which has the prefix pref and the suffix suff. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1. &nbsp; Example 1: Input [&quot;WordFilter&quot;, &quot;f&quot;] [[[&quot;apple&quot;]], [&quot;a&quot;, &quot;e&quot;]] Output [null, 0] Explanation WordFilter wordFilter = new WordFilter([&quot;apple&quot;]); wordFilter.f(&quot;a&quot;, &quot;e&quot;); // return 0, because the word at index 0 has prefix = &quot;a&quot; and suffix = &quot;e&quot;. &nbsp; Constraints: 1 &lt;= words.length &lt;= 104 1 &lt;= words[i].length &lt;= 7 1 &lt;= pref.length, suff.length &lt;= 7 words[i], pref and suff consist of lowercase English letters only. At most 104 calls will be made to the function f."
    },
    {
      "number": 746,
      "title": "Min Cost Climbing Stairs",
      "titleSlug": "min-cost-climbing-stairs",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor. &nbsp; Example 1: Input: cost = [10,15,20] Output: 15 Explanation: You will start at index 1. - Pay 15 and climb two steps to reach the top. The total cost is 15. Example 2: Input: cost = [1,100,1,1,1,100,1,1,100,1] Output: 6 Explanation: You will start at index 0. - Pay 1 and climb two steps to reach index 2. - Pay 1 and climb two steps to reach index 4. - Pay 1 and climb two steps to reach index 6. - Pay 1 and climb one step to reach index 7. - Pay 1 and climb two steps to reach index 9. - Pay 1 and climb one step to reach the top. The total cost is 6. &nbsp; Constraints: 2 &lt;= cost.length &lt;= 1000 0 &lt;= cost[i] &lt;= 999"
    },
    {
      "number": 747,
      "title": "Largest Number At Least Twice of Others",
      "titleSlug": "largest-number-at-least-twice-of-others",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Sorting"
      ],
      "description": "You are given an integer array nums where the largest integer is unique. Determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise. &nbsp; Example 1: Input: nums = [3,6,1,0] Output: 1 Explanation: 6 is the largest integer. For every other number in the array x, 6 is at least twice as big as x. The index of value 6 is 1, so we return 1. Example 2: Input: nums = [1,2,3,4] Output: -1 Explanation: 4 is less than twice the value of 3, so we return -1. &nbsp; Constraints: 2 &lt;= nums.length &lt;= 50 0 &lt;= nums[i] &lt;= 100 The largest element in nums is unique."
    },
    {
      "number": 748,
      "title": "Shortest Completing Word",
      "titleSlug": "shortest-completing-word",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "Given a string licensePlate and an array of strings words, find the shortest completing word in words. A completing word is a word that contains all the letters in licensePlate. Ignore numbers and spaces in licensePlate, and treat letters as case insensitive. If a letter appears more than once in licensePlate, then it must appear in the word the same number of times or more. For example, if licensePlate = &quot;aBc 12c&quot;, then it contains letters &#39;a&#39;, &#39;b&#39; (ignoring case), and &#39;c&#39; twice. Possible completing words are &quot;abccdef&quot;, &quot;caaacab&quot;, and &quot;cbca&quot;. Return the shortest completing word in words. It is guaranteed an answer exists. If there are multiple shortest completing words, return the first one that occurs in words. &nbsp; Example 1: Input: licensePlate = &quot;1s3 PSt&quot;, words = [&quot;step&quot;,&quot;steps&quot;,&quot;stripe&quot;,&quot;stepple&quot;] Output: &quot;steps&quot; Explanation: licensePlate contains letters &#39;s&#39;, &#39;p&#39;, &#39;s&#39; (ignoring case), and &#39;t&#39;. &quot;step&quot; contains &#39;t&#39; and &#39;p&#39;, but only contains 1 &#39;s&#39;. &quot;steps&quot; contains &#39;t&#39;, &#39;p&#39;, and both &#39;s&#39; characters. &quot;stripe&quot; is missing an &#39;s&#39;. &quot;stepple&quot; is missing an &#39;s&#39;. Since &quot;steps&quot; is the only word containing all the letters, that is the answer. Example 2: Input: licensePlate = &quot;1s3 456&quot;, words = [&quot;looks&quot;,&quot;pest&quot;,&quot;stew&quot;,&quot;show&quot;] Output: &quot;pest&quot; Explanation: licensePlate only contains the letter &#39;s&#39;. All the words contain &#39;s&#39;, but among these &quot;pest&quot;, &quot;stew&quot;, and &quot;show&quot; are shortest. The answer is &quot;pest&quot; because it is the word that appears earliest of the 3. &nbsp; Constraints: 1 &lt;= licensePlate.length &lt;= 7 licensePlate contains digits, letters (uppercase or lowercase), or space &#39; &#39;. 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 15 words[i] consists of lower case English letters."
    },
    {
      "number": 749,
      "title": "Contain Virus",
      "titleSlug": "contain-virus",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Depth-First Search",
        "Breadth-First Search",
        "Matrix",
        "Simulation"
      ],
      "description": "A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls. The world is modeled as an m x n binary grid isInfected, where isInfected[i][j] == 0 represents uninfected cells, and isInfected[i][j] == 1 represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary. Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There will never be a tie. Return the number of walls used to quarantine all the infected regions. If the world will become fully infected, return the number of walls used. &nbsp; Example 1: Input: isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]] Output: 10 Explanation: There are 2 contaminated regions. On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is: On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained. Example 2: Input: isInfected = [[1,1,1],[1,0,1],[1,1,1]] Output: 4 Explanation: Even though there is only one cell saved, there are 4 walls built. Notice that walls are only built on the shared boundary of two different cells. Example 3: Input: isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]] Output: 13 Explanation: The region on the left only builds two new walls. &nbsp; Constraints: m ==&nbsp;isInfected.length n ==&nbsp;isInfected[i].length 1 &lt;= m, n &lt;= 50 isInfected[i][j] is either 0 or 1. There is always a contiguous viral region throughout the described process that will infect strictly more uncontaminated squares in the next round."
    },
    {
      "number": 752,
      "title": "Open the Lock",
      "titleSlug": "open-the-lock",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Breadth-First Search"
      ],
      "description": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;. The wheels can rotate freely and wrap around: for example we can turn &#39;9&#39; to be &#39;0&#39;, or &#39;0&#39; to be &#39;9&#39;. Each move consists of turning one wheel one slot. The lock initially starts at &#39;0000&#39;, a string representing the state of the 4 wheels. You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it. Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible. &nbsp; Example 1: Input: deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot; Output: 6 Explanation: A sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;. Note that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid, because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;. Example 2: Input: deadends = [&quot;8888&quot;], target = &quot;0009&quot; Output: 1 Explanation: We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;. Example 3: Input: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot; Output: -1 Explanation: We cannot reach the target without getting stuck. &nbsp; Constraints: 1 &lt;= deadends.length &lt;= 500 deadends[i].length == 4 target.length == 4 target will not be in the list deadends. target and deadends[i] consist of digits only."
    },
    {
      "number": 753,
      "title": "Cracking the Safe",
      "titleSlug": "cracking-the-safe",
      "difficulty": "Hard",
      "tags": [
        "Depth-First Search",
        "Graph",
        "Eulerian Circuit"
      ],
      "description": "There is a safe protected by a password. The password is a sequence of n digits where each digit can be in the range [0, k - 1]. The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the most recent n digits that were entered each time you type a digit. For example, the correct password is &quot;345&quot; and you enter in &quot;012345&quot;: After typing 0, the most recent 3 digits is &quot;0&quot;, which is incorrect. After typing 1, the most recent 3 digits is &quot;01&quot;, which is incorrect. After typing 2, the most recent 3 digits is &quot;012&quot;, which is incorrect. After typing 3, the most recent 3 digits is &quot;123&quot;, which is incorrect. After typing 4, the most recent 3 digits is &quot;234&quot;, which is incorrect. After typing 5, the most recent 3 digits is &quot;345&quot;, which is correct and the safe unlocks. Return any string of minimum length that will unlock the safe at some point of entering it. &nbsp; Example 1: Input: n = 1, k = 2 Output: &quot;10&quot; Explanation: The password is a single digit, so enter each digit. &quot;01&quot; would also unlock the safe. Example 2: Input: n = 2, k = 2 Output: &quot;01100&quot; Explanation: For each possible password: - &quot;00&quot; is typed in starting from the 4th digit. - &quot;01&quot; is typed in starting from the 1st digit. - &quot;10&quot; is typed in starting from the 3rd digit. - &quot;11&quot; is typed in starting from the 2nd digit. Thus &quot;01100&quot; will unlock the safe. &quot;10011&quot;, and &quot;11001&quot; would also unlock the safe. &nbsp; Constraints: 1 &lt;= n &lt;= 4 1 &lt;= k &lt;= 10 1 &lt;= kn &lt;= 4096"
    },
    {
      "number": 754,
      "title": "Reach a Number",
      "titleSlug": "reach-a-number",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Binary Search"
      ],
      "description": "You are standing at position 0 on an infinite number line. There is a destination at position target. You can make some number of moves numMoves so that: On each move, you can either go left or right. During the ith move (starting from i == 1 to i == numMoves), you take i steps in the chosen direction. Given the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination. &nbsp; Example 1: Input: target = 2 Output: 3 Explanation: On the 1st move, we step from 0 to 1 (1 step). On the 2nd move, we step from 1 to -1 (2 steps). On the 3rd move, we step from -1 to 2 (3 steps). Example 2: Input: target = 3 Output: 2 Explanation: On the 1st move, we step from 0 to 1 (1 step). On the 2nd move, we step from 1 to 3 (2 steps). &nbsp; Constraints: -109 &lt;= target &lt;= 109 target != 0"
    },
    {
      "number": 756,
      "title": "Pyramid Transition Matrix",
      "titleSlug": "pyramid-transition-matrix",
      "difficulty": "Medium",
      "tags": [
        "Bit Manipulation",
        "Depth-First Search",
        "Breadth-First Search"
      ],
      "description": "You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains one less block than the row beneath it and is centered on top. To make the pyramid aesthetically pleasing, there are only specific triangular patterns that are allowed. A triangular pattern consists of a single block stacked on top of two blocks. The patterns are given&nbsp;as a list of&nbsp;three-letter strings allowed, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block. For example, &quot;ABC&quot; represents a triangular pattern with a &#39;C&#39; block stacked on top of an &#39;A&#39; (left) and &#39;B&#39; (right) block. Note that this is different from &quot;BAC&quot; where &#39;B&#39; is on the left bottom and &#39;A&#39; is on the right bottom. You start with a bottom row of blocks bottom, given as a single string, that you must use as the base of the pyramid. Given bottom and allowed, return true if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in allowed, or false otherwise. &nbsp; Example 1: Input: bottom = &quot;BCD&quot;, allowed = [&quot;BCC&quot;,&quot;CDE&quot;,&quot;CEA&quot;,&quot;FFF&quot;] Output: true Explanation: The allowed triangular patterns are shown on the right. Starting from the bottom (level 3), we can build &quot;CE&quot; on level 2 and then build &quot;A&quot; on level 1. There are three triangular patterns in the pyramid, which are &quot;BCC&quot;, &quot;CDE&quot;, and &quot;CEA&quot;. All are allowed. Example 2: Input: bottom = &quot;AAAA&quot;, allowed = [&quot;AAB&quot;,&quot;AAC&quot;,&quot;BCD&quot;,&quot;BBE&quot;,&quot;DEF&quot;] Output: false Explanation: The allowed triangular patterns are shown on the right. Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1. &nbsp; Constraints: 2 &lt;= bottom.length &lt;= 6 0 &lt;= allowed.length &lt;= 216 allowed[i].length == 3 The letters in all input strings are from the set {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;}. All the values of allowed are unique."
    },
    {
      "number": 757,
      "title": "Set Intersection Size At Least Two",
      "titleSlug": "set-intersection-size-at-least-two",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Greedy",
        "Sorting"
      ],
      "description": "You are given a 2D integer array intervals where intervals[i] = [starti, endi] represents all the integers from starti to endi inclusively. A containing set is an array nums where each interval from intervals has at least two integers in nums. For example, if intervals = [[1,3], [3,7], [8,9]], then [1,2,4,7,8,9] and [2,3,4,8,9] are containing sets. Return the minimum possible size of a containing set. &nbsp; Example 1: Input: intervals = [[1,3],[3,7],[8,9]] Output: 5 Explanation: let nums = [2, 3, 4, 8, 9]. It can be shown that there cannot be any containing array of size 4. Example 2: Input: intervals = [[1,3],[1,4],[2,5],[3,5]] Output: 3 Explanation: let nums = [2, 3, 4]. It can be shown that there cannot be any containing array of size 2. Example 3: Input: intervals = [[1,2],[2,3],[2,4],[4,5]] Output: 5 Explanation: let nums = [1, 2, 3, 4, 5]. It can be shown that there cannot be any containing array of size 4. &nbsp; Constraints: 1 &lt;= intervals.length &lt;= 3000 intervals[i].length == 2 0 &lt;= starti &lt; endi &lt;= 108"
    },
    {
      "number": 761,
      "title": "Special Binary String",
      "titleSlug": "special-binary-string",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Recursion"
      ],
      "description": "Special binary strings are binary strings with the following two properties: The number of 0&#39;s is equal to the number of 1&#39;s. Every prefix of the binary string has at least as many 1&#39;s as 0&#39;s. You are given a special binary string s. A move consists of choosing two consecutive, non-empty, special substrings of s, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string. Return the lexicographically largest resulting string possible after applying the mentioned operations on the string. &nbsp; Example 1: Input: s = &quot;11011000&quot; Output: &quot;11100100&quot; Explanation: The strings &quot;10&quot; [occuring at s[1]] and &quot;1100&quot; [at s[3]] are swapped. This is the lexicographically largest string possible after some number of swaps. Example 2: Input: s = &quot;10&quot; Output: &quot;10&quot; &nbsp; Constraints: 1 &lt;= s.length &lt;= 50 s[i] is either &#39;0&#39; or &#39;1&#39;. s is a special binary string."
    },
    {
      "number": 762,
      "title": "Prime Number of Set Bits in Binary Representation",
      "titleSlug": "prime-number-of-set-bits-in-binary-representation",
      "difficulty": "Easy",
      "tags": [
        "Math",
        "Bit Manipulation"
      ],
      "description": "Given two integers left and right, return the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation. Recall that the number of set bits an integer has is the number of 1&#39;s present when written in binary. For example, 21 written in binary is 10101, which has 3 set bits. &nbsp; Example 1: Input: left = 6, right = 10 Output: 4 Explanation: 6 -&gt; 110 (2 set bits, 2 is prime) 7 -&gt; 111 (3 set bits, 3 is prime) 8 -&gt; 1000 (1 set bit, 1 is not prime) 9 -&gt; 1001 (2 set bits, 2 is prime) 10 -&gt; 1010 (2 set bits, 2 is prime) 4 numbers have a prime number of set bits. Example 2: Input: left = 10, right = 15 Output: 5 Explanation: 10 -&gt; 1010 (2 set bits, 2 is prime) 11 -&gt; 1011 (3 set bits, 3 is prime) 12 -&gt; 1100 (2 set bits, 2 is prime) 13 -&gt; 1101 (3 set bits, 3 is prime) 14 -&gt; 1110 (3 set bits, 3 is prime) 15 -&gt; 1111 (4 set bits, 4 is not prime) 5 numbers have a prime number of set bits. &nbsp; Constraints: 1 &lt;= left &lt;= right &lt;= 106 0 &lt;= right - left &lt;= 104"
    },
    {
      "number": 763,
      "title": "Partition Labels",
      "titleSlug": "partition-labels",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Two Pointers",
        "String",
        "Greedy"
      ],
      "description": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string &quot;ababcc&quot; can be partitioned into [&quot;abab&quot;, &quot;cc&quot;], but partitions such as [&quot;aba&quot;, &quot;bcc&quot;] or [&quot;ab&quot;, &quot;ab&quot;, &quot;cc&quot;] are invalid. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts. &nbsp; Example 1: Input: s = &quot;ababcbacadefegdehijhklij&quot; Output: [9,7,8] Explanation: The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;. This is a partition so that each letter appears in at most one part. A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts. Example 2: Input: s = &quot;eccbbbbdec&quot; Output: [10] &nbsp; Constraints: 1 &lt;= s.length &lt;= 500 s consists of lowercase English letters."
    },
    {
      "number": 764,
      "title": "Largest Plus Sign",
      "titleSlug": "largest-plus-sign",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "You are given an integer n. You have an n x n binary grid grid with all values initially 1&#39;s except for some indices given in the array mines. The ith element of the array mines is defined as mines[i] = [xi, yi] where grid[xi][yi] == 0. Return the order of the largest axis-aligned plus sign of 1&#39;s contained in grid. If there is none, return 0. An axis-aligned plus sign of 1&#39;s of order k has some center grid[r][c] == 1 along with four arms of length k - 1 going up, down, left, and right, and made of 1&#39;s. Note that there could be 0&#39;s or 1&#39;s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1&#39;s. &nbsp; Example 1: Input: n = 5, mines = [[4,2]] Output: 2 Explanation: In the above grid, the largest plus sign can only be of order 2. One of them is shown. Example 2: Input: n = 1, mines = [[0,0]] Output: 0 Explanation: There is no plus sign, so return 0. &nbsp; Constraints: 1 &lt;= n &lt;= 500 1 &lt;= mines.length &lt;= 5000 0 &lt;= xi, yi &lt; n All the pairs (xi, yi) are unique."
    },
    {
      "number": 765,
      "title": "Couples Holding Hands",
      "titleSlug": "couples-holding-hands",
      "difficulty": "Hard",
      "tags": [
        "Greedy",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Graph"
      ],
      "description": "There are n couples sitting in 2n seats arranged in a row and want to hold hands. The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1). Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats. &nbsp; Example 1: Input: row = [0,2,1,3] Output: 1 Explanation: We only need to swap the second (row[1]) and third (row[2]) person. Example 2: Input: row = [3,2,0,1] Output: 0 Explanation: All couples are already seated side by side. &nbsp; Constraints: 2n == row.length 2 &lt;= n &lt;= 30 n is even. 0 &lt;= row[i] &lt; 2n All the elements of row are unique."
    },
    {
      "number": 766,
      "title": "Toeplitz Matrix",
      "titleSlug": "toeplitz-matrix",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Matrix"
      ],
      "description": "Given an m x n matrix, return&nbsp;true&nbsp;if the matrix is Toeplitz. Otherwise, return false. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements. &nbsp; Example 1: Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]] Output: true Explanation: In the above grid, the&nbsp;diagonals are: &quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;. In each diagonal all elements are the same, so the answer is True. Example 2: Input: matrix = [[1,2],[2,2]] Output: false Explanation: The diagonal &quot;[1, 2]&quot; has different elements. &nbsp; Constraints: m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 20 0 &lt;= matrix[i][j] &lt;= 99 &nbsp; Follow up: What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? What if the matrix is so large that you can only load up a partial row into the memory at once?"
    },
    {
      "number": 767,
      "title": "Reorganize String",
      "titleSlug": "reorganize-string",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Greedy",
        "Sorting",
        "Heap (Priority Queue)",
        "Counting"
      ],
      "description": "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same. Return any possible rearrangement of s or return &quot;&quot; if not possible. &nbsp; Example 1: Input: s = \"aab\" Output: \"aba\" Example 2: Input: s = \"aaab\" Output: \"\" &nbsp; Constraints: 1 &lt;= s.length &lt;= 500 s consists of lowercase English letters."
    },
    {
      "number": 768,
      "title": "Max Chunks To Make Sorted II",
      "titleSlug": "max-chunks-to-make-sorted-ii",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Stack",
        "Greedy",
        "Sorting",
        "Monotonic Stack"
      ],
      "description": "You are given an integer array arr. We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array. Return the largest number of chunks we can make to sort the array. &nbsp; Example 1: Input: arr = [5,4,3,2,1] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn&#39;t sorted. Example 2: Input: arr = [2,1,3,4,4] Output: 4 Explanation: We can split into two chunks, such as [2, 1], [3, 4, 4]. However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 2000 0 &lt;= arr[i] &lt;= 108"
    },
    {
      "number": 769,
      "title": "Max Chunks To Make Sorted",
      "titleSlug": "max-chunks-to-make-sorted",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Stack",
        "Greedy",
        "Sorting",
        "Monotonic Stack"
      ],
      "description": "You are given an integer array arr of length n that represents a permutation of the integers in the range [0, n - 1]. We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array. Return the largest number of chunks we can make to sort the array. &nbsp; Example 1: Input: arr = [4,3,2,1,0] Output: 1 Explanation: Splitting into two or more chunks will not return the required result. For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn&#39;t sorted. Example 2: Input: arr = [1,0,2,3,4] Output: 4 Explanation: We can split into two chunks, such as [1, 0], [2, 3, 4]. However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible. &nbsp; Constraints: n == arr.length 1 &lt;= n &lt;= 10 0 &lt;= arr[i] &lt; n All the elements of arr are unique."
    },
    {
      "number": 770,
      "title": "Basic Calculator IV",
      "titleSlug": "basic-calculator-iv",
      "difficulty": "Hard",
      "tags": [
        "Hash Table",
        "Math",
        "String",
        "Stack",
        "Recursion"
      ],
      "description": "Given an expression such as expression = &quot;e + 8 - a + 5&quot; and an evaluation map such as {&quot;e&quot;: 1} (given in terms of evalvars = [&quot;e&quot;] and evalints = [1]), return a list of tokens representing the simplified expression, such as [&quot;-1*a&quot;,&quot;14&quot;] An expression alternates chunks and symbols, with a space separating each chunk and symbol. A chunk is either an expression in parentheses, a variable, or a non-negative integer. A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like &quot;2x&quot; or &quot;-x&quot;. Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, expression = &quot;1 + 2 * 3&quot; has an answer of [&quot;7&quot;]. The format of the output is as follows: For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like &quot;b*a*c&quot;, only &quot;a*b*c&quot;. Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term. For example, &quot;a*a*b*c&quot; has degree 4. The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed. An example of a well-formatted answer is [&quot;-2*a*a*a&quot;, &quot;3*a*a*b&quot;, &quot;3*b*b&quot;, &quot;4*a&quot;, &quot;5*c&quot;, &quot;-6&quot;]. Terms (including constant terms) with coefficient 0 are not included. For example, an expression of &quot;0&quot; has an output of []. Note: You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1]. &nbsp; Example 1: Input: expression = &quot;e + 8 - a + 5&quot;, evalvars = [&quot;e&quot;], evalints = [1] Output: [&quot;-1*a&quot;,&quot;14&quot;] Example 2: Input: expression = &quot;e - 8 + temperature - pressure&quot;, evalvars = [&quot;e&quot;, &quot;temperature&quot;], evalints = [1, 12] Output: [&quot;-1*pressure&quot;,&quot;5&quot;] Example 3: Input: expression = &quot;(e + 8) * (e - 8)&quot;, evalvars = [], evalints = [] Output: [&quot;1*e*e&quot;,&quot;-64&quot;] &nbsp; Constraints: 1 &lt;= expression.length &lt;= 250 expression consists of lowercase English letters, digits, &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;(&#39;, &#39;)&#39;, &#39; &#39;. expression does not contain any leading or trailing spaces. All the tokens in expression are separated by a single space. 0 &lt;= evalvars.length &lt;= 100 1 &lt;= evalvars[i].length &lt;= 20 evalvars[i] consists of lowercase English letters. evalints.length == evalvars.length -100 &lt;= evalints[i] &lt;= 100"
    },
    {
      "number": 771,
      "title": "Jewels and Stones",
      "titleSlug": "jewels-and-stones",
      "difficulty": "Easy",
      "tags": [
        "Hash Table",
        "String"
      ],
      "description": "You&#39;re given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels. Letters are case sensitive, so &quot;a&quot; is considered a different type of stone from &quot;A&quot;. &nbsp; Example 1: Input: jewels = \"aA\", stones = \"aAAbbbb\" Output: 3 Example 2: Input: jewels = \"z\", stones = \"ZZ\" Output: 0 &nbsp; Constraints: 1 &lt;=&nbsp;jewels.length, stones.length &lt;= 50 jewels and stones consist of only English letters. All the characters of&nbsp;jewels are unique."
    },
    {
      "number": 773,
      "title": "Sliding Puzzle",
      "titleSlug": "sliding-puzzle",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Backtracking",
        "Breadth-First Search",
        "Memoization",
        "Matrix"
      ],
      "description": "On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it. The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]]. Given the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1. &nbsp; Example 1: Input: board = [[1,2,3],[4,0,5]] Output: 1 Explanation: Swap the 0 and the 5 in one move. Example 2: Input: board = [[1,2,3],[5,4,0]] Output: -1 Explanation: No number of moves will make the board solved. Example 3: Input: board = [[4,1,2],[5,0,3]] Output: 5 Explanation: 5 is the smallest number of moves that solves the board. An example path: After move 0: [[4,1,2],[5,0,3]] After move 1: [[4,1,2],[0,5,3]] After move 2: [[0,1,2],[4,5,3]] After move 3: [[1,0,2],[4,5,3]] After move 4: [[1,2,0],[4,5,3]] After move 5: [[1,2,3],[4,5,0]] &nbsp; Constraints: board.length == 2 board[i].length == 3 0 &lt;= board[i][j] &lt;= 5 Each value board[i][j] is unique."
    },
    {
      "number": 775,
      "title": "Global and Local Inversions",
      "titleSlug": "global-and-local-inversions",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math"
      ],
      "description": "You are given an integer array nums of length n which represents a permutation of all the integers in the range [0, n - 1]. The number of global inversions is the number of the different pairs (i, j) where: 0 &lt;= i &lt; j &lt; n nums[i] &gt; nums[j] The number of local inversions is the number of indices i where: 0 &lt;= i &lt; n - 1 nums[i] &gt; nums[i + 1] Return true if the number of global inversions is equal to the number of local inversions. &nbsp; Example 1: Input: nums = [1,0,2] Output: true Explanation: There is 1 global inversion and 1 local inversion. Example 2: Input: nums = [1,2,0] Output: false Explanation: There are 2 global inversions and 1 local inversion. &nbsp; Constraints: n == nums.length 1 &lt;= n &lt;= 105 0 &lt;= nums[i] &lt; n All the integers of nums are unique. nums is a permutation of all the numbers in the range [0, n - 1]."
    },
    {
      "number": 777,
      "title": "Swap Adjacent in LR String",
      "titleSlug": "swap-adjacent-in-lr-string",
      "difficulty": "Medium",
      "tags": [
        "Two Pointers",
        "String"
      ],
      "description": "In a string composed of &#39;L&#39;, &#39;R&#39;, and &#39;X&#39; characters, like &quot;RXXLRXRXL&quot;, a move consists of either replacing one occurrence of &quot;XL&quot; with &quot;LX&quot;, or replacing one occurrence of &quot;RX&quot; with &quot;XR&quot;. Given the starting string start and the ending string result, return True if and only if there exists a sequence of moves to transform start to result. &nbsp; Example 1: Input: start = &quot;RXXLRXRXL&quot;, result = &quot;XRLXXRRLX&quot; Output: true Explanation: We can transform start to result following these steps: RXXLRXRXL -&gt; XRXLRXRXL -&gt; XRLXRXRXL -&gt; XRLXXRRXL -&gt; XRLXXRRLX Example 2: Input: start = &quot;X&quot;, result = &quot;L&quot; Output: false &nbsp; Constraints: 1 &lt;= start.length&nbsp;&lt;= 104 start.length == result.length Both start and result will only consist of characters in &#39;L&#39;, &#39;R&#39;, and&nbsp;&#39;X&#39;."
    },
    {
      "number": 778,
      "title": "Swim in Rising Water",
      "titleSlug": "swim-in-rising-water",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Binary Search",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Heap (Priority Queue)",
        "Matrix"
      ],
      "description": "You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j). The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim. Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0). &nbsp; Example 1: Input: grid = [[0,2],[1,3]] Output: 3 Explanation: At time 0, you are in grid location (0, 0). You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0. You cannot reach point (1, 1) until time 3. When the depth of water is 3, we can swim anywhere inside the grid. Example 2: Input: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]] Output: 16 Explanation: The final route is shown. We need to wait until time 16 so that (0, 0) and (4, 4) are connected. &nbsp; Constraints: n == grid.length n == grid[i].length 1 &lt;= n &lt;= 50 0 &lt;= grid[i][j] &lt;&nbsp;n2 Each value grid[i][j] is unique."
    },
    {
      "number": 779,
      "title": "K-th Symbol in Grammar",
      "titleSlug": "k-th-symbol-in-grammar",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Bit Manipulation",
        "Recursion"
      ],
      "description": "We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10. For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110. Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows. &nbsp; Example 1: Input: n = 1, k = 1 Output: 0 Explanation: row 1: 0 Example 2: Input: n = 2, k = 1 Output: 0 Explanation: row 1: 0 row 2: 01 Example 3: Input: n = 2, k = 2 Output: 1 Explanation: row 1: 0 row 2: 01 &nbsp; Constraints: 1 &lt;= n &lt;= 30 1 &lt;= k &lt;= 2n - 1"
    },
    {
      "number": 780,
      "title": "Reaching Points",
      "titleSlug": "reaching-points",
      "difficulty": "Hard",
      "tags": [
        "Math"
      ],
      "description": "Given four integers sx, sy, tx, and ty, return true if it is possible to convert the point (sx, sy) to the point (tx, ty) through some operations, or false otherwise. The allowed operation on some point (x, y) is to convert it to either (x, x + y) or (x + y, y). &nbsp; Example 1: Input: sx = 1, sy = 1, tx = 3, ty = 5 Output: true Explanation: One series of moves that transforms the starting point to the target is: (1, 1) -&gt; (1, 2) (1, 2) -&gt; (3, 2) (3, 2) -&gt; (3, 5) Example 2: Input: sx = 1, sy = 1, tx = 2, ty = 2 Output: false Example 3: Input: sx = 1, sy = 1, tx = 1, ty = 1 Output: true &nbsp; Constraints: 1 &lt;= sx, sy, tx, ty &lt;= 109"
    },
    {
      "number": 781,
      "title": "Rabbits in Forest",
      "titleSlug": "rabbits-in-forest",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Math",
        "Greedy"
      ],
      "description": "There is a forest with an unknown number of rabbits. We asked n rabbits &quot;How many rabbits have the same color as you?&quot; and collected the answers in an integer array answers where answers[i] is the answer of the ith rabbit. Given the array answers, return the minimum number of rabbits that could be in the forest. &nbsp; Example 1: Input: answers = [1,1,2] Output: 5 Explanation: The two rabbits that answered &quot;1&quot; could both be the same color, say red. The rabbit that answered &quot;2&quot; can&#39;t be red or the answers would be inconsistent. Say the rabbit that answered &quot;2&quot; was blue. Then there should be 2 other blue rabbits in the forest that didn&#39;t answer into the array. The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn&#39;t. Example 2: Input: answers = [10,10,10] Output: 11 &nbsp; Constraints: 1 &lt;= answers.length &lt;= 1000 0 &lt;= answers[i] &lt; 1000"
    },
    {
      "number": 782,
      "title": "Transform to Chessboard",
      "titleSlug": "transform-to-chessboard",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Bit Manipulation",
        "Matrix"
      ],
      "description": "You are given an n x n binary grid board. In each move, you can swap any two rows with each other, or any two columns with each other. Return the minimum number of moves to transform the board into a chessboard board. If the task is impossible, return -1. A chessboard board is a board where no 0&#39;s and no 1&#39;s are 4-directionally adjacent. &nbsp; Example 1: Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]] Output: 2 Explanation: One potential sequence of moves is shown. The first move swaps the first and second column. The second move swaps the second and third row. Example 2: Input: board = [[0,1],[1,0]] Output: 0 Explanation: Also note that the board with 0 in the top left corner, is also a valid chessboard. Example 3: Input: board = [[1,0],[1,0]] Output: -1 Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard. &nbsp; Constraints: n == board.length n == board[i].length 2 &lt;= n &lt;= 30 board[i][j] is either&nbsp;0 or 1."
    },
    {
      "number": 783,
      "title": "Minimum Distance Between BST Nodes",
      "titleSlug": "minimum-distance-between-bst-nodes",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree. &nbsp; Example 1: Input: root = [4,2,6,1,3] Output: 1 Example 2: Input: root = [1,0,48,null,null,12,49] Output: 1 &nbsp; Constraints: The number of nodes in the tree is in the range [2, 100]. 0 &lt;= Node.val &lt;= 105 &nbsp; Note: This question is the same as 530: https://leetcode.com/problems/minimum-absolute-difference-in-bst/"
    },
    {
      "number": 784,
      "title": "Letter Case Permutation",
      "titleSlug": "letter-case-permutation",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Backtracking",
        "Bit Manipulation"
      ],
      "description": "Given a string s, you&nbsp;can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. Return the output in any order. &nbsp; Example 1: Input: s = &quot;a1b2&quot; Output: [&quot;a1b2&quot;,&quot;a1B2&quot;,&quot;A1b2&quot;,&quot;A1B2&quot;] Example 2: Input: s = &quot;3z4&quot; Output: [&quot;3z4&quot;,&quot;3Z4&quot;] &nbsp; Constraints: 1 &lt;= s.length &lt;= 12 s consists of lowercase English letters, uppercase English letters, and digits."
    },
    {
      "number": 785,
      "title": "Is Graph Bipartite?",
      "titleSlug": "is-graph-bipartite",
      "difficulty": "Medium",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Graph"
      ],
      "description": "There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties: There are no self-edges (graph[u] does not contain u). There are no parallel edges (graph[u] does not contain duplicate values). If v is in graph[u], then u is in graph[v] (the graph is undirected). The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them. A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B. Return true if and only if it is bipartite. &nbsp; Example 1: Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]] Output: false Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other. Example 2: Input: graph = [[1,3],[0,2],[1,3],[0,2]] Output: true Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}. &nbsp; Constraints: graph.length == n 1 &lt;= n &lt;= 100 0 &lt;= graph[u].length &lt; n 0 &lt;= graph[u][i] &lt;= n - 1 graph[u]&nbsp;does not contain&nbsp;u. All the values of graph[u] are unique. If graph[u] contains v, then graph[v] contains u."
    },
    {
      "number": 786,
      "title": "K-th Smallest Prime Fraction",
      "titleSlug": "k-th-smallest-prime-fraction",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Binary Search",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k. For every i and j where 0 &lt;= i &lt; j &lt; arr.length, we consider the fraction arr[i] / arr[j]. Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j]. &nbsp; Example 1: Input: arr = [1,2,3,5], k = 3 Output: [2,5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3. The third fraction is 2/5. Example 2: Input: arr = [1,7], k = 1 Output: [1,7] &nbsp; Constraints: 2 &lt;= arr.length &lt;= 1000 1 &lt;= arr[i] &lt;= 3 * 104 arr[0] == 1 arr[i] is a prime number for i &gt; 0. All the numbers of arr are unique and sorted in strictly increasing order. 1 &lt;= k &lt;= arr.length * (arr.length - 1) / 2 &nbsp; Follow up: Can you solve the problem with better than O(n2) complexity?"
    },
    {
      "number": 787,
      "title": "Cheapest Flights Within K Stops",
      "titleSlug": "cheapest-flights-within-k-stops",
      "difficulty": "Medium",
      "tags": [
        "Dynamic Programming",
        "Depth-First Search",
        "Breadth-First Search",
        "Graph",
        "Heap (Priority Queue)",
        "Shortest Path"
      ],
      "description": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei. You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1. &nbsp; Example 1: Input: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1 Output: 700 Explanation: The graph is shown above. The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700. Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops. Example 2: Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1 Output: 200 Explanation: The graph is shown above. The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200. Example 3: Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0 Output: 500 Explanation: The graph is shown above. The optimal path with no stops from city 0 to 2 is marked in red and has cost 500. &nbsp; Constraints: 1 &lt;= n &lt;= 100 0 &lt;= flights.length &lt;= (n * (n - 1) / 2) flights[i].length == 3 0 &lt;= fromi, toi &lt; n fromi != toi 1 &lt;= pricei &lt;= 104 There will not be any multiple flights between two cities. 0 &lt;= src, dst, k &lt; n src != dst"
    },
    {
      "number": 788,
      "title": "Rotated Digits",
      "titleSlug": "rotated-digits",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Dynamic Programming"
      ],
      "description": "An integer x is a good if after rotating each digit individually by 180 degrees, we get a valid number that is different from x. Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. For example: 0, 1, and 8 rotate to themselves, 2 and 5 rotate to each other (in this case they are rotated in a different direction, in other words, 2 or 5 gets mirrored), 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Given an integer n, return the number of good integers in the range [1, n]. &nbsp; Example 1: Input: n = 10 Output: 4 Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9. Note that 1 and 10 are not good numbers, since they remain unchanged after rotating. Example 2: Input: n = 1 Output: 0 Example 3: Input: n = 2 Output: 1 &nbsp; Constraints: 1 &lt;= n &lt;= 104"
    },
    {
      "number": 789,
      "title": "Escape The Ghosts",
      "titleSlug": "escape-the-ghosts",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math"
      ],
      "description": "You are playing a simplified PAC-MAN game on an infinite 2-D grid. You start at the point [0, 0], and you are given a destination point target = [xtarget, ytarget] that you are trying to get to. There are several ghosts on the map with their starting positions given as a 2D array ghosts, where ghosts[i] = [xi, yi] represents the starting position of the ith ghost. All inputs are integral coordinates. Each turn, you and all the ghosts may independently choose to either move 1 unit in any of the four cardinal directions: north, east, south, or west, or stay still. All actions happen simultaneously. You escape if and only if you can reach the target before any ghost reaches you. If you reach any square (including the target) at the same time as a ghost, it does not count as an escape. Return true if it is possible to escape regardless of how the ghosts move, otherwise return false. &nbsp; Example 1: Input: ghosts = [[1,0],[0,3]], target = [0,1] Output: true Explanation: You can reach the destination (0, 1) after 1 turn, while the ghosts located at (1, 0) and (0, 3) cannot catch up with you. Example 2: Input: ghosts = [[1,0]], target = [2,0] Output: false Explanation: You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination. Example 3: Input: ghosts = [[2,0]], target = [1,0] Output: false Explanation: The ghost can reach the target at the same time as you. &nbsp; Constraints: 1 &lt;= ghosts.length &lt;= 100 ghosts[i].length == 2 -104 &lt;= xi, yi &lt;= 104 There can be multiple ghosts in the same location. target.length == 2 -104 &lt;= xtarget, ytarget &lt;= 104"
    },
    {
      "number": 790,
      "title": "Domino and Tromino Tiling",
      "titleSlug": "domino-and-tromino-tiling",
      "difficulty": "Medium",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes. Given an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7. In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile. &nbsp; Example 1: Input: n = 3 Output: 5 Explanation: The five different ways are show above. Example 2: Input: n = 1 Output: 1 &nbsp; Constraints: 1 &lt;= n &lt;= 1000"
    },
    {
      "number": 791,
      "title": "Custom Sort String",
      "titleSlug": "custom-sort-string",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Sorting"
      ],
      "description": "You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously. Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string. Return any permutation of s that satisfies this property. &nbsp; Example 1: Input: order = &quot;cba&quot;, s = &quot;abcd&quot; Output: &quot;cbad&quot; Explanation: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; appear in order, so the order of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; should be &quot;c&quot;, &quot;b&quot;, and &quot;a&quot;. Since &quot;d&quot; does not appear in order, it can be at any position in the returned string. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; are also valid outputs. Example 2: Input: order = &quot;bcafg&quot;, s = &quot;abcd&quot; Output: &quot;bcad&quot; Explanation: The characters &quot;b&quot;, &quot;c&quot;, and &quot;a&quot; from order dictate the order for the characters in s. The character &quot;d&quot; in s does not appear in order, so its position is flexible. Following the order of appearance in order, &quot;b&quot;, &quot;c&quot;, and &quot;a&quot; from s should be arranged as &quot;b&quot;, &quot;c&quot;, &quot;a&quot;. &quot;d&quot; can be placed at any position since it&#39;s not in order. The output &quot;bcad&quot; correctly follows this rule. Other arrangements like &quot;dbca&quot; or &quot;bcda&quot; would also be valid, as long as &quot;b&quot;, &quot;c&quot;, &quot;a&quot; maintain their order. &nbsp; Constraints: 1 &lt;= order.length &lt;= 26 1 &lt;= s.length &lt;= 200 order and s consist of lowercase English letters. All the characters of order are unique."
    },
    {
      "number": 792,
      "title": "Number of Matching Subsequences",
      "titleSlug": "number-of-matching-subsequences",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Binary Search",
        "Dynamic Programming",
        "Trie",
        "Sorting"
      ],
      "description": "Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, &quot;ace&quot; is a subsequence of &quot;abcde&quot;. &nbsp; Example 1: Input: s = &quot;abcde&quot;, words = [&quot;a&quot;,&quot;bb&quot;,&quot;acd&quot;,&quot;ace&quot;] Output: 3 Explanation: There are three strings in words that are a subsequence of s: &quot;a&quot;, &quot;acd&quot;, &quot;ace&quot;. Example 2: Input: s = &quot;dsahjpjauf&quot;, words = [&quot;ahjpjau&quot;,&quot;ja&quot;,&quot;ahbwzgqnuk&quot;,&quot;tnmlanowax&quot;] Output: 2 &nbsp; Constraints: 1 &lt;= s.length &lt;= 5 * 104 1 &lt;= words.length &lt;= 5000 1 &lt;= words[i].length &lt;= 50 s and words[i] consist of only lowercase English letters."
    },
    {
      "number": 793,
      "title": "Preimage Size of Factorial Zeroes Function",
      "titleSlug": "preimage-size-of-factorial-zeroes-function",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "Binary Search"
      ],
      "description": "Let f(x) be the number of zeroes at the end of x!. Recall that x! = 1 * 2 * 3 * ... * x and by convention, 0! = 1. For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has two zeroes at the end. Given an integer k, return the number of non-negative integers x have the property that f(x) = k. &nbsp; Example 1: Input: k = 0 Output: 5 Explanation: 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes. Example 2: Input: k = 5 Output: 0 Explanation: There is no x such that x! ends in k = 5 zeroes. Example 3: Input: k = 3 Output: 5 &nbsp; Constraints: 0 &lt;= k &lt;= 109"
    },
    {
      "number": 794,
      "title": "Valid Tic-Tac-Toe State",
      "titleSlug": "valid-tic-tac-toe-state",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Matrix"
      ],
      "description": "Given a Tic-Tac-Toe board as a string array board, return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game. The board is a 3 x 3 array that consists of characters &#39; &#39;, &#39;X&#39;, and &#39;O&#39;. The &#39; &#39; character represents an empty square. Here are the rules of Tic-Tac-Toe: Players take turns placing characters into empty squares &#39; &#39;. The first player always places &#39;X&#39; characters, while the second player always places &#39;O&#39; characters. &#39;X&#39; and &#39;O&#39; characters are always placed into empty squares, never filled ones. The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over. &nbsp; Example 1: Input: board = [&quot;O &quot;,&quot; &quot;,&quot; &quot;] Output: false Explanation: The first player always plays &quot;X&quot;. Example 2: Input: board = [&quot;XOX&quot;,&quot; X &quot;,&quot; &quot;] Output: false Explanation: Players take turns making moves. Example 3: Input: board = [&quot;XOX&quot;,&quot;O O&quot;,&quot;XOX&quot;] Output: true &nbsp; Constraints: board.length == 3 board[i].length == 3 board[i][j] is either &#39;X&#39;, &#39;O&#39;, or &#39; &#39;."
    },
    {
      "number": 795,
      "title": "Number of Subarrays with Bounded Maximum",
      "titleSlug": "number-of-subarrays-with-bounded-maximum",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers"
      ],
      "description": "Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays such that the value of the maximum array element in that subarray is in the range [left, right]. The test cases are generated so that the answer will fit in a 32-bit integer. &nbsp; Example 1: Input: nums = [2,1,4,3], left = 2, right = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3]. Example 2: Input: nums = [2,9,2,5,6], left = 2, right = 8 Output: 7 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 109 0 &lt;= left &lt;= right &lt;= 109"
    },
    {
      "number": 796,
      "title": "Rotate String",
      "titleSlug": "rotate-string",
      "difficulty": "Easy",
      "tags": [
        "String",
        "String Matching"
      ],
      "description": "Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s. A shift on s consists of moving the leftmost character of s to the rightmost position. For example, if s = &quot;abcde&quot;, then it will be &quot;bcdea&quot; after one shift. &nbsp; Example 1: Input: s = \"abcde\", goal = \"cdeab\" Output: true Example 2: Input: s = \"abcde\", goal = \"abced\" Output: false &nbsp; Constraints: 1 &lt;= s.length, goal.length &lt;= 100 s and goal consist of lowercase English letters."
    },
    {
      "number": 797,
      "title": "All Paths From Source to Target",
      "titleSlug": "all-paths-from-source-to-target",
      "difficulty": "Medium",
      "tags": [
        "Backtracking",
        "Depth-First Search",
        "Breadth-First Search",
        "Graph"
      ],
      "description": "Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order. The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]). &nbsp; Example 1: Input: graph = [[1,2],[3],[3],[]] Output: [[0,1,3],[0,2,3]] Explanation: There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3. Example 2: Input: graph = [[4,3,1],[3,2,4],[3],[4],[]] Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]] &nbsp; Constraints: n == graph.length 2 &lt;= n &lt;= 15 0 &lt;= graph[i][j] &lt; n graph[i][j] != i (i.e., there will be no self-loops). All the elements of graph[i] are unique. The input graph is guaranteed to be a DAG."
    },
    {
      "number": 798,
      "title": "Smallest Rotation with Highest Score",
      "titleSlug": "smallest-rotation-with-highest-score",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Prefix Sum"
      ],
      "description": "You are given an array nums. You can rotate it by a non-negative integer k so that the array becomes [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]. Afterward, any entries that are less than or equal to their index are worth one point. For example, if we have nums = [2,4,1,3,0], and we rotate by k = 2, it becomes [1,3,0,2,4]. This is worth 3 points because 1 &gt; 0 [no points], 3 &gt; 1 [no points], 0 &lt;= 2 [one point], 2 &lt;= 3 [one point], 4 &lt;= 4 [one point]. Return the rotation index k that corresponds to the highest score we can achieve if we rotated nums by it. If there are multiple answers, return the smallest such index k. &nbsp; Example 1: Input: nums = [2,3,1,4,0] Output: 3 Explanation: Scores for each k are listed below: k = 0, nums = [2,3,1,4,0], score 2 k = 1, nums = [3,1,4,0,2], score 3 k = 2, nums = [1,4,0,2,3], score 3 k = 3, nums = [4,0,2,3,1], score 4 k = 4, nums = [0,2,3,1,4], score 3 So we should choose k = 3, which has the highest score. Example 2: Input: nums = [1,3,0,2,4] Output: 0 Explanation: nums will always have 3 points no matter how it shifts. So we will choose the smallest k, which is 0. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt; nums.length"
    },
    {
      "number": 799,
      "title": "Champagne Tower",
      "titleSlug": "champagne-tower",
      "difficulty": "Medium",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.&nbsp; Each glass holds one cup&nbsp;of champagne. Then, some champagne is poured into the first glass at the top.&nbsp; When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.&nbsp; When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.&nbsp; (A glass at the bottom row has its excess champagne fall on the floor.) For example, after one cup of champagne is poured, the top most glass is full.&nbsp; After two cups of champagne are poured, the two glasses on the second row are half full.&nbsp; After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.&nbsp; After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below. Now after pouring some non-negative integer cups of champagne, return how full the jth glass in the ith row is (both i and j are 0-indexed.) &nbsp; Example 1: Input: poured = 1, query_row = 1, query_glass = 1 Output: 0.00000 Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty. Example 2: Input: poured = 2, query_row = 1, query_glass = 1 Output: 0.50000 Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange. Example 3: Input: poured = 100000009, query_row = 33, query_glass = 17 Output: 1.00000 &nbsp; Constraints: 0 &lt;=&nbsp;poured &lt;= 109 0 &lt;= query_glass &lt;= query_row&nbsp;&lt; 100"
    },
    {
      "number": 801,
      "title": "Minimum Swaps To Make Sequences Increasing",
      "titleSlug": "minimum-swaps-to-make-sequences-increasing",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "You are given two integer arrays of the same length nums1 and nums2. In one operation, you are allowed to swap nums1[i] with nums2[i]. For example, if nums1 = [1,2,3,8], and nums2 = [5,6,7,4], you can swap the element at i = 3 to obtain nums1 = [1,2,3,4] and nums2 = [5,6,7,8]. Return the minimum number of needed operations to make nums1 and nums2 strictly increasing. The test cases are generated so that the given input always makes it possible. An array arr is strictly increasing if and only if arr[0] &lt; arr[1] &lt; arr[2] &lt; ... &lt; arr[arr.length - 1]. &nbsp; Example 1: Input: nums1 = [1,3,5,4], nums2 = [1,2,3,7] Output: 1 Explanation: Swap nums1[3] and nums2[3]. Then the sequences are: nums1 = [1, 3, 5, 7] and nums2 = [1, 2, 3, 4] which are both strictly increasing. Example 2: Input: nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9] Output: 1 &nbsp; Constraints: 2 &lt;= nums1.length &lt;= 105 nums2.length == nums1.length 0 &lt;= nums1[i], nums2[i] &lt;= 2 * 105"
    },
    {
      "number": 802,
      "title": "Find Eventual Safe States",
      "titleSlug": "find-eventual-safe-states",
      "difficulty": "Medium",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Graph",
        "Topological Sort"
      ],
      "description": "There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i]. A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node). Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order. &nbsp; Example 1: Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6] Explanation: The given graph is shown above. Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them. Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6. Example 2: Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]] Output: [4] Explanation: Only node 4 is a terminal node, and every path starting at node 4 leads to node 4. &nbsp; Constraints: n == graph.length 1 &lt;= n &lt;= 104 0 &lt;= graph[i].length &lt;= n 0 &lt;= graph[i][j] &lt;= n - 1 graph[i] is sorted in a strictly increasing order. The graph may contain self-loops. The number of edges in the graph will be in the range [1, 4 * 104]."
    },
    {
      "number": 803,
      "title": "Bricks Falling When Hit",
      "titleSlug": "bricks-falling-when-hit",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Union Find",
        "Matrix"
      ],
      "description": "You are given an m x n binary grid, where each 1 represents a brick and 0 represents an empty space. A brick is stable if: It is directly connected to the top of the grid, or At least one other brick in its four adjacent cells is stable. You are also given an array hits, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location hits[i] = (rowi, coli). The brick on that location&nbsp;(if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the grid (i.e., it does not land on other stable bricks). Return an array result, where each result[i] is the number of bricks that will fall after the ith erasure is applied. Note that an erasure may refer to a location with no brick, and if it does, no bricks drop. &nbsp; Example 1: Input: grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]] Output: [2] Explanation: Starting with the grid: [[1,0,0,0], [1,1,1,0]] We erase the underlined brick at (1,0), resulting in the grid: [[1,0,0,0], [0,1,1,0]] The two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is: [[1,0,0,0], [0,0,0,0]] Hence the result is [2]. Example 2: Input: grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]] Output: [0,0] Explanation: Starting with the grid: [[1,0,0,0], [1,1,0,0]] We erase the underlined brick at (1,1), resulting in the grid: [[1,0,0,0], [1,0,0,0]] All remaining bricks are still stable, so no bricks fall. The grid remains the same: [[1,0,0,0], [1,0,0,0]] Next, we erase the underlined brick at (1,0), resulting in the grid: [[1,0,0,0], [0,0,0,0]] Once again, all remaining bricks are still stable, so no bricks fall. Hence the result is [0,0]. &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 200 grid[i][j] is 0 or 1. 1 &lt;= hits.length &lt;= 4 * 104 hits[i].length == 2 0 &lt;= xi&nbsp;&lt;= m - 1 0 &lt;=&nbsp;yi &lt;= n - 1 All (xi, yi) are unique."
    },
    {
      "number": 804,
      "title": "Unique Morse Code Words",
      "titleSlug": "unique-morse-code-words",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: &#39;a&#39; maps to &quot;.-&quot;, &#39;b&#39; maps to &quot;-...&quot;, &#39;c&#39; maps to &quot;-.-.&quot;, and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;] Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter. For example, &quot;cab&quot; can be written as &quot;-.-..--...&quot;, which is the concatenation of &quot;-.-.&quot;, &quot;.-&quot;, and &quot;-...&quot;. We will call such a concatenation the transformation of a word. Return the number of different transformations among all words we have. &nbsp; Example 1: Input: words = [&quot;gin&quot;,&quot;zen&quot;,&quot;gig&quot;,&quot;msg&quot;] Output: 2 Explanation: The transformation of each word is: &quot;gin&quot; -&gt; &quot;--...-.&quot; &quot;zen&quot; -&gt; &quot;--...-.&quot; &quot;gig&quot; -&gt; &quot;--...--.&quot; &quot;msg&quot; -&gt; &quot;--...--.&quot; There are 2 different transformations: &quot;--...-.&quot; and &quot;--...--.&quot;. Example 2: Input: words = [&quot;a&quot;] Output: 1 &nbsp; Constraints: 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 12 words[i] consists of lowercase English letters."
    },
    {
      "number": 805,
      "title": "Split Array With Same Average",
      "titleSlug": "split-array-with-same-average",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Dynamic Programming",
        "Bit Manipulation",
        "Bitmask"
      ],
      "description": "You are given an integer array nums. You should move each element of nums into one of the two arrays A and B such that A and B are non-empty, and average(A) == average(B). Return true if it is possible to achieve that and false otherwise. Note that for an array arr, average(arr) is the sum of all the elements of arr over the length of arr. &nbsp; Example 1: Input: nums = [1,2,3,4,5,6,7,8] Output: true Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have an average of 4.5. Example 2: Input: nums = [3,1] Output: false &nbsp; Constraints: 1 &lt;= nums.length &lt;= 30 0 &lt;= nums[i] &lt;= 104"
    },
    {
      "number": 806,
      "title": "Number of Lines To Write String",
      "titleSlug": "number-of-lines-to-write-string",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "String"
      ],
      "description": "You are given a string s of lowercase English letters and an array widths denoting how many pixels wide each lowercase English letter is. Specifically, widths[0] is the width of &#39;a&#39;, widths[1] is the width of &#39;b&#39;, and so on. You are trying to write s across several lines, where each line is no longer than 100 pixels. Starting at the beginning of s, write as many letters on the first line such that the total width does not exceed 100 pixels. Then, from where you stopped in s, continue writing as many letters as you can on the second line. Continue this process until you have written all of s. Return an array result of length 2 where: result[0] is the total number of lines. result[1] is the width of the last line in pixels. &nbsp; Example 1: Input: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = &quot;abcdefghijklmnopqrstuvwxyz&quot; Output: [3,60] Explanation: You can write s as follows: abcdefghij // 100 pixels wide klmnopqrst // 100 pixels wide uvwxyz // 60 pixels wide There are a total of 3 lines, and the last line is 60 pixels wide. Example 2: Input: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = &quot;bbbcccdddaaa&quot; Output: [2,4] Explanation: You can write s as follows: bbbcccdddaa // 98 pixels wide a // 4 pixels wide There are a total of 2 lines, and the last line is 4 pixels wide. &nbsp; Constraints: widths.length == 26 2 &lt;= widths[i] &lt;= 10 1 &lt;= s.length &lt;= 1000 s contains only lowercase English letters."
    },
    {
      "number": 807,
      "title": "Max Increase to Keep City Skyline",
      "titleSlug": "max-increase-to-keep-city-skyline",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Greedy",
        "Matrix"
      ],
      "description": "There is a city composed of n x n blocks, where each block contains a single building shaped like a vertical square prism. You are given a 0-indexed n x n integer matrix grid where grid[r][c] represents the height of the building located in the block at row r and column c. A city&#39;s skyline is the&nbsp;outer contour formed by all the building when viewing the side of the city from a distance. The skyline from each cardinal direction north, east, south, and west may be different. We are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). The height of a 0-height building can also be increased. However, increasing the height of a building should not affect the city&#39;s skyline from any cardinal direction. Return the maximum total sum that the height of the buildings can be increased by without changing the city&#39;s skyline from any cardinal direction. &nbsp; Example 1: Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]] Output: 35 Explanation: The building heights are shown in the center of the above image. The skylines when viewed from each cardinal direction are drawn in red. The grid after increasing the height of buildings without affecting skylines is: gridNew = [ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ] Example 2: Input: grid = [[0,0,0],[0,0,0],[0,0,0]] Output: 0 Explanation: Increasing the height of any building will result in the skyline changing. &nbsp; Constraints: n == grid.length n == grid[r].length 2 &lt;= n &lt;= 50 0 &lt;= grid[r][c] &lt;= 100"
    },
    {
      "number": 808,
      "title": "Soup Servings",
      "titleSlug": "soup-servings",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Dynamic Programming",
        "Probability and Statistics"
      ],
      "description": "There are two types of soup: type A and type B. Initially, we have n ml of each type of soup. There are four kinds of operations: Serve 100 ml of soup A and 0 ml of soup B, Serve 75 ml of soup A and 25 ml of soup B, Serve 50 ml of soup A and 50 ml of soup B, and Serve 25 ml of soup A and 75 ml of soup B. When we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup. Note that we do not have an operation where all 100 ml&#39;s of soup B are used first. Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time. Answers within 10-5 of the actual answer will be accepted. &nbsp; Example 1: Input: n = 50 Output: 0.62500 Explanation: If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625. Example 2: Input: n = 100 Output: 0.71875 &nbsp; Constraints: 0 &lt;= n &lt;= 109"
    },
    {
      "number": 809,
      "title": "Expressive Words",
      "titleSlug": "expressive-words",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "String"
      ],
      "description": "Sometimes people repeat letters to represent extra feeling. For example: &quot;hello&quot; -&gt; &quot;heeellooo&quot; &quot;hi&quot; -&gt; &quot;hiiii&quot; In these strings like &quot;heeellooo&quot;, we have groups of adjacent letters that are all the same: &quot;h&quot;, &quot;eee&quot;, &quot;ll&quot;, &quot;ooo&quot;. You are given a string s and an array of query strings words. A query word is stretchy if it can be made to be equal to s by any number of applications of the following extension operation: choose a group consisting of characters c, and add some number of characters c to the group so that the size of the group is three or more. For example, starting with &quot;hello&quot;, we could do an extension on the group &quot;o&quot; to get &quot;hellooo&quot;, but we cannot get &quot;helloo&quot; since the group &quot;oo&quot; has a size less than three. Also, we could do another extension like &quot;ll&quot; -&gt; &quot;lllll&quot; to get &quot;helllllooo&quot;. If s = &quot;helllllooo&quot;, then the query word &quot;hello&quot; would be stretchy because of these two extension operations: query = &quot;hello&quot; -&gt; &quot;hellooo&quot; -&gt; &quot;helllllooo&quot; = s. Return the number of query strings that are stretchy. &nbsp; Example 1: Input: s = &quot;heeellooo&quot;, words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;] Output: 1 Explanation: We can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;. We can&#39;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not size 3 or more. Example 2: Input: s = &quot;zzzzzyyyyy&quot;, words = [&quot;zzyy&quot;,&quot;zy&quot;,&quot;zyy&quot;] Output: 3 &nbsp; Constraints: 1 &lt;= s.length, words.length &lt;= 100 1 &lt;= words[i].length &lt;= 100 s and words[i] consist of lowercase letters."
    },
    {
      "number": 810,
      "title": "Chalkboard XOR Game",
      "titleSlug": "chalkboard-xor-game",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Bit Manipulation",
        "Brainteaser",
        "Game Theory"
      ],
      "description": "You are given an array of integers nums represents the numbers written on a chalkboard. Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses. The bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0. Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins. Return true if and only if Alice wins the game, assuming both players play optimally. &nbsp; Example 1: Input: nums = [1,1,2] Output: false Explanation: Alice has two choices: erase 1 or erase 2. If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. If Alice erases 2 first, now nums become [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose. Example 2: Input: nums = [0,1] Output: true Example 3: Input: nums = [1,2,3] Output: true &nbsp; Constraints: 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt; 216"
    },
    {
      "number": 811,
      "title": "Subdomain Visit Count",
      "titleSlug": "subdomain-visit-count",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Counting"
      ],
      "description": "A website domain &quot;discuss.leetcode.com&quot; consists of various subdomains. At the top level, we have &quot;com&quot;, at the next level, we have &quot;leetcode.com&quot;&nbsp;and at the lowest level, &quot;discuss.leetcode.com&quot;. When we visit a domain like &quot;discuss.leetcode.com&quot;, we will also visit the parent domains &quot;leetcode.com&quot; and &quot;com&quot; implicitly. A count-paired domain is a domain that has one of the two formats &quot;rep d1.d2.d3&quot; or &quot;rep d1.d2&quot; where rep is the number of visits to the domain and d1.d2.d3 is the domain itself. For example, &quot;9001 discuss.leetcode.com&quot; is a count-paired domain that indicates that discuss.leetcode.com was visited 9001 times. Given an array of count-paired domains cpdomains, return an array of the count-paired domains of each subdomain in the input. You may return the answer in any order. &nbsp; Example 1: Input: cpdomains = [&quot;9001 discuss.leetcode.com&quot;] Output: [&quot;9001 leetcode.com&quot;,&quot;9001 discuss.leetcode.com&quot;,&quot;9001 com&quot;] Explanation: We only have one website domain: &quot;discuss.leetcode.com&quot;. As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times. Example 2: Input: cpdomains = [&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;] Output: [&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;] Explanation: We will visit &quot;google.mail.com&quot; 900 times, &quot;yahoo.com&quot; 50 times, &quot;intel.mail.com&quot; once and &quot;wiki.org&quot; 5 times. For the subdomains, we will visit &quot;mail.com&quot; 900 + 1 = 901 times, &quot;com&quot; 900 + 50 + 1 = 951 times, and &quot;org&quot; 5 times. &nbsp; Constraints: 1 &lt;= cpdomain.length &lt;= 100 1 &lt;= cpdomain[i].length &lt;= 100 cpdomain[i] follows either the &quot;repi d1i.d2i.d3i&quot; format or the &quot;repi d1i.d2i&quot; format. repi is an integer in the range [1, 104]. d1i, d2i, and d3i consist of lowercase English letters."
    },
    {
      "number": 812,
      "title": "Largest Triangle Area",
      "titleSlug": "largest-triangle-area",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math",
        "Geometry"
      ],
      "description": "Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points. Answers within 10-5 of the actual answer will be accepted. &nbsp; Example 1: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2.00000 Explanation: The five points are shown in the above figure. The red triangle is the largest. Example 2: Input: points = [[1,0],[0,0],[0,1]] Output: 0.50000 &nbsp; Constraints: 3 &lt;= points.length &lt;= 50 -50 &lt;= xi, yi &lt;= 50 All the given points are unique."
    },
    {
      "number": 813,
      "title": "Largest Sum of Averages",
      "titleSlug": "largest-sum-of-averages",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Prefix Sum"
      ],
      "description": "You are given an integer array nums and an integer k. You can partition the array into at most k non-empty adjacent subarrays. The score of a partition is the sum of the averages of each subarray. Note that the partition must use every integer in nums, and that the score is not necessarily an integer. Return the maximum score you can achieve of all the possible partitions. Answers within 10-6 of the actual answer will be accepted. &nbsp; Example 1: Input: nums = [9,1,2,3,9], k = 3 Output: 20.00000 Explanation: The best choice is to partition nums into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20. We could have also partitioned nums into [9, 1], [2], [3, 9], for example. That partition would lead to a score of 5 + 2 + 6 = 13, which is worse. Example 2: Input: nums = [1,2,3,4,5,6,7], k = 4 Output: 20.50000 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 104 1 &lt;= k &lt;= nums.length"
    },
    {
      "number": 814,
      "title": "Binary Tree Pruning",
      "titleSlug": "binary-tree-pruning",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed. A subtree of a node node is node plus every node that is a descendant of node. &nbsp; Example 1: Input: root = [1,null,0,0,1] Output: [1,null,0,null,1] Explanation: Only the red nodes satisfy the property &quot;every subtree not containing a 1&quot;. The diagram on the right represents the answer. Example 2: Input: root = [1,0,1,0,0,0,1] Output: [1,null,1,null,1] Example 3: Input: root = [1,1,0,1,1,0,1,0] Output: [1,1,0,1,1,null,1] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 200]. Node.val is either 0 or 1."
    },
    {
      "number": 815,
      "title": "Bus Routes",
      "titleSlug": "bus-routes",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Breadth-First Search"
      ],
      "description": "You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever. For example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; ... forever. You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only. Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible. &nbsp; Example 1: Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6 Output: 2 Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6. Example 2: Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12 Output: -1 &nbsp; &nbsp; Constraints: 1 &lt;= routes.length &lt;= 500. 1 &lt;= routes[i].length &lt;= 105 All the values of routes[i] are unique. sum(routes[i].length) &lt;= 105 0 &lt;= routes[i][j] &lt; 106 0 &lt;= source, target &lt; 106"
    },
    {
      "number": 816,
      "title": "Ambiguous Coordinates",
      "titleSlug": "ambiguous-coordinates",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Backtracking",
        "Enumeration"
      ],
      "description": "We had some 2-dimensional coordinates, like &quot;(1, 3)&quot; or &quot;(2, 0.5)&quot;. Then, we removed all commas, decimal points, and spaces and ended up with the string s. For example, &quot;(1, 3)&quot; becomes s = &quot;(13)&quot; and &quot;(2, 0.5)&quot; becomes s = &quot;(205)&quot;. Return a list of strings representing all possibilities for what our original coordinates could have been. Our original representation never had extraneous zeroes, so we never started with numbers like &quot;00&quot;, &quot;0.0&quot;, &quot;0.00&quot;, &quot;1.0&quot;, &quot;001&quot;, &quot;00.01&quot;, or any other number that can be represented with fewer digits. Also, a decimal point within a number never occurs without at least one digit occurring before it, so we never started with numbers like &quot;.1&quot;. The final answer list can be returned in any order. All coordinates in the final answer have exactly one space between them (occurring after the comma.) &nbsp; Example 1: Input: s = &quot;(123)&quot; Output: [&quot;(1, 2.3)&quot;,&quot;(1, 23)&quot;,&quot;(1.2, 3)&quot;,&quot;(12, 3)&quot;] Example 2: Input: s = &quot;(0123)&quot; Output: [&quot;(0, 1.23)&quot;,&quot;(0, 12.3)&quot;,&quot;(0, 123)&quot;,&quot;(0.1, 2.3)&quot;,&quot;(0.1, 23)&quot;,&quot;(0.12, 3)&quot;] Explanation: 0.0, 00, 0001 or 00.01 are not allowed. Example 3: Input: s = &quot;(00011)&quot; Output: [&quot;(0, 0.011)&quot;,&quot;(0.001, 1)&quot;] &nbsp; Constraints: 4 &lt;= s.length &lt;= 12 s[0] == &#39;(&#39; and s[s.length - 1] == &#39;)&#39;. The rest of s are digits."
    },
    {
      "number": 817,
      "title": "Linked List Components",
      "titleSlug": "linked-list-components",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Linked List"
      ],
      "description": "You are given the head of a linked list containing unique integer values and an integer array nums that is a subset of the linked list values. Return the number of connected components in nums where two values are connected if they appear consecutively in the linked list. &nbsp; Example 1: Input: head = [0,1,2,3], nums = [0,1,3] Output: 2 Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components. Example 2: Input: head = [0,1,2,3,4], nums = [0,3,1,4] Output: 2 Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. &nbsp; Constraints: The number of nodes in the linked list is n. 1 &lt;= n &lt;= 104 0 &lt;= Node.val &lt; n All the values Node.val are unique. 1 &lt;= nums.length &lt;= n 0 &lt;= nums[i] &lt; n All the values of nums are unique."
    },
    {
      "number": 818,
      "title": "Race Car",
      "titleSlug": "race-car",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "Your car starts at position 0 and speed +1 on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions &#39;A&#39; (accelerate) and &#39;R&#39; (reverse): When you get an instruction &#39;A&#39;, your car does the following: position += speed speed *= 2 When you get an instruction &#39;R&#39;, your car does the following: If your speed is positive then speed = -1 otherwise speed = 1 Your position stays the same. For example, after commands &quot;AAR&quot;, your car goes to positions 0 --&gt; 1 --&gt; 3 --&gt; 3, and your speed goes to 1 --&gt; 2 --&gt; 4 --&gt; -1. Given a target position target, return the length of the shortest sequence of instructions to get there. &nbsp; Example 1: Input: target = 3 Output: 2 Explanation: The shortest instruction sequence is &quot;AA&quot;. Your position goes from 0 --&gt; 1 --&gt; 3. Example 2: Input: target = 6 Output: 5 Explanation: The shortest instruction sequence is &quot;AAARA&quot;. Your position goes from 0 --&gt; 1 --&gt; 3 --&gt; 7 --&gt; 7 --&gt; 6. &nbsp; Constraints: 1 &lt;= target &lt;= 104"
    },
    {
      "number": 819,
      "title": "Most Common Word",
      "titleSlug": "most-common-word",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Counting"
      ],
      "description": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique. The words in paragraph are case-insensitive and the answer should be returned in lowercase. Note that words can not contain punctuation symbols. &nbsp; Example 1: Input: paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;, banned = [&quot;hit&quot;] Output: &quot;ball&quot; Explanation: &quot;hit&quot; occurs 3 times, but it is a banned word. &quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;), and that &quot;hit&quot; isn&#39;t the answer even though it occurs more because it is banned. Example 2: Input: paragraph = &quot;a.&quot;, banned = [] Output: &quot;a&quot; &nbsp; Constraints: 1 &lt;= paragraph.length &lt;= 1000 paragraph consists of English letters, space &#39; &#39;, or one of the symbols: &quot;!?&#39;,;.&quot;. 0 &lt;= banned.length &lt;= 100 1 &lt;= banned[i].length &lt;= 10 banned[i] consists of only lowercase English letters."
    },
    {
      "number": 820,
      "title": "Short Encoding of Words",
      "titleSlug": "short-encoding-of-words",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Trie"
      ],
      "description": "A valid encoding of an array of words is any reference string s and array of indices indices such that: words.length == indices.length The reference string s ends with the &#39;#&#39; character. For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next &#39;#&#39; character is equal to words[i]. Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words. &nbsp; Example 1: Input: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;] Output: 10 Explanation: A valid encoding would be s = &quot;time#bell#&quot; and indices = [0, 2, 5]. words[0] = &quot;time&quot;, the substring of s starting from indices[0] = 0 to the next &#39;#&#39; is underlined in &quot;time#bell#&quot; words[1] = &quot;me&quot;, the substring of s starting from indices[1] = 2 to the next &#39;#&#39; is underlined in &quot;time#bell#&quot; words[2] = &quot;bell&quot;, the substring of s starting from indices[2] = 5 to the next &#39;#&#39; is underlined in &quot;time#bell#&quot; Example 2: Input: words = [&quot;t&quot;] Output: 2 Explanation: A valid encoding would be s = &quot;t#&quot; and indices = [0]. &nbsp; Constraints: 1 &lt;= words.length &lt;= 2000 1 &lt;= words[i].length &lt;= 7 words[i] consists of only lowercase letters."
    },
    {
      "number": 821,
      "title": "Shortest Distance to a Character",
      "titleSlug": "shortest-distance-to-a-character",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Two Pointers",
        "String"
      ],
      "description": "Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s. The distance between two indices i and j is abs(i - j), where abs is the absolute value function. &nbsp; Example 1: Input: s = &quot;loveleetcode&quot;, c = &quot;e&quot; Output: [3,2,1,0,1,0,0,1,2,2,1,0] Explanation: The character &#39;e&#39; appears at indices 3, 5, 6, and 11 (0-indexed). The closest occurrence of &#39;e&#39; for index 0 is at index 3, so the distance is abs(0 - 3) = 3. The closest occurrence of &#39;e&#39; for index 1 is at index 3, so the distance is abs(1 - 3) = 2. For index 4, there is a tie between the &#39;e&#39; at index 3 and the &#39;e&#39; at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1. The closest occurrence of &#39;e&#39; for index 8 is at index 6, so the distance is abs(8 - 6) = 2. Example 2: Input: s = &quot;aaab&quot;, c = &quot;b&quot; Output: [3,2,1,0] &nbsp; Constraints: 1 &lt;= s.length &lt;= 104 s[i] and c are lowercase English letters. It is guaranteed that c occurs at least once in s."
    },
    {
      "number": 822,
      "title": "Card Flipping Game",
      "titleSlug": "card-flipping-game",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table"
      ],
      "description": "You are given two 0-indexed integer arrays fronts and backs of length n, where the ith card has the positive integer fronts[i] printed on the front and backs[i] printed on the back. Initially, each card is placed on a table such that the front number is facing up and the other is facing down. You may flip over any number of cards (possibly zero). After flipping the cards, an integer is considered good if it is facing down on some card and not facing up on any card. Return the minimum possible good integer after flipping the cards. If there are no good integers, return 0. &nbsp; Example 1: Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3] Output: 2 Explanation: If we flip the second card, the face up numbers are [1,3,4,4,7] and the face down are [1,2,4,1,3]. 2 is the minimum good integer as it appears facing down but not facing up. It can be shown that 2 is the minimum possible good integer obtainable after flipping some cards. Example 2: Input: fronts = [1], backs = [1] Output: 0 Explanation: There are no good integers no matter how we flip the cards, so we return 0. &nbsp; Constraints: n == fronts.length == backs.length 1 &lt;= n &lt;= 1000 1 &lt;= fronts[i], backs[i] &lt;= 2000"
    },
    {
      "number": 823,
      "title": "Binary Trees With Factors",
      "titleSlug": "binary-trees-with-factors",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Dynamic Programming",
        "Sorting"
      ],
      "description": "Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1. We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node&#39;s value should be equal to the product of the values of its children. Return the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7. &nbsp; Example 1: Input: arr = [2,4] Output: 3 Explanation: We can make these trees: [2], [4], [4, 2, 2] Example 2: Input: arr = [2,4,5,10] Output: 7 Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 1000 2 &lt;= arr[i] &lt;= 109 All the values of arr are unique."
    },
    {
      "number": 824,
      "title": "Goat Latin",
      "titleSlug": "goat-latin",
      "difficulty": "Easy",
      "tags": [
        "String"
      ],
      "description": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to &quot;Goat Latin&quot; (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel (&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, or &#39;u&#39;), append &quot;ma&quot; to the end of the word. For example, the word &quot;apple&quot; becomes &quot;applema&quot;. If a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add &quot;ma&quot;. For example, the word &quot;goat&quot; becomes &quot;oatgma&quot;. Add one letter &#39;a&#39; to the end of each word per its word index in the sentence, starting with 1. For example, the first word gets &quot;a&quot; added to the end, the second word gets &quot;aa&quot; added to the end, and so on. Return the final sentence representing the conversion from sentence to Goat Latin. &nbsp; Example 1: Input: sentence = \"I speak Goat Latin\" Output: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\" Example 2: Input: sentence = \"The quick brown fox jumped over the lazy dog\" Output: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\" &nbsp; Constraints: 1 &lt;= sentence.length &lt;= 150 sentence consists of English letters and spaces. sentence has no leading or trailing spaces. All the words in sentence are separated by a single space."
    },
    {
      "number": 825,
      "title": "Friends Of Appropriate Ages",
      "titleSlug": "friends-of-appropriate-ages",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Binary Search",
        "Sorting"
      ],
      "description": "There are n persons on a social media website. You are given an integer array ages where ages[i] is the age of the ith person. A Person x will not send a friend request to a person y (x != y) if any of the following conditions is true: age[y] &lt;= 0.5 * age[x] + 7 age[y] &gt; age[x] age[y] &gt; 100 &amp;&amp; age[x] &lt; 100 Otherwise, x will send a friend request to y. Note that if x sends a request to y, y will not necessarily send a request to x. Also, a person will not send a friend request to themself. Return the total number of friend requests made. &nbsp; Example 1: Input: ages = [16,16] Output: 2 Explanation: 2 people friend request each other. Example 2: Input: ages = [16,17,18] Output: 2 Explanation: Friend requests are made 17 -&gt; 16, 18 -&gt; 17. Example 3: Input: ages = [20,30,100,110,120] Output: 3 Explanation: Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100. &nbsp; Constraints: n == ages.length 1 &lt;= n &lt;= 2 * 104 1 &lt;= ages[i] &lt;= 120"
    },
    {
      "number": 826,
      "title": "Most Profit Assigning Work",
      "titleSlug": "most-profit-assigning-work",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Binary Search",
        "Greedy",
        "Sorting"
      ],
      "description": "You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where: difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]). Every worker can be assigned at most one job, but one job can be completed multiple times. For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0. Return the maximum profit we can achieve after assigning the workers to the jobs. &nbsp; Example 1: Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7] Output: 100 Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately. Example 2: Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25] Output: 0 &nbsp; Constraints: n == difficulty.length n == profit.length m == worker.length 1 &lt;= n, m &lt;= 104 1 &lt;= difficulty[i], profit[i], worker[i] &lt;= 105"
    },
    {
      "number": 827,
      "title": "Making A Large Island",
      "titleSlug": "making-a-large-island",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Matrix"
      ],
      "description": "You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1. Return the size of the largest island in grid after applying this operation. An island is a 4-directionally connected group of 1s. &nbsp; Example 1: Input: grid = [[1,0],[0,1]] Output: 3 Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3. Example 2: Input: grid = [[1,1],[1,0]] Output: 4 Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4. Example 3: Input: grid = [[1,1],[1,1]] Output: 4 Explanation: Can&#39;t change any 0 to 1, only one island with area = 4. &nbsp; Constraints: n == grid.length n == grid[i].length 1 &lt;= n &lt;= 500 grid[i][j] is either 0 or 1."
    },
    {
      "number": 828,
      "title": "Count Unique Characters of All Substrings of a Given String",
      "titleSlug": "count-unique-characters-of-all-substrings-of-a-given-string",
      "difficulty": "Hard",
      "tags": [
        "Hash Table",
        "String",
        "Dynamic Programming"
      ],
      "description": "Let&#39;s define a function countUniqueChars(s) that returns the number of unique characters in&nbsp;s. For example, calling countUniqueChars(s) if s = &quot;LEETCODE&quot; then &quot;L&quot;, &quot;T&quot;, &quot;C&quot;, &quot;O&quot;, &quot;D&quot; are the unique characters since they appear only once in s, therefore countUniqueChars(s) = 5. Given a string s, return the sum of countUniqueChars(t) where t is a substring of s. The test cases are generated such that the answer fits in a 32-bit integer. Notice that some substrings can be repeated so in this case you have to count the repeated ones too. &nbsp; Example 1: Input: s = &quot;ABC&quot; Output: 10 Explanation: All possible substrings are: &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; and &quot;ABC&quot;. Every substring is composed with only unique letters. Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10 Example 2: Input: s = &quot;ABA&quot; Output: 8 Explanation: The same as example 1, except countUniqueChars(&quot;ABA&quot;) = 1. Example 3: Input: s = &quot;LEETCODE&quot; Output: 92 &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s consists of uppercase English letters only."
    },
    {
      "number": 829,
      "title": "Consecutive Numbers Sum",
      "titleSlug": "consecutive-numbers-sum",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "Enumeration"
      ],
      "description": "Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers. &nbsp; Example 1: Input: n = 5 Output: 2 Explanation: 5 = 2 + 3 Example 2: Input: n = 9 Output: 3 Explanation: 9 = 4 + 5 = 2 + 3 + 4 Example 3: Input: n = 15 Output: 4 Explanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 &nbsp; Constraints: 1 &lt;= n &lt;= 109"
    },
    {
      "number": 830,
      "title": "Positions of Large Groups",
      "titleSlug": "positions-of-large-groups",
      "difficulty": "Easy",
      "tags": [
        "String"
      ],
      "description": "In a string s&nbsp;of lowercase letters, these letters form consecutive groups of the same character. For example, a string like s = &quot;abbxxxxzyy&quot; has the groups &quot;a&quot;, &quot;bb&quot;, &quot;xxxx&quot;, &quot;z&quot;, and&nbsp;&quot;yy&quot;. A group is identified by an interval&nbsp;[start, end], where&nbsp;start&nbsp;and&nbsp;end&nbsp;denote the start and end&nbsp;indices (inclusive) of the group. In the above example,&nbsp;&quot;xxxx&quot;&nbsp;has the interval&nbsp;[3,6]. A group is considered&nbsp;large&nbsp;if it has 3 or more characters. Return&nbsp;the intervals of every large group sorted in&nbsp;increasing order by start index. &nbsp; Example 1: Input: s = &quot;abbxxxxzzy&quot; Output: [[3,6]] Explanation: &quot;xxxx&quot; is the only large group with start index 3 and end index 6. Example 2: Input: s = &quot;abc&quot; Output: [] Explanation: We have groups &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;, none of which are large groups. Example 3: Input: s = &quot;abcdddeeeeaabbbcd&quot; Output: [[3,5],[6,9],[12,14]] Explanation: The large groups are &quot;ddd&quot;, &quot;eeee&quot;, and &quot;bbb&quot;. &nbsp; Constraints: 1 &lt;= s.length &lt;= 1000 s contains lowercase English letters only."
    },
    {
      "number": 831,
      "title": "Masking Personal Information",
      "titleSlug": "masking-personal-information",
      "difficulty": "Medium",
      "tags": [
        "String"
      ],
      "description": "You are given a personal information string s, representing either an email address or a phone number. Return the masked personal information using the below rules. Email address: An email address is: A name consisting of uppercase and lowercase English letters, followed by The &#39;@&#39; symbol, followed by The domain consisting of uppercase and lowercase English letters with a dot &#39;.&#39; somewhere in the middle (not the first or last character). To mask an email: The uppercase letters in the name and domain must be converted to lowercase letters. The middle letters of the name (i.e., all but the first and last letters) must be replaced by 5 asterisks &quot;*****&quot;. Phone number: A phone number is formatted as follows: The phone number contains 10-13 digits. The last 10 digits make up the local number. The remaining 0-3 digits, in the beginning, make up the country code. Separation characters from the set {&#39;+&#39;, &#39;-&#39;, &#39;(&#39;, &#39;)&#39;, &#39; &#39;} separate the above digits in some way. To mask a phone number: Remove all separation characters. The masked phone number should have the form: &quot;***-***-XXXX&quot; if the country code has 0 digits. &quot;+*-***-***-XXXX&quot; if the country code has 1 digit. &quot;+**-***-***-XXXX&quot; if the country code has 2 digits. &quot;+***-***-***-XXXX&quot; if the country code has 3 digits. &quot;XXXX&quot; is the last 4 digits of the local number. &nbsp; Example 1: Input: s = &quot;LeetCode@LeetCode.com&quot; Output: &quot;l*****e@leetcode.com&quot; Explanation: s is an email address. The name and domain are converted to lowercase, and the middle of the name is replaced by 5 asterisks. Example 2: Input: s = &quot;AB@qq.com&quot; Output: &quot;a*****b@qq.com&quot; Explanation: s is an email address. The name and domain are converted to lowercase, and the middle of the name is replaced by 5 asterisks. Note that even though &quot;ab&quot; is 2 characters, it still must have 5 asterisks in the middle. Example 3: Input: s = &quot;1(234)567-890&quot; Output: &quot;***-***-7890&quot; Explanation: s is a phone number. There are 10 digits, so the local number is 10 digits and the country code is 0 digits. Thus, the resulting masked number is &quot;***-***-7890&quot;. &nbsp; Constraints: s is either a valid email or a phone number. If s is an email: 8 &lt;= s.length &lt;= 40 s consists of uppercase and lowercase English letters and exactly one &#39;@&#39; symbol and &#39;.&#39; symbol. If s is a phone number: 10 &lt;= s.length &lt;= 20 s consists of digits, spaces, and the symbols &#39;(&#39;, &#39;)&#39;, &#39;-&#39;, and &#39;+&#39;."
    },
    {
      "number": 832,
      "title": "Flipping an Image",
      "titleSlug": "flipping-an-image",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Two Pointers",
        "Bit Manipulation",
        "Matrix",
        "Simulation"
      ],
      "description": "Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1,1,0] horizontally results in [0,1,1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0,1,1] results in [1,0,0]. &nbsp; Example 1: Input: image = [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2: Input: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] &nbsp; Constraints: n == image.length n == image[i].length 1 &lt;= n &lt;= 20 images[i][j] is either 0 or 1."
    },
    {
      "number": 833,
      "title": "Find And Replace in String",
      "titleSlug": "find-and-replace-in-string",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Sorting"
      ],
      "description": "You are given a 0-indexed string s that you must perform k replacement operations on. The replacement operations are given as three 0-indexed parallel arrays, indices, sources, and targets, all of length k. To complete the ith replacement operation: Check if the substring sources[i] occurs at index indices[i] in the original string s. If it does not occur, do nothing. Otherwise if it does occur, replace that substring with targets[i]. For example, if s = &quot;abcd&quot;, indices[i] = 0, sources[i] = &quot;ab&quot;, and targets[i] = &quot;eee&quot;, then the result of this replacement will be &quot;eeecd&quot;. All replacement operations must occur simultaneously, meaning the replacement operations should not affect the indexing of each other. The testcases will be generated such that the replacements will not overlap. For example, a testcase with s = &quot;abc&quot;, indices = [0, 1], and sources = [&quot;ab&quot;,&quot;bc&quot;] will not be generated because the &quot;ab&quot; and &quot;bc&quot; replacements overlap. Return the resulting string after performing all replacement operations on s. A substring is a contiguous sequence of characters in a string. &nbsp; Example 1: Input: s = &quot;abcd&quot;, indices = [0, 2], sources = [&quot;a&quot;, &quot;cd&quot;], targets = [&quot;eee&quot;, &quot;ffff&quot;] Output: &quot;eeebffff&quot; Explanation: &quot;a&quot; occurs at index 0 in s, so we replace it with &quot;eee&quot;. &quot;cd&quot; occurs at index 2 in s, so we replace it with &quot;ffff&quot;. Example 2: Input: s = &quot;abcd&quot;, indices = [0, 2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;] Output: &quot;eeecd&quot; Explanation: &quot;ab&quot; occurs at index 0 in s, so we replace it with &quot;eee&quot;. &quot;ec&quot; does not occur at index 2 in s, so we do nothing. &nbsp; Constraints: 1 &lt;= s.length &lt;= 1000 k == indices.length == sources.length == targets.length 1 &lt;= k &lt;= 100 0 &lt;= indexes[i] &lt; s.length 1 &lt;= sources[i].length, targets[i].length &lt;= 50 s consists of only lowercase English letters. sources[i] and targets[i] consist of only lowercase English letters."
    },
    {
      "number": 834,
      "title": "Sum of Distances in Tree",
      "titleSlug": "sum-of-distances-in-tree",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming",
        "Tree",
        "Depth-First Search",
        "Graph"
      ],
      "description": "There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges. You are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. Return an array answer of length n where answer[i] is the sum of the distances between the ith node in the tree and all other nodes. &nbsp; Example 1: Input: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] Output: [8,12,6,10,10,10] Explanation: The tree is shown above. We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) equals 1 + 1 + 2 + 2 + 2 = 8. Hence, answer[0] = 8, and so on. Example 2: Input: n = 1, edges = [] Output: [0] Example 3: Input: n = 2, edges = [[1,0]] Output: [1,1] &nbsp; Constraints: 1 &lt;= n &lt;= 3 * 104 edges.length == n - 1 edges[i].length == 2 0 &lt;= ai, bi &lt; n ai != bi The given input represents a valid tree."
    },
    {
      "number": 835,
      "title": "Image Overlap",
      "titleSlug": "image-overlap",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Matrix"
      ],
      "description": "You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values. We translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images. Note also that a translation does not include any kind of rotation. Any 1 bits that are translated outside of the matrix borders are erased. Return the largest possible overlap. &nbsp; Example 1: Input: img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]] Output: 3 Explanation: We translate img1 to right by 1 unit and down by 1 unit. The number of positions that have a 1 in both images is 3 (shown in red). Example 2: Input: img1 = [[1]], img2 = [[1]] Output: 1 Example 3: Input: img1 = [[0]], img2 = [[0]] Output: 0 &nbsp; Constraints: n == img1.length == img1[i].length n == img2.length == img2[i].length 1 &lt;= n &lt;= 30 img1[i][j] is either 0 or 1. img2[i][j] is either 0 or 1."
    },
    {
      "number": 836,
      "title": "Rectangle Overlap",
      "titleSlug": "rectangle-overlap",
      "difficulty": "Easy",
      "tags": [
        "Math",
        "Geometry"
      ],
      "description": "An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis. Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false. &nbsp; Example 1: Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true Example 2: Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false Example 3: Input: rec1 = [0,0,1,1], rec2 = [2,2,3,3] Output: false &nbsp; Constraints: rec1.length == 4 rec2.length == 4 -109 &lt;= rec1[i], rec2[i] &lt;= 109 rec1 and rec2 represent a valid rectangle with a non-zero area."
    },
    {
      "number": 837,
      "title": "New 21 Game",
      "titleSlug": "new-21-game",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Dynamic Programming",
        "Sliding Window",
        "Probability and Statistics"
      ],
      "description": "Alice plays the following game, loosely based on the card game &quot;21&quot;. Alice starts with 0 points and draws numbers while she has less than k points. During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets k or more points. Return the probability that Alice has n or fewer points. Answers within 10-5 of the actual answer are considered accepted. &nbsp; Example 1: Input: n = 10, k = 1, maxPts = 10 Output: 1.00000 Explanation: Alice gets a single card, then stops. Example 2: Input: n = 6, k = 1, maxPts = 10 Output: 0.60000 Explanation: Alice gets a single card, then stops. In 6 out of 10 possibilities, she is at or below 6 points. Example 3: Input: n = 21, k = 17, maxPts = 10 Output: 0.73278 &nbsp; Constraints: 0 &lt;= k &lt;= n &lt;= 104 1 &lt;= maxPts &lt;= 104"
    },
    {
      "number": 838,
      "title": "Push Dominoes",
      "titleSlug": "push-dominoes",
      "difficulty": "Medium",
      "tags": [
        "Two Pointers",
        "String",
        "Dynamic Programming"
      ],
      "description": "There are n dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right. After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. You are given a string dominoes representing the initial state where: dominoes[i] = &#39;L&#39;, if the ith domino has been pushed to the left, dominoes[i] = &#39;R&#39;, if the ith domino has been pushed to the right, and dominoes[i] = &#39;.&#39;, if the ith domino has not been pushed. Return a string representing the final state. &nbsp; Example 1: Input: dominoes = &quot;RR.L&quot; Output: &quot;RR.L&quot; Explanation: The first domino expends no additional force on the second domino. Example 2: Input: dominoes = &quot;.L.R...LR..L..&quot; Output: &quot;LL.RR.LLRRLL..&quot; &nbsp; Constraints: n == dominoes.length 1 &lt;= n &lt;= 105 dominoes[i] is either &#39;L&#39;, &#39;R&#39;, or &#39;.&#39;."
    },
    {
      "number": 839,
      "title": "Similar String Groups",
      "titleSlug": "similar-string-groups",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find"
      ],
      "description": "Two strings, X and Y, are considered similar if either they are identical or we can make them equivalent by swapping at most two letters (in distinct positions) within the string X. For example, &quot;tars&quot;&nbsp;and &quot;rats&quot;&nbsp;are similar (swapping at positions 0 and 2), and &quot;rats&quot; and &quot;arts&quot; are similar, but &quot;star&quot; is not similar to &quot;tars&quot;, &quot;rats&quot;, or &quot;arts&quot;. Together, these form two connected groups by similarity: {&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;} and {&quot;star&quot;}.&nbsp; Notice that &quot;tars&quot; and &quot;arts&quot; are in the same group even though they are not similar.&nbsp; Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there? &nbsp; Example 1: Input: strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;] Output: 2 Example 2: Input: strs = [&quot;omv&quot;,&quot;ovm&quot;] Output: 1 &nbsp; Constraints: 1 &lt;= strs.length &lt;= 300 1 &lt;= strs[i].length &lt;= 300 strs[i] consists of lowercase letters only. All words in strs have the same length and are anagrams of each other."
    },
    {
      "number": 840,
      "title": "Magic Squares In Grid",
      "titleSlug": "magic-squares-in-grid",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Math",
        "Matrix"
      ],
      "description": "A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum. Given a row x col grid of integers, how many 3 x 3 magic square subgrids are there? Note: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15. &nbsp; Example 1: Input: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]] Output: 1 Explanation: The following subgrid is a 3 x 3 magic square: while this one is not: In total, there is only one magic square inside the given grid. Example 2: Input: grid = [[8]] Output: 0 &nbsp; Constraints: row == grid.length col == grid[i].length 1 &lt;= row, col &lt;= 10 0 &lt;= grid[i][j] &lt;= 15"
    },
    {
      "number": 841,
      "title": "Keys and Rooms",
      "titleSlug": "keys-and-rooms",
      "difficulty": "Medium",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Graph"
      ],
      "description": "There are n rooms labeled from 0 to n - 1&nbsp;and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key. When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms. Given an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise. &nbsp; Example 1: Input: rooms = [[1],[2],[3],[]] Output: true Explanation: We visit room 0 and pick up key 1. We then visit room 1 and pick up key 2. We then visit room 2 and pick up key 3. We then visit room 3. Since we were able to visit every room, we return true. Example 2: Input: rooms = [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can not enter room number 2 since the only key that unlocks it is in that room. &nbsp; Constraints: n == rooms.length 2 &lt;= n &lt;= 1000 0 &lt;= rooms[i].length &lt;= 1000 1 &lt;= sum(rooms[i].length) &lt;= 3000 0 &lt;= rooms[i][j] &lt; n All the values of rooms[i] are unique."
    },
    {
      "number": 842,
      "title": "Split Array into Fibonacci Sequence",
      "titleSlug": "split-array-into-fibonacci-sequence",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Backtracking"
      ],
      "description": "You are given a string of digits num, such as &quot;123456579&quot;. We can split it into a Fibonacci-like sequence [123, 456, 579]. Formally, a Fibonacci-like sequence is a list f of non-negative integers such that: 0 &lt;= f[i] &lt; 231, (that is, each integer fits in a 32-bit signed integer type), f.length &gt;= 3, and f[i] + f[i + 1] == f[i + 2] for all 0 &lt;= i &lt; f.length - 2. Note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself. Return any Fibonacci-like sequence split from num, or return [] if it cannot be done. &nbsp; Example 1: Input: num = &quot;1101111&quot; Output: [11,0,11,11] Explanation: The output [110, 1, 111] would also be accepted. Example 2: Input: num = &quot;112358130&quot; Output: [] Explanation: The task is impossible. Example 3: Input: num = &quot;0123&quot; Output: [] Explanation: Leading zeroes are not allowed, so &quot;01&quot;, &quot;2&quot;, &quot;3&quot; is not valid. &nbsp; Constraints: 1 &lt;= num.length &lt;= 200 num contains only digits."
    },
    {
      "number": 843,
      "title": "Guess the Word",
      "titleSlug": "guess-the-word",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "String",
        "Interactive",
        "Game Theory"
      ],
      "description": "You are given an array of unique strings words where words[i] is six letters long. One word of words was chosen as a secret word. You are also given the helper object Master. You may call Master.guess(word) where word is a six-letter-long string, and it must be from words. Master.guess(word) returns: -1 if word is not from words, or an integer representing the number of exact matches (value and position) of your guess to the secret word. There is a parameter allowedGuesses for each test case where allowedGuesses is the maximum number of times you can call Master.guess(word). For each test case, you should call Master.guess with the secret word without exceeding the maximum number of allowed guesses. You will get: &quot;Either you took too many guesses, or you did not find the secret word.&quot; if you called Master.guess more than allowedGuesses times or if you did not call Master.guess with the secret word, or &quot;You guessed the secret word correctly.&quot; if you called Master.guess with the secret word with the number of calls to Master.guess less than or equal to allowedGuesses. The test cases are generated such that you can guess the secret word with a reasonable strategy (other than using the bruteforce method). &nbsp; Example 1: Input: secret = &quot;acckzz&quot;, words = [&quot;acckzz&quot;,&quot;ccbazz&quot;,&quot;eiowzz&quot;,&quot;abcczz&quot;], allowedGuesses = 10 Output: You guessed the secret word correctly. Explanation: master.guess(&quot;aaaaaa&quot;) returns -1, because &quot;aaaaaa&quot; is not in wordlist. master.guess(&quot;acckzz&quot;) returns 6, because &quot;acckzz&quot; is secret and has all 6 matches. master.guess(&quot;ccbazz&quot;) returns 3, because &quot;ccbazz&quot; has 3 matches. master.guess(&quot;eiowzz&quot;) returns 2, because &quot;eiowzz&quot; has 2 matches. master.guess(&quot;abcczz&quot;) returns 4, because &quot;abcczz&quot; has 4 matches. We made 5 calls to master.guess, and one of them was the secret, so we pass the test case. Example 2: Input: secret = &quot;hamada&quot;, words = [&quot;hamada&quot;,&quot;khaled&quot;], allowedGuesses = 10 Output: You guessed the secret word correctly. Explanation: Since there are two words, you can guess both. &nbsp; Constraints: 1 &lt;= words.length &lt;= 100 words[i].length == 6 words[i] consist of lowercase English letters. All the strings of wordlist are unique. secret exists in words. 10 &lt;= allowedGuesses &lt;= 30"
    },
    {
      "number": 844,
      "title": "Backspace String Compare",
      "titleSlug": "backspace-string-compare",
      "difficulty": "Easy",
      "tags": [
        "Two Pointers",
        "String",
        "Stack",
        "Simulation"
      ],
      "description": "Given two strings s and t, return true if they are equal when both are typed into empty text editors. &#39;#&#39; means a backspace character. Note that after backspacing an empty text, the text will continue empty. &nbsp; Example 1: Input: s = &quot;ab#c&quot;, t = &quot;ad#c&quot; Output: true Explanation: Both s and t become &quot;ac&quot;. Example 2: Input: s = &quot;ab##&quot;, t = &quot;c#d#&quot; Output: true Explanation: Both s and t become &quot;&quot;. Example 3: Input: s = &quot;a#c&quot;, t = &quot;b&quot; Output: false Explanation: s becomes &quot;c&quot; while t becomes &quot;b&quot;. &nbsp; Constraints: 1 &lt;= s.length, t.length &lt;= 200 s and t only contain lowercase letters and &#39;#&#39; characters. &nbsp; Follow up: Can you solve it in O(n) time and O(1) space?"
    },
    {
      "number": 845,
      "title": "Longest Mountain in Array",
      "titleSlug": "longest-mountain-in-array",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Dynamic Programming",
        "Enumeration"
      ],
      "description": "You may recall that an array arr is a mountain array if and only if: arr.length &gt;= 3 There exists some index i (0-indexed) with 0 &lt; i &lt; arr.length - 1 such that: arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i] arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] Given an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray. &nbsp; Example 1: Input: arr = [2,1,4,7,3,2,5] Output: 5 Explanation: The largest mountain is [1,4,7,3,2] which has length 5. Example 2: Input: arr = [2,2,2] Output: 0 Explanation: There is no mountain. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 104 0 &lt;= arr[i] &lt;= 104 &nbsp; Follow up: Can you solve it using only one pass? Can you solve it in O(1) space?"
    },
    {
      "number": 846,
      "title": "Hand of Straights",
      "titleSlug": "hand-of-straights",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Greedy",
        "Sorting"
      ],
      "description": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards. Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise. &nbsp; Example 1: Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3 Output: true Explanation: Alice&#39;s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8] Example 2: Input: hand = [1,2,3,4,5], groupSize = 4 Output: false Explanation: Alice&#39;s hand can not be rearranged into groups of 4. &nbsp; Constraints: 1 &lt;= hand.length &lt;= 104 0 &lt;= hand[i] &lt;= 109 1 &lt;= groupSize &lt;= hand.length &nbsp; Note: This question is the same as 1296: https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/"
    },
    {
      "number": 847,
      "title": "Shortest Path Visiting All Nodes",
      "titleSlug": "shortest-path-visiting-all-nodes",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming",
        "Bit Manipulation",
        "Breadth-First Search",
        "Graph",
        "Bitmask"
      ],
      "description": "You have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges. &nbsp; Example 1: Input: graph = [[1,2,3],[0],[0],[0]] Output: 4 Explanation: One possible path is [1,0,2,0,3] Example 2: Input: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]] Output: 4 Explanation: One possible path is [0,1,4,2,3] &nbsp; Constraints: n == graph.length 1 &lt;= n &lt;= 12 0 &lt;= graph[i].length &lt;&nbsp;n graph[i] does not contain i. If graph[a] contains b, then graph[b] contains a. The input graph is always connected."
    },
    {
      "number": 848,
      "title": "Shifting Letters",
      "titleSlug": "shifting-letters",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "String",
        "Prefix Sum"
      ],
      "description": "You are given a string s of lowercase English letters and an integer array shifts of the same length. Call the shift() of a letter, the next letter in the alphabet, (wrapping around so that &#39;z&#39; becomes &#39;a&#39;). For example, shift(&#39;a&#39;) = &#39;b&#39;, shift(&#39;t&#39;) = &#39;u&#39;, and shift(&#39;z&#39;) = &#39;a&#39;. Now for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times. Return the final string after all such shifts to s are applied. &nbsp; Example 1: Input: s = &quot;abc&quot;, shifts = [3,5,9] Output: &quot;rpl&quot; Explanation: We start with &quot;abc&quot;. After shifting the first 1 letters of s by 3, we have &quot;dbc&quot;. After shifting the first 2 letters of s by 5, we have &quot;igc&quot;. After shifting the first 3 letters of s by 9, we have &quot;rpl&quot;, the answer. Example 2: Input: s = &quot;aaa&quot;, shifts = [1,2,3] Output: &quot;gfd&quot; &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s consists of lowercase English letters. shifts.length == s.length 0 &lt;= shifts[i] &lt;= 109"
    },
    {
      "number": 849,
      "title": "Maximize Distance to Closest Person",
      "titleSlug": "maximize-distance-to-closest-person",
      "difficulty": "Medium",
      "tags": [
        "Array"
      ],
      "description": "You are given an array representing a row of seats where seats[i] = 1 represents a person sitting in the ith seat, and seats[i] = 0 represents that the ith seat is empty (0-indexed). There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.&nbsp; Return that maximum distance to the closest person. &nbsp; Example 1: Input: seats = [1,0,0,0,1,0,1] Output: 2 Explanation: If Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2. If Alex sits in any other open seat, the closest person has distance 1. Thus, the maximum distance to the closest person is 2. Example 2: Input: seats = [1,0,0,0] Output: 3 Explanation: If Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away. This is the maximum distance possible, so the answer is 3. Example 3: Input: seats = [0,1] Output: 1 &nbsp; Constraints: 2 &lt;= seats.length &lt;= 2 * 104 seats[i]&nbsp;is 0 or&nbsp;1. At least one seat is empty. At least one seat is occupied."
    },
    {
      "number": 850,
      "title": "Rectangle Area II",
      "titleSlug": "rectangle-area-ii",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Segment Tree",
        "Line Sweep",
        "Ordered Set"
      ],
      "description": "You are given a 2D array of axis-aligned rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] denotes the ith rectangle where (xi1, yi1) are the coordinates of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-right corner. Calculate the total area covered by all rectangles in the plane. Any area covered by two or more rectangles should only be counted once. Return the total area. Since the answer may be too large, return it modulo 109 + 7. &nbsp; Example 1: Input: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]] Output: 6 Explanation: A total area of 6 is covered by all three rectangles, as illustrated in the picture. From (1,1) to (2,2), the green and red rectangles overlap. From (1,0) to (2,3), all three rectangles overlap. Example 2: Input: rectangles = [[0,0,1000000000,1000000000]] Output: 49 Explanation: The answer is 1018 modulo (109 + 7), which is 49. &nbsp; Constraints: 1 &lt;= rectangles.length &lt;= 200 rectanges[i].length == 4 0 &lt;= xi1, yi1, xi2, yi2 &lt;= 109 xi1 &lt;= xi2 yi1 &lt;= yi2 All rectangles have non zero area."
    },
    {
      "number": 851,
      "title": "Loud and Rich",
      "titleSlug": "loud-and-rich",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Depth-First Search",
        "Graph",
        "Topological Sort"
      ],
      "description": "There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness. You are given an array richer where richer[i] = [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time). Return an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x. &nbsp; Example 1: Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0] Output: [5,5,2,5,4,5,6,7] Explanation: answer[0] = 5. Person 5 has more money than 3, which has more money than 1, which has more money than 0. The only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0. answer[7] = 7. Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7. The other answers can be filled out with similar reasoning. Example 2: Input: richer = [], quiet = [0] Output: [0] &nbsp; Constraints: n == quiet.length 1 &lt;= n &lt;= 500 0 &lt;= quiet[i] &lt; n All the values of quiet are unique. 0 &lt;= richer.length &lt;= n * (n - 1) / 2 0 &lt;= ai, bi &lt; n ai != bi All the pairs of richer are unique. The observations in richer are all logically consistent."
    },
    {
      "number": 852,
      "title": "Peak Index in a Mountain Array",
      "titleSlug": "peak-index-in-a-mountain-array",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search"
      ],
      "description": "You are given an integer mountain array arr of length n where the values increase to a peak element and then decrease. Return the index of the peak element. Your task is to solve it in O(log(n)) time complexity. &nbsp; Example 1: Input: arr = [0,1,0] Output: 1 Example 2: Input: arr = [0,2,1,0] Output: 1 Example 3: Input: arr = [0,10,5,2] Output: 1 &nbsp; Constraints: 3 &lt;= arr.length &lt;= 105 0 &lt;= arr[i] &lt;= 106 arr is guaranteed to be a mountain array."
    },
    {
      "number": 853,
      "title": "Car Fleet",
      "titleSlug": "car-fleet",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Stack",
        "Sorting",
        "Monotonic Stack"
      ],
      "description": "There are n cars at given miles away from the starting mile 0, traveling to reach the mile target. You are given two integer array position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour. A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car. A car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet. If a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet. Return the number of car fleets that will arrive at the destination. &nbsp; Example 1: Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3] Output: 3 Explanation: The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12. The fleet forms at target. The car starting at 0 (speed 1) does not catch up to any other car, so it is a fleet by itself. The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target. Example 2: Input: target = 10, position = [3], speed = [3] Output: 1 Explanation: There is only one car, hence there is only one fleet. Example 3: Input: target = 100, position = [0,2,4], speed = [4,2,1] Output: 1 Explanation: The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The car starting at 4 (speed 1) travels to 5. Then, the fleet at 4 (speed 2) and the car at position 5 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target. &nbsp; Constraints: n == position.length == speed.length 1 &lt;= n &lt;= 105 0 &lt; target &lt;= 106 0 &lt;= position[i] &lt; target All the values of position are unique. 0 &lt; speed[i] &lt;= 106"
    },
    {
      "number": 854,
      "title": "K-Similar Strings",
      "titleSlug": "k-similar-strings",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Breadth-First Search"
      ],
      "description": "Strings s1 and s2 are k-similar (for some non-negative integer k) if we can swap the positions of two letters in s1 exactly k times so that the resulting string equals s2. Given two anagrams s1 and s2, return the smallest k for which s1 and s2 are k-similar. &nbsp; Example 1: Input: s1 = &quot;ab&quot;, s2 = &quot;ba&quot; Output: 1 Explanation: The two string are 1-similar because we can use one swap to change s1 to s2: &quot;ab&quot; --&gt; &quot;ba&quot;. Example 2: Input: s1 = &quot;abc&quot;, s2 = &quot;bca&quot; Output: 2 Explanation: The two strings are 2-similar because we can use two swaps to change s1 to s2: &quot;abc&quot; --&gt; &quot;bac&quot; --&gt; &quot;bca&quot;. &nbsp; Constraints: 1 &lt;= s1.length &lt;= 20 s2.length == s1.length s1 and s2 contain only lowercase letters from the set {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;}. s2 is an anagram of s1."
    },
    {
      "number": 855,
      "title": "Exam Room",
      "titleSlug": "exam-room",
      "difficulty": "Medium",
      "tags": [
        "Design",
        "Heap (Priority Queue)",
        "Ordered Set"
      ],
      "description": "There is an exam room with n seats in a single row labeled from 0 to n - 1. When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number 0. Design a class that simulates the mentioned exam room. Implement the ExamRoom class: ExamRoom(int n) Initializes the object of the exam room with the number of the seats n. int seat() Returns the label of the seat at which the next student will set. void leave(int p) Indicates that the student sitting at seat p will leave the room. It is guaranteed that there will be a student sitting at seat p. &nbsp; Example 1: Input [&quot;ExamRoom&quot;, &quot;seat&quot;, &quot;seat&quot;, &quot;seat&quot;, &quot;seat&quot;, &quot;leave&quot;, &quot;seat&quot;] [[10], [], [], [], [], [4], []] Output [null, 0, 9, 4, 2, null, 5] Explanation ExamRoom examRoom = new ExamRoom(10); examRoom.seat(); // return 0, no one is in the room, then the student sits at seat number 0. examRoom.seat(); // return 9, the student sits at the last seat number 9. examRoom.seat(); // return 4, the student sits at the last seat number 4. examRoom.seat(); // return 2, the student sits at the last seat number 2. examRoom.leave(4); examRoom.seat(); // return 5, the student sits at the last seat number 5. &nbsp; Constraints: 1 &lt;= n &lt;= 109 It is guaranteed that there is a student sitting at seat p. At most 104 calls will be made to seat and leave."
    },
    {
      "number": 856,
      "title": "Score of Parentheses",
      "titleSlug": "score-of-parentheses",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Stack"
      ],
      "description": "Given a balanced parentheses string s, return the score of the string. The score of a balanced parentheses string is based on the following rule: &quot;()&quot; has score 1. AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string. &nbsp; Example 1: Input: s = &quot;()&quot; Output: 1 Example 2: Input: s = &quot;(())&quot; Output: 2 Example 3: Input: s = &quot;()()&quot; Output: 2 &nbsp; Constraints: 2 &lt;= s.length &lt;= 50 s consists of only &#39;(&#39; and &#39;)&#39;. s is a balanced parentheses string."
    },
    {
      "number": 857,
      "title": "Minimum Cost to Hire K Workers",
      "titleSlug": "minimum-cost-to-hire-k-workers",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Greedy",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "There are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker. We want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules: Every worker in the paid group must be paid at least their minimum wage expectation. In the group, each worker&#39;s pay must be directly proportional to their quality. This means if a worker&rsquo;s quality is double that of another worker in the group, then they must be paid twice as much as the other worker. Given the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10-5 of the actual answer will be accepted. &nbsp; Example 1: Input: quality = [10,20,5], wage = [70,50,30], k = 2 Output: 105.00000 Explanation: We pay 70 to 0th worker and 35 to 2nd worker. Example 2: Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3 Output: 30.66667 Explanation: We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately. &nbsp; Constraints: n == quality.length == wage.length 1 &lt;= k &lt;= n &lt;= 104 1 &lt;= quality[i], wage[i] &lt;= 104"
    },
    {
      "number": 858,
      "title": "Mirror Reflection",
      "titleSlug": "mirror-reflection",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Geometry",
        "Number Theory"
      ],
      "description": "There is a special square room with mirrors on each of the four walls. Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2. The square room has walls of length p&nbsp;and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor. Given the two integers p and q, return the number of the receptor that the ray meets first. The test cases are guaranteed so that the ray will meet a receptor eventually. &nbsp; Example 1: Input: p = 2, q = 1 Output: 2 Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall. Example 2: Input: p = 3, q = 1 Output: 1 &nbsp; Constraints: 1 &lt;= q &lt;= p &lt;= 1000"
    },
    {
      "number": 859,
      "title": "Buddy Strings",
      "titleSlug": "buddy-strings",
      "difficulty": "Easy",
      "tags": [
        "Hash Table",
        "String"
      ],
      "description": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false. Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j]. For example, swapping at indices 0 and 2 in &quot;abcd&quot; results in &quot;cbad&quot;. &nbsp; Example 1: Input: s = &quot;ab&quot;, goal = &quot;ba&quot; Output: true Explanation: You can swap s[0] = &#39;a&#39; and s[1] = &#39;b&#39; to get &quot;ba&quot;, which is equal to goal. Example 2: Input: s = &quot;ab&quot;, goal = &quot;ab&quot; Output: false Explanation: The only letters you can swap are s[0] = &#39;a&#39; and s[1] = &#39;b&#39;, which results in &quot;ba&quot; != goal. Example 3: Input: s = &quot;aa&quot;, goal = &quot;aa&quot; Output: true Explanation: You can swap s[0] = &#39;a&#39; and s[1] = &#39;a&#39; to get &quot;aa&quot;, which is equal to goal. &nbsp; Constraints: 1 &lt;= s.length, goal.length &lt;= 2 * 104 s and goal consist of lowercase letters."
    },
    {
      "number": 860,
      "title": "Lemonade Change",
      "titleSlug": "lemonade-change",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Greedy"
      ],
      "description": "At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5. Note that you do not have any change in hand at first. Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise. &nbsp; Example 1: Input: bills = [5,5,5,10,20] Output: true Explanation: From the first 3 customers, we collect three $5 bills in order. From the fourth customer, we collect a $10 bill and give back a $5. From the fifth customer, we give a $10 bill and a $5 bill. Since all customers got correct change, we output true. Example 2: Input: bills = [5,5,10,10,20] Output: false Explanation: From the first two customers in order, we collect two $5 bills. For the next two customers in order, we collect a $10 bill and give back a $5 bill. For the last customer, we can not give the change of $15 back because we only have two $10 bills. Since not every customer received the correct change, the answer is false. &nbsp; Constraints: 1 &lt;= bills.length &lt;= 105 bills[i] is either 5, 10, or 20."
    },
    {
      "number": 861,
      "title": "Score After Flipping Matrix",
      "titleSlug": "score-after-flipping-matrix",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Greedy",
        "Bit Manipulation",
        "Matrix"
      ],
      "description": "You are given an m x n binary matrix grid. A move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0&#39;s to 1&#39;s, and all 1&#39;s to 0&#39;s). Every row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers. Return the highest possible score after making any number of moves (including zero moves). &nbsp; Example 1: Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 Example 2: Input: grid = [[0]] Output: 1 &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 20 grid[i][j] is either 0 or 1."
    },
    {
      "number": 862,
      "title": "Shortest Subarray with Sum at Least K",
      "titleSlug": "shortest-subarray-with-sum-at-least-k",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Binary Search",
        "Queue",
        "Sliding Window",
        "Heap (Priority Queue)",
        "Prefix Sum",
        "Monotonic Queue"
      ],
      "description": "Given an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1. A subarray is a contiguous part of an array. &nbsp; Example 1: Input: nums = [1], k = 1 Output: 1 Example 2: Input: nums = [1,2], k = 4 Output: -1 Example 3: Input: nums = [2,-1,2], k = 3 Output: 3 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 -105 &lt;= nums[i] &lt;= 105 1 &lt;= k &lt;= 109"
    },
    {
      "number": 863,
      "title": "All Nodes Distance K in Binary Tree",
      "titleSlug": "all-nodes-distance-k-in-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node. You can return the answer in any order. &nbsp; Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2 Output: [7,4,1] Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1. Example 2: Input: root = [1], target = 1, k = 3 Output: [] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 500]. 0 &lt;= Node.val &lt;= 500 All the values Node.val are unique. target is the value of one of the nodes in the tree. 0 &lt;= k &lt;= 1000"
    },
    {
      "number": 864,
      "title": "Shortest Path to Get All Keys",
      "titleSlug": "shortest-path-to-get-all-keys",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Bit Manipulation",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "You are given an m x n grid grid where: &#39;.&#39; is an empty cell. &#39;#&#39; is a wall. &#39;@&#39; is the starting point. Lowercase letters represent keys. Uppercase letters represent locks. You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall. If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key. For some 1 &lt;= k &lt;= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet. Return the lowest number of moves to acquire all keys. If it is impossible, return -1. &nbsp; Example 1: Input: grid = [&quot;@.a..&quot;,&quot;###.#&quot;,&quot;b.A.B&quot;] Output: 8 Explanation: Note that the goal is to obtain all the keys not to open all the locks. Example 2: Input: grid = [&quot;@..aA&quot;,&quot;..B#.&quot;,&quot;....b&quot;] Output: 6 Example 3: Input: grid = [&quot;@Aa&quot;] Output: -1 &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 30 grid[i][j] is either an English letter, &#39;.&#39;, &#39;#&#39;, or &#39;@&#39;.&nbsp; There is exactly one&nbsp;&#39;@&#39;&nbsp;in the grid. The number of keys in the grid is in the range [1, 6]. Each key in the grid is unique. Each key in the grid has a matching lock."
    },
    {
      "number": 865,
      "title": "Smallest Subtree with all the Deepest Nodes",
      "titleSlug": "smallest-subtree-with-all-the-deepest-nodes",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, the depth of each node is the shortest distance to the root. Return the smallest subtree such that it contains all the deepest nodes in the original tree. A node is called the deepest if it has the largest depth possible among any node in the entire tree. The subtree of a node is a tree consisting of that node, plus the set of all descendants of that node. &nbsp; Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4] Output: [2,7,4] Explanation: We return the node with value 2, colored in yellow in the diagram. The nodes coloured in blue are the deepest nodes of the tree. Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it. Example 2: Input: root = [1] Output: [1] Explanation: The root is the deepest node in the tree. Example 3: Input: root = [0,1,3,null,2] Output: [2] Explanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest. &nbsp; Constraints: The number of nodes in the tree will be in the range [1, 500]. 0 &lt;= Node.val &lt;= 500 The values of the nodes in the tree are unique. &nbsp; Note: This question is the same as 1123: https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/"
    },
    {
      "number": 866,
      "title": "Prime Palindrome",
      "titleSlug": "prime-palindrome",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Number Theory"
      ],
      "description": "Given an integer n, return the smallest prime palindrome greater than or equal to n. An integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number. For example, 2, 3, 5, 7, 11, and 13 are all primes. An integer is a palindrome if it reads the same from left to right as it does from right to left. For example, 101 and 12321 are palindromes. The test cases are generated so that the answer always exists and is in the range [2, 2 * 108]. &nbsp; Example 1: Input: n = 6 Output: 7 Example 2: Input: n = 8 Output: 11 Example 3: Input: n = 13 Output: 101 &nbsp; Constraints: 1 &lt;= n &lt;= 108"
    },
    {
      "number": 867,
      "title": "Transpose Matrix",
      "titleSlug": "transpose-matrix",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Matrix",
        "Simulation"
      ],
      "description": "Given a 2D integer array matrix, return the transpose of matrix. The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix&#39;s row and column indices. &nbsp; Example 1: Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]] Example 2: Input: matrix = [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]] &nbsp; Constraints: m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 1000 1 &lt;= m * n &lt;= 105 -109 &lt;= matrix[i][j] &lt;= 109"
    },
    {
      "number": 868,
      "title": "Binary Gap",
      "titleSlug": "binary-gap",
      "difficulty": "Easy",
      "tags": [
        "Bit Manipulation"
      ],
      "description": "Given a positive integer n, find and return the longest distance between any two adjacent 1&#39;s in the binary representation of n. If there are no two adjacent 1&#39;s, return 0. Two 1&#39;s are adjacent if there are only 0&#39;s separating them (possibly no 0&#39;s). The distance between two 1&#39;s is the absolute difference between their bit positions. For example, the two 1&#39;s in &quot;1001&quot; have a distance of 3. &nbsp; Example 1: Input: n = 22 Output: 2 Explanation: 22 in binary is &quot;10110&quot;. The first adjacent pair of 1&#39;s is &quot;10110&quot; with a distance of 2. The second adjacent pair of 1&#39;s is &quot;10110&quot; with a distance of 1. The answer is the largest of these two distances, which is 2. Note that &quot;10110&quot; is not a valid pair since there is a 1 separating the two 1&#39;s underlined. Example 2: Input: n = 8 Output: 0 Explanation: 8 in binary is &quot;1000&quot;. There are not any adjacent pairs of 1&#39;s in the binary representation of 8, so we return 0. Example 3: Input: n = 5 Output: 2 Explanation: 5 in binary is &quot;101&quot;. &nbsp; Constraints: 1 &lt;= n &lt;= 109"
    },
    {
      "number": 869,
      "title": "Reordered Power of 2",
      "titleSlug": "reordered-power-of-2",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Math",
        "Sorting",
        "Counting",
        "Enumeration"
      ],
      "description": "You are given an integer n. We reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this so that the resulting number is a power of two. &nbsp; Example 1: Input: n = 1 Output: true Example 2: Input: n = 10 Output: false &nbsp; Constraints: 1 &lt;= n &lt;= 109"
    },
    {
      "number": 870,
      "title": "Advantage Shuffle",
      "titleSlug": "advantage-shuffle",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Greedy",
        "Sorting"
      ],
      "description": "You are given two integer arrays nums1 and nums2 both of the same length. The advantage of nums1 with respect to nums2 is the number of indices i for which nums1[i] &gt; nums2[i]. Return any permutation of nums1 that maximizes its advantage with respect to nums2. &nbsp; Example 1: Input: nums1 = [2,7,11,15], nums2 = [1,10,4,11] Output: [2,11,7,15] Example 2: Input: nums1 = [12,24,8,32], nums2 = [13,25,32,11] Output: [24,32,8,12] &nbsp; Constraints: 1 &lt;= nums1.length &lt;= 105 nums2.length == nums1.length 0 &lt;= nums1[i], nums2[i] &lt;= 109"
    },
    {
      "number": 871,
      "title": "Minimum Number of Refueling Stops",
      "titleSlug": "minimum-number-of-refueling-stops",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Greedy",
        "Heap (Priority Queue)"
      ],
      "description": "A car travels from a starting position to a destination which is target miles east of the starting position. There are gas stations along the way. The gas stations are represented as an array stations where stations[i] = [positioni, fueli] indicates that the ith gas station is positioni miles east of the starting position and has fueli liters of gas. The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car. Return the minimum number of refueling stops the car must make in order to reach its destination. If it cannot reach the destination, return -1. Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there. If the car reaches the destination with 0 fuel left, it is still considered to have arrived. &nbsp; Example 1: Input: target = 1, startFuel = 1, stations = [] Output: 0 Explanation: We can reach the target without refueling. Example 2: Input: target = 100, startFuel = 1, stations = [[10,100]] Output: -1 Explanation: We can not reach the target (or even the first gas station). Example 3: Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] Output: 2 Explanation: We start with 10 liters of fuel. We drive to position 10, expending 10 liters of fuel. We refuel from 0 liters to 60 liters of gas. Then, we drive from position 10 to position 60 (expending 50 liters of fuel), and refuel from 10 liters to 50 liters of gas. We then drive to and reach the target. We made 2 refueling stops along the way, so we return 2. &nbsp; Constraints: 1 &lt;= target, startFuel &lt;= 109 0 &lt;= stations.length &lt;= 500 1 &lt;= positioni &lt; positioni+1 &lt; target 1 &lt;= fueli &lt; 109"
    },
    {
      "number": 872,
      "title": "Leaf-Similar Trees",
      "titleSlug": "leaf-similar-trees",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Consider all the leaves of a binary tree, from&nbsp;left to right order, the values of those&nbsp;leaves form a leaf value sequence. For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar&nbsp;if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar. &nbsp; Example 1: Input: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8] Output: true Example 2: Input: root1 = [1,2,3], root2 = [1,3,2] Output: false &nbsp; Constraints: The number of nodes in each tree will be in the range [1, 200]. Both of the given trees will have values in the range [0, 200]."
    },
    {
      "number": 873,
      "title": "Length of Longest Fibonacci Subsequence",
      "titleSlug": "length-of-longest-fibonacci-subsequence",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Dynamic Programming"
      ],
      "description": "A sequence x1, x2, ..., xn is Fibonacci-like if: n &gt;= 3 xi + xi+1 == xi+2 for all i + 2 &lt;= n Given a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0. A subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8]. &nbsp; Example 1: Input: arr = [1,2,3,4,5,6,7,8] Output: 5 Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8]. Example 2: Input: arr = [1,3,7,11,12,14,18] Output: 3 Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18]. &nbsp; Constraints: 3 &lt;= arr.length &lt;= 1000 1 &lt;= arr[i] &lt; arr[i + 1] &lt;= 109"
    },
    {
      "number": 874,
      "title": "Walking Robot Simulation",
      "titleSlug": "walking-robot-simulation",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Simulation"
      ],
      "description": "A robot on an infinite XY-plane starts at point (0, 0) facing north. The robot receives an array of integers commands, which represents a sequence of moves that it needs to execute. There are only three possible types of instructions the robot can receive: -2: Turn left 90 degrees. -1: Turn right 90 degrees. 1 &lt;= k &lt;= 9: Move forward k units, one unit at a time. Some of the grid squares are obstacles. The ith obstacle is at grid point obstacles[i] = (xi, yi). If the robot runs into an obstacle, it will stay in its current location (on the block adjacent to the obstacle) and move onto the next command. Return the maximum squared Euclidean distance that the robot reaches at any point in its path (i.e. if the distance is 5, return 25). Note: There can be an obstacle at (0, 0). If this happens, the robot will ignore the obstacle until it has moved off the origin. However, it will be unable to return to (0, 0) due to the obstacle. North means +Y direction. East means +X direction. South means -Y direction. West means -X direction. &nbsp; Example 1: Input: commands = [4,-1,3], obstacles = [] Output: 25 Explanation: The robot starts at (0, 0): Move north 4 units to (0, 4). Turn right. Move east 3 units to (3, 4). The furthest point the robot ever gets from the origin is (3, 4), which squared is 32 + 42 = 25 units away. Example 2: Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]] Output: 65 Explanation: The robot starts at (0, 0): Move north 4 units to (0, 4). Turn right. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4). Turn left. Move north 4 units to (1, 8). The furthest point the robot ever gets from the origin is (1, 8), which squared is 12 + 82 = 65 units away. Example 3: Input: commands = [6,-1,-1,6], obstacles = [[0,0]] Output: 36 Explanation: The robot starts at (0, 0): Move north 6 units to (0, 6). Turn right. Turn right. Move south 5 units and get blocked by the obstacle at (0,0), robot is at (0, 1). The furthest point the robot ever gets from the origin is (0, 6), which squared is 62 = 36 units away. &nbsp; Constraints: 1 &lt;= commands.length &lt;= 104 commands[i] is either -2, -1, or an integer in the range [1, 9]. 0 &lt;= obstacles.length &lt;= 104 -3 * 104 &lt;= xi, yi &lt;= 3 * 104 The answer is guaranteed to be less than 231."
    },
    {
      "number": 875,
      "title": "Koko Eating Bananas",
      "titleSlug": "koko-eating-bananas",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search"
      ],
      "description": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return the minimum integer k such that she can eat all the bananas within h hours. &nbsp; Example 1: Input: piles = [3,6,7,11], h = 8 Output: 4 Example 2: Input: piles = [30,11,23,4,20], h = 5 Output: 30 Example 3: Input: piles = [30,11,23,4,20], h = 6 Output: 23 &nbsp; Constraints: 1 &lt;= piles.length &lt;= 104 piles.length &lt;= h &lt;= 109 1 &lt;= piles[i] &lt;= 109"
    },
    {
      "number": 876,
      "title": "Middle of the Linked List",
      "titleSlug": "middle-of-the-linked-list",
      "difficulty": "Easy",
      "tags": [
        "Linked List",
        "Two Pointers"
      ],
      "description": "Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. &nbsp; Example 1: Input: head = [1,2,3,4,5] Output: [3,4,5] Explanation: The middle node of the list is node 3. Example 2: Input: head = [1,2,3,4,5,6] Output: [4,5,6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. &nbsp; Constraints: The number of nodes in the list is in the range [1, 100]. 1 &lt;= Node.val &lt;= 100"
    },
    {
      "number": 877,
      "title": "Stone Game",
      "titleSlug": "stone-game",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math",
        "Dynamic Programming",
        "Game Theory"
      ],
      "description": "Alice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. The total number of stones across all the piles is odd, so there are no ties. Alice and Bob take turns, with Alice starting first. Each turn, a player takes the entire pile of stones either from the beginning or from the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins. &nbsp; Example 1: Input: piles = [5,3,4,5] Output: true Explanation: Alice starts first, and can only take the first 5 or the last 5. Say she takes the first 5, so that the row becomes [3, 4, 5]. If Bob takes 3, then the board is [4, 5], and Alice takes 5 to win with 10 points. If Bob takes the last 5, then the board is [3, 4], and Alice takes 4 to win with 9 points. This demonstrated that taking the first 5 was a winning move for Alice, so we return true. Example 2: Input: piles = [3,7,2,3] Output: true &nbsp; Constraints: 2 &lt;= piles.length &lt;= 500 piles.length is even. 1 &lt;= piles[i] &lt;= 500 sum(piles[i]) is odd."
    },
    {
      "number": 878,
      "title": "Nth Magical Number",
      "titleSlug": "nth-magical-number",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "Binary Search"
      ],
      "description": "A positive integer is magical if it is divisible by either a or b. Given the three integers n, a, and b, return the nth magical number. Since the answer may be very large, return it modulo 109 + 7. &nbsp; Example 1: Input: n = 1, a = 2, b = 3 Output: 2 Example 2: Input: n = 4, a = 2, b = 3 Output: 6 &nbsp; Constraints: 1 &lt;= n &lt;= 109 2 &lt;= a, b &lt;= 4 * 104"
    },
    {
      "number": 879,
      "title": "Profitable Schemes",
      "titleSlug": "profitable-schemes",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "There is a group of n members, and a list of various crimes they could commit. The ith crime generates a profit[i] and requires group[i] members to participate in it. If a member participates in one crime, that member can&#39;t participate in another crime. Let&#39;s call a profitable scheme any subset of these crimes that generates at least minProfit profit, and the total number of members participating in that subset of crimes is at most n. Return the number of schemes that can be chosen. Since the answer may be very large, return it modulo 109 + 7. &nbsp; Example 1: Input: n = 5, minProfit = 3, group = [2,2], profit = [2,3] Output: 2 Explanation: To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes. Example 2: Input: n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation: To make a profit of at least 5, the group could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2). &nbsp; Constraints: 1 &lt;= n &lt;= 100 0 &lt;= minProfit &lt;= 100 1 &lt;= group.length &lt;= 100 1 &lt;= group[i] &lt;= 100 profit.length == group.length 0 &lt;= profit[i] &lt;= 100"
    },
    {
      "number": 880,
      "title": "Decoded String at Index",
      "titleSlug": "decoded-string-at-index",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Stack"
      ],
      "description": "You are given an encoded string s. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken: If the character read is a letter, that letter is written onto the tape. If the character read is a digit d, the entire current tape is repeatedly written d - 1 more times in total. Given an integer k, return the kth letter (1-indexed) in the decoded string. &nbsp; Example 1: Input: s = &quot;leet2code3&quot;, k = 10 Output: &quot;o&quot; Explanation: The decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;. The 10th letter in the string is &quot;o&quot;. Example 2: Input: s = &quot;ha22&quot;, k = 5 Output: &quot;h&quot; Explanation: The decoded string is &quot;hahahaha&quot;. The 5th letter is &quot;h&quot;. Example 3: Input: s = &quot;a2345678999999999999999&quot;, k = 1 Output: &quot;a&quot; Explanation: The decoded string is &quot;a&quot; repeated 8301530446056247680 times. The 1st letter is &quot;a&quot;. &nbsp; Constraints: 2 &lt;= s.length &lt;= 100 s consists of lowercase English letters and digits 2 through 9. s starts with a letter. 1 &lt;= k &lt;= 109 It is guaranteed that k is less than or equal to the length of the decoded string. The decoded string is guaranteed to have less than 263 letters."
    },
    {
      "number": 881,
      "title": "Boats to Save People",
      "titleSlug": "boats-to-save-people",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Greedy",
        "Sorting"
      ],
      "description": "You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person. &nbsp; Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) &nbsp; Constraints: 1 &lt;= people.length &lt;= 5 * 104 1 &lt;= people[i] &lt;= limit &lt;= 3 * 104"
    },
    {
      "number": 882,
      "title": "Reachable Nodes In Subdivided Graph",
      "titleSlug": "reachable-nodes-in-subdivided-graph",
      "difficulty": "Hard",
      "tags": [
        "Graph",
        "Heap (Priority Queue)",
        "Shortest Path"
      ],
      "description": "You are given an undirected graph (the &quot;original graph&quot;) with n nodes labeled from 0 to n - 1. You decide to subdivide each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge. The graph is given as a 2D array of edges where edges[i] = [ui, vi, cnti] indicates that there is an edge between nodes ui and vi in the original graph, and cnti is the total number of new nodes that you will subdivide the edge into. Note that cnti == 0 means you will not subdivide the edge. To subdivide the edge [ui, vi], replace it with (cnti + 1) new edges and cnti new nodes. The new nodes are x1, x2, ..., xcnti, and the new edges are [ui, x1], [x1, x2], [x2, x3], ..., [xcnti-1, xcnti], [xcnti, vi]. In this new graph, you want to know how many nodes are reachable from the node 0, where a node is reachable if the distance is maxMoves or less. Given the original graph and maxMoves, return the number of nodes that are reachable from node 0 in the new graph. &nbsp; Example 1: Input: edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3 Output: 13 Explanation: The edge subdivisions are shown in the image above. The nodes that are reachable are highlighted in yellow. Example 2: Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4 Output: 23 Example 3: Input: edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5 Output: 1 Explanation: Node 0 is disconnected from the rest of the graph, so only node 0 is reachable. &nbsp; Constraints: 0 &lt;= edges.length &lt;= min(n * (n - 1) / 2, 104) edges[i].length == 3 0 &lt;= ui &lt; vi &lt; n There are no multiple edges in the graph. 0 &lt;= cnti &lt;= 104 0 &lt;= maxMoves &lt;= 109 1 &lt;= n &lt;= 3000"
    },
    {
      "number": 883,
      "title": "Projection Area of 3D Shapes",
      "titleSlug": "projection-area-of-3d-shapes",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math",
        "Geometry",
        "Matrix"
      ],
      "description": "You are given an n x n grid where we place some 1 x 1 x 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of the cell (i, j). We view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3-dimensional figure to a 2-dimensional plane. We are viewing the &quot;shadow&quot; when looking at the cubes from the top, the front, and the side. Return the total area of all three projections. &nbsp; Example 1: Input: grid = [[1,2],[3,4]] Output: 17 Explanation: Here are the three projections (&quot;shadows&quot;) of the shape made with each axis-aligned plane. Example 2: Input: grid = [[2]] Output: 5 Example 3: Input: grid = [[1,0],[0,2]] Output: 8 &nbsp; Constraints: n == grid.length == grid[i].length 1 &lt;= n &lt;= 50 0 &lt;= grid[i][j] &lt;= 50"
    },
    {
      "number": 884,
      "title": "Uncommon Words from Two Sentences",
      "titleSlug": "uncommon-words-from-two-sentences",
      "difficulty": "Easy",
      "tags": [
        "Hash Table",
        "String",
        "Counting"
      ],
      "description": "A sentence is a string of single-space separated words where each word consists only of lowercase letters. A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order. &nbsp; Example 1: Input: s1 = &quot;this apple is sweet&quot;, s2 = &quot;this apple is sour&quot; Output: [&quot;sweet&quot;,&quot;sour&quot;] Explanation: The word &quot;sweet&quot; appears only in s1, while the word &quot;sour&quot; appears only in s2. Example 2: Input: s1 = &quot;apple apple&quot;, s2 = &quot;banana&quot; Output: [&quot;banana&quot;] &nbsp; Constraints: 1 &lt;= s1.length, s2.length &lt;= 200 s1 and s2 consist of lowercase English letters and spaces. s1 and s2 do not have leading or trailing spaces. All the words in s1 and s2 are separated by a single space."
    },
    {
      "number": 885,
      "title": "Spiral Matrix III",
      "titleSlug": "spiral-matrix-iii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Matrix",
        "Simulation"
      ],
      "description": "You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column. You will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid&#39;s boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all rows * cols spaces of the grid. Return an array of coordinates representing the positions of the grid in the order you visited them. &nbsp; Example 1: Input: rows = 1, cols = 4, rStart = 0, cStart = 0 Output: [[0,0],[0,1],[0,2],[0,3]] Example 2: Input: rows = 5, cols = 6, rStart = 1, cStart = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]] &nbsp; Constraints: 1 &lt;= rows, cols &lt;= 100 0 &lt;= rStart &lt; rows 0 &lt;= cStart &lt; cols"
    },
    {
      "number": 886,
      "title": "Possible Bipartition",
      "titleSlug": "possible-bipartition",
      "difficulty": "Medium",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Graph"
      ],
      "description": "We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Given the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way. &nbsp; Example 1: Input: n = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: The first group has [1,4], and the second group has [2,3]. Example 2: Input: n = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false Explanation: We need at least 3 groups to divide them. We cannot put them in two groups. &nbsp; Constraints: 1 &lt;= n &lt;= 2000 0 &lt;= dislikes.length &lt;= 104 dislikes[i].length == 2 1 &lt;= ai &lt; bi &lt;= n All the pairs of dislikes are unique."
    },
    {
      "number": 887,
      "title": "Super Egg Drop",
      "titleSlug": "super-egg-drop",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "Binary Search",
        "Dynamic Programming"
      ],
      "description": "You are given k identical eggs and you have access to a building with n floors labeled from 1 to n. You know that there exists a floor f where 0 &lt;= f &lt;= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break. Each move, you may take an unbroken egg and drop it from any floor x (where 1 &lt;= x &lt;= n). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves. Return the minimum number of moves that you need to determine with certainty what the value of f is. &nbsp; Example 1: Input: k = 1, n = 2 Output: 2 Explanation: Drop the egg from floor 1. If it breaks, we know that f = 0. Otherwise, drop the egg from floor 2. If it breaks, we know that f = 1. If it does not break, then we know f = 2. Hence, we need at minimum 2 moves to determine with certainty what the value of f is. Example 2: Input: k = 2, n = 6 Output: 3 Example 3: Input: k = 3, n = 14 Output: 4 &nbsp; Constraints: 1 &lt;= k &lt;= 100 1 &lt;= n &lt;= 104"
    },
    {
      "number": 888,
      "title": "Fair Candy Swap",
      "titleSlug": "fair-candy-swap",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Binary Search",
        "Sorting"
      ],
      "description": "Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has. Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have. Return an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists. &nbsp; Example 1: Input: aliceSizes = [1,1], bobSizes = [2,2] Output: [1,2] Example 2: Input: aliceSizes = [1,2], bobSizes = [2,3] Output: [1,2] Example 3: Input: aliceSizes = [2], bobSizes = [1,3] Output: [2,3] &nbsp; Constraints: 1 &lt;= aliceSizes.length, bobSizes.length &lt;= 104 1 &lt;= aliceSizes[i], bobSizes[j] &lt;= 105 Alice and Bob have a different total number of candies. There will be at least one valid answer for the given input."
    },
    {
      "number": 889,
      "title": "Construct Binary Tree from Preorder and Postorder Traversal",
      "titleSlug": "construct-binary-tree-from-preorder-and-postorder-traversal",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Divide and Conquer",
        "Tree",
        "Binary Tree"
      ],
      "description": "Given two integer arrays, preorder and postorder where preorder is the preorder traversal of a binary tree of distinct values and postorder is the postorder traversal of the same tree, reconstruct and return the binary tree. If there exist multiple answers, you can return any of them. &nbsp; Example 1: Input: preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7] Example 2: Input: preorder = [1], postorder = [1] Output: [1] &nbsp; Constraints: 1 &lt;= preorder.length &lt;= 30 1 &lt;= preorder[i] &lt;= preorder.length All the values of preorder are unique. postorder.length == preorder.length 1 &lt;= postorder[i] &lt;= postorder.length All the values of postorder are unique. It is guaranteed that preorder and postorder are the preorder traversal and postorder traversal of the same binary tree."
    },
    {
      "number": 890,
      "title": "Find and Replace Pattern",
      "titleSlug": "find-and-replace-pattern",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter. &nbsp; Example 1: Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot; Output: [&quot;mee&quot;,&quot;aqq&quot;] Explanation: &quot;mee&quot; matches the pattern because there is a permutation {a -&gt; m, b -&gt; e, ...}. &quot;ccc&quot; does not match the pattern because {a -&gt; c, b -&gt; c, ...} is not a permutation, since a and b map to the same letter. Example 2: Input: words = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], pattern = &quot;a&quot; Output: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] &nbsp; Constraints: 1 &lt;= pattern.length &lt;= 20 1 &lt;= words.length &lt;= 50 words[i].length == pattern.length pattern and words[i] are lowercase English letters."
    },
    {
      "number": 891,
      "title": "Sum of Subsequence Widths",
      "titleSlug": "sum-of-subsequence-widths",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Sorting"
      ],
      "description": "The width of a sequence is the difference between the maximum and minimum elements in the sequence. Given an array of integers nums, return the sum of the widths of all the non-empty subsequences of nums. Since the answer may be very large, return it modulo 109 + 7. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7]. &nbsp; Example 1: Input: nums = [2,1,3] Output: 6 Explanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6. Example 2: Input: nums = [2] Output: 0 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105"
    },
    {
      "number": 892,
      "title": "Surface Area of 3D Shapes",
      "titleSlug": "surface-area-of-3d-shapes",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math",
        "Geometry",
        "Matrix"
      ],
      "description": "You are given an n x n grid where you have placed some 1 x 1 x 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of cell (i, j). After placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes. Return the total surface area of the resulting shapes. Note: The bottom face of each shape counts toward its surface area. &nbsp; Example 1: Input: grid = [[1,2],[3,4]] Output: 34 Example 2: Input: grid = [[1,1,1],[1,0,1],[1,1,1]] Output: 32 Example 3: Input: grid = [[2,2,2],[2,1,2],[2,2,2]] Output: 46 &nbsp; Constraints: n == grid.length == grid[i].length 1 &lt;= n &lt;= 50 0 &lt;= grid[i][j] &lt;= 50"
    },
    {
      "number": 893,
      "title": "Groups of Special-Equivalent Strings",
      "titleSlug": "groups-of-special-equivalent-strings",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Sorting"
      ],
      "description": "You are given an array of strings of the same length words. In one move, you can swap any two even indexed characters or any two odd indexed characters of a string words[i]. Two strings words[i] and words[j] are special-equivalent if after any number of moves, words[i] == words[j]. For example, words[i] = &quot;zzxy&quot; and words[j] = &quot;xyzz&quot; are special-equivalent because we may make the moves &quot;zzxy&quot; -&gt; &quot;xzzy&quot; -&gt; &quot;xyzz&quot;. A group of special-equivalent strings from words is a non-empty subset of words such that: Every pair of strings in the group are special equivalent, and The group is the largest size possible (i.e., there is not a string words[i] not in the group such that words[i] is special-equivalent to every string in the group). Return the number of groups of special-equivalent strings from words. &nbsp; Example 1: Input: words = [&quot;abcd&quot;,&quot;cdab&quot;,&quot;cbad&quot;,&quot;xyzz&quot;,&quot;zzxy&quot;,&quot;zzyx&quot;] Output: 3 Explanation: One group is [&quot;abcd&quot;, &quot;cdab&quot;, &quot;cbad&quot;], since they are all pairwise special equivalent, and none of the other strings is all pairwise special equivalent to these. The other two groups are [&quot;xyzz&quot;, &quot;zzxy&quot;] and [&quot;zzyx&quot;]. Note that in particular, &quot;zzxy&quot; is not special equivalent to &quot;zzyx&quot;. Example 2: Input: words = [&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] Output: 3 &nbsp; Constraints: 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 20 words[i] consist of lowercase English letters. All the strings are of the same length."
    },
    {
      "number": 894,
      "title": "All Possible Full Binary Trees",
      "titleSlug": "all-possible-full-binary-trees",
      "difficulty": "Medium",
      "tags": [
        "Dynamic Programming",
        "Tree",
        "Recursion",
        "Memoization",
        "Binary Tree"
      ],
      "description": "Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0. Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order. A full binary tree is a binary tree where each node has exactly 0 or 2 children. &nbsp; Example 1: Input: n = 7 Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]] Example 2: Input: n = 3 Output: [[0,0,0]] &nbsp; Constraints: 1 &lt;= n &lt;= 20"
    },
    {
      "number": 895,
      "title": "Maximum Frequency Stack",
      "titleSlug": "maximum-frequency-stack",
      "difficulty": "Hard",
      "tags": [
        "Hash Table",
        "Stack",
        "Design",
        "Ordered Set"
      ],
      "description": "Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack. Implement the FreqStack class: FreqStack() constructs an empty frequency stack. void push(int val) pushes an integer val onto the top of the stack. int pop() removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the stack&#39;s top is removed and returned. &nbsp; Example 1: Input [&quot;FreqStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;] [[], [5], [7], [5], [7], [4], [5], [], [], [], []] Output [null, null, null, null, null, null, null, 5, 7, 5, 4] Explanation FreqStack freqStack = new FreqStack(); freqStack.push(5); // The stack is [5] freqStack.push(7); // The stack is [5,7] freqStack.push(5); // The stack is [5,7,5] freqStack.push(7); // The stack is [5,7,5,7] freqStack.push(4); // The stack is [5,7,5,7,4] freqStack.push(5); // The stack is [5,7,5,7,4,5] freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4]. freqStack.pop(); // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4]. freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,4]. freqStack.pop(); // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7]. &nbsp; Constraints: 0 &lt;= val &lt;= 109 At most 2 * 104 calls will be made to push and pop. It is guaranteed that there will be at least one element in the stack before calling pop."
    },
    {
      "number": 896,
      "title": "Monotonic Array",
      "titleSlug": "monotonic-array",
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "description": "An array is monotonic if it is either monotone increasing or monotone decreasing. An array nums is monotone increasing if for all i &lt;= j, nums[i] &lt;= nums[j]. An array nums is monotone decreasing if for all i &lt;= j, nums[i] &gt;= nums[j]. Given an integer array nums, return true if the given array is monotonic, or false otherwise. &nbsp; Example 1: Input: nums = [1,2,2,3] Output: true Example 2: Input: nums = [6,5,4,4] Output: true Example 3: Input: nums = [1,3,2] Output: false &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 -105 &lt;= nums[i] &lt;= 105"
    },
    {
      "number": 897,
      "title": "Increasing Order Search Tree",
      "titleSlug": "increasing-order-search-tree",
      "difficulty": "Easy",
      "tags": [
        "Stack",
        "Tree",
        "Depth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child. &nbsp; Example 1: Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9] Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] Example 2: Input: root = [5,1,7] Output: [1,null,5,null,7] &nbsp; Constraints: The number of nodes in the given tree will be in the range [1, 100]. 0 &lt;= Node.val &lt;= 1000"
    },
    {
      "number": 898,
      "title": "Bitwise ORs of Subarrays",
      "titleSlug": "bitwise-ors-of-subarrays",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Bit Manipulation"
      ],
      "description": "Given an integer array arr, return the number of distinct bitwise ORs of all the non-empty subarrays of arr. The bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer. A subarray is a contiguous non-empty sequence of elements within an array. &nbsp; Example 1: Input: arr = [0] Output: 1 Explanation: There is only one possible result: 0. Example 2: Input: arr = [1,1,2] Output: 3 Explanation: The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3. Example 3: Input: arr = [1,2,4] Output: 6 Explanation: The possible results are 1, 2, 3, 4, 6, and 7. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 5 * 104 0 &lt;= arr[i] &lt;= 109"
    },
    {
      "number": 899,
      "title": "Orderly Queue",
      "titleSlug": "orderly-queue",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "String",
        "Sorting"
      ],
      "description": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string. Return the lexicographically smallest string you could have after applying the mentioned step any number of moves. &nbsp; Example 1: Input: s = &quot;cba&quot;, k = 1 Output: &quot;acb&quot; Explanation: In the first move, we move the 1st character &#39;c&#39; to the end, obtaining the string &quot;bac&quot;. In the second move, we move the 1st character &#39;b&#39; to the end, obtaining the final result &quot;acb&quot;. Example 2: Input: s = &quot;baaca&quot;, k = 3 Output: &quot;aaabc&quot; Explanation: In the first move, we move the 1st character &#39;b&#39; to the end, obtaining the string &quot;aacab&quot;. In the second move, we move the 3rd character &#39;c&#39; to the end, obtaining the final result &quot;aaabc&quot;. &nbsp; Constraints: 1 &lt;= k &lt;= s.length &lt;= 1000 s consist of lowercase English letters."
    },
    {
      "number": 900,
      "title": "RLE Iterator",
      "titleSlug": "rle-iterator",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Design",
        "Counting",
        "Iterator"
      ],
      "description": "We can use run-length encoding (i.e., RLE) to encode a sequence of integers. In a run-length encoded array of even length encoding (0-indexed), for all even i, encoding[i] tells us the number of times that the non-negative integer value encoding[i + 1] is repeated in the sequence. For example, the sequence arr = [8,8,8,5,5] can be encoded to be encoding = [3,8,2,5]. encoding = [3,8,0,9,2,5] and encoding = [2,8,1,8,2,5] are also valid RLE of arr. Given a run-length encoded array, design an iterator that iterates through it. Implement the RLEIterator class: RLEIterator(int[] encoded) Initializes the object with the encoded array encoded. int next(int n) Exhausts the next n elements and returns the last element exhausted in this way. If there is no element left to exhaust, return -1 instead. &nbsp; Example 1: Input [&quot;RLEIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;] [[[3, 8, 0, 9, 2, 5]], [2], [1], [1], [2]] Output [null, 8, 8, 5, -1] Explanation RLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // This maps to the sequence [8,8,8,5,5]. rLEIterator.next(2); // exhausts 2 terms of the sequence, returning 8. The remaining sequence is now [8, 5, 5]. rLEIterator.next(1); // exhausts 1 term of the sequence, returning 8. The remaining sequence is now [5, 5]. rLEIterator.next(1); // exhausts 1 term of the sequence, returning 5. The remaining sequence is now [5]. rLEIterator.next(2); // exhausts 2 terms, returning -1. This is because the first term exhausted was 5, but the second term did not exist. Since the last term exhausted does not exist, we return -1. &nbsp; Constraints: 2 &lt;= encoding.length &lt;= 1000 encoding.length is even. 0 &lt;= encoding[i] &lt;= 109 1 &lt;= n &lt;= 109 At most 1000 calls will be made to next."
    },
    {
      "number": 901,
      "title": "Online Stock Span",
      "titleSlug": "online-stock-span",
      "difficulty": "Medium",
      "tags": [
        "Stack",
        "Design",
        "Monotonic Stack",
        "Data Stream"
      ],
      "description": "Design an algorithm that collects daily price quotes for some stock and returns the span of that stock&#39;s price for the current day. The span of the stock&#39;s price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day. For example, if the prices of the stock in the last four days is [7,2,1,2] and the price of the stock today is 2, then the span of today is 4 because starting from today, the price of the stock was less than or equal 2 for 4 consecutive days. Also, if the prices of the stock in the last four days is [7,34,1,2] and the price of the stock today is 8, then the span of today is 3 because starting from today, the price of the stock was less than or equal 8 for 3 consecutive days. Implement the StockSpanner class: StockSpanner() Initializes the object of the class. int next(int price) Returns the span of the stock&#39;s price given that today&#39;s price is price. &nbsp; Example 1: Input [&quot;StockSpanner&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;] [[], [100], [80], [60], [70], [60], [75], [85]] Output [null, 1, 1, 1, 2, 1, 4, 6] Explanation StockSpanner stockSpanner = new StockSpanner(); stockSpanner.next(100); // return 1 stockSpanner.next(80); // return 1 stockSpanner.next(60); // return 1 stockSpanner.next(70); // return 2 stockSpanner.next(60); // return 1 stockSpanner.next(75); // return 4, because the last 4 prices (including today&#39;s price of 75) were less than or equal to today&#39;s price. stockSpanner.next(85); // return 6 &nbsp; Constraints: 1 &lt;= price &lt;= 105 At most 104 calls will be made to next."
    },
    {
      "number": 902,
      "title": "Numbers At Most N Given Digit Set",
      "titleSlug": "numbers-at-most-n-given-digit-set",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "String",
        "Binary Search",
        "Dynamic Programming"
      ],
      "description": "Given an array of digits which is sorted in non-decreasing order. You can write numbers using each digits[i] as many times as we want. For example, if digits = [&#39;1&#39;,&#39;3&#39;,&#39;5&#39;], we may write numbers such as &#39;13&#39;, &#39;551&#39;, and &#39;1351315&#39;. Return the number of positive integers that can be generated that are less than or equal to a given integer n. &nbsp; Example 1: Input: digits = [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;], n = 100 Output: 20 Explanation: The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. Example 2: Input: digits = [&quot;1&quot;,&quot;4&quot;,&quot;9&quot;], n = 1000000000 Output: 29523 Explanation: We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits array. Example 3: Input: digits = [&quot;7&quot;], n = 8 Output: 1 &nbsp; Constraints: 1 &lt;= digits.length &lt;= 9 digits[i].length == 1 digits[i] is a digit from&nbsp;&#39;1&#39;&nbsp;to &#39;9&#39;. All the values in&nbsp;digits are unique. digits is sorted in&nbsp;non-decreasing order. 1 &lt;= n &lt;= 109"
    },
    {
      "number": 903,
      "title": "Valid Permutations for DI Sequence",
      "titleSlug": "valid-permutations-for-di-sequence",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming",
        "Prefix Sum"
      ],
      "description": "You are given a string s of length n where s[i] is either: &#39;D&#39; means decreasing, or &#39;I&#39; means increasing. A permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i: If s[i] == &#39;D&#39;, then perm[i] &gt; perm[i + 1], and If s[i] == &#39;I&#39;, then perm[i] &lt; perm[i + 1]. Return the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7. &nbsp; Example 1: Input: s = &quot;DID&quot; Output: 5 Explanation: The 5 valid permutations of (0, 1, 2, 3) are: (1, 0, 3, 2) (2, 0, 3, 1) (2, 1, 3, 0) (3, 0, 2, 1) (3, 1, 2, 0) Example 2: Input: s = &quot;D&quot; Output: 1 &nbsp; Constraints: n == s.length 1 &lt;= n &lt;= 200 s[i] is either &#39;I&#39; or &#39;D&#39;."
    },
    {
      "number": 904,
      "title": "Fruit Into Baskets",
      "titleSlug": "fruit-into-baskets",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Sliding Window"
      ],
      "description": "You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces. You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow: You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold. Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets. Once you reach a tree with fruit that cannot fit in your baskets, you must stop. Given the integer array fruits, return the maximum number of fruits you can pick. &nbsp; Example 1: Input: fruits = [1,2,1] Output: 3 Explanation: We can pick from all 3 trees. Example 2: Input: fruits = [0,1,2,2] Output: 3 Explanation: We can pick from trees [1,2,2]. If we had started at the first tree, we would only pick from trees [0,1]. Example 3: Input: fruits = [1,2,3,2,2] Output: 4 Explanation: We can pick from trees [2,3,2,2]. If we had started at the first tree, we would only pick from trees [1,2]. &nbsp; Constraints: 1 &lt;= fruits.length &lt;= 105 0 &lt;= fruits[i] &lt; fruits.length"
    },
    {
      "number": 905,
      "title": "Sort Array By Parity",
      "titleSlug": "sort-array-by-parity",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Two Pointers",
        "Sorting"
      ],
      "description": "Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition. &nbsp; Example 1: Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Example 2: Input: nums = [0] Output: [0] &nbsp; Constraints: 1 &lt;= nums.length &lt;= 5000 0 &lt;= nums[i] &lt;= 5000"
    },
    {
      "number": 906,
      "title": "Super Palindromes",
      "titleSlug": "super-palindromes",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "String",
        "Enumeration"
      ],
      "description": "Let&#39;s say a positive integer is a super-palindrome if it is a palindrome, and it is also the square of a palindrome. Given two positive integers left and right represented as strings, return the number of super-palindromes integers in the inclusive range [left, right]. &nbsp; Example 1: Input: left = &quot;4&quot;, right = &quot;1000&quot; Output: 4 Explanation: 4, 9, 121, and 484 are superpalindromes. Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome. Example 2: Input: left = &quot;1&quot;, right = &quot;2&quot; Output: 1 &nbsp; Constraints: 1 &lt;= left.length, right.length &lt;= 18 left and right consist of only digits. left and right cannot have leading zeros. left and right represent integers in the range [1, 1018 - 1]. left is less than or equal to right."
    },
    {
      "number": 907,
      "title": "Sum of Subarray Minimums",
      "titleSlug": "sum-of-subarray-minimums",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Stack",
        "Monotonic Stack"
      ],
      "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7. &nbsp; Example 1: Input: arr = [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1. Sum is 17. Example 2: Input: arr = [11,81,94,43,3] Output: 444 &nbsp; Constraints: 1 &lt;= arr.length &lt;= 3 * 104 1 &lt;= arr[i] &lt;= 3 * 104"
    },
    {
      "number": 908,
      "title": "Smallest Range I",
      "titleSlug": "smallest-range-i",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math"
      ],
      "description": "You are given an integer array nums and an integer k. In one operation, you can choose any index i where 0 &lt;= i &lt; nums.length and change nums[i] to nums[i] + x where x is an integer from the range [-k, k]. You can apply this operation at most once for each index i. The score of nums is the difference between the maximum and minimum elements in nums. Return the minimum score of nums after applying the mentioned operation at most once for each index in it. &nbsp; Example 1: Input: nums = [1], k = 0 Output: 0 Explanation: The score is max(nums) - min(nums) = 1 - 1 = 0. Example 2: Input: nums = [0,10], k = 2 Output: 6 Explanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) = 8 - 2 = 6. Example 3: Input: nums = [1,3,6], k = 3 Output: 0 Explanation: Change nums to be [4, 4, 4]. The score is max(nums) - min(nums) = 4 - 4 = 0. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 0 &lt;= nums[i] &lt;= 104 0 &lt;= k &lt;= 104"
    },
    {
      "number": 909,
      "title": "Snakes and Ladders",
      "titleSlug": "snakes-and-ladders",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row. You start on square 1 of the board. In each move, starting from square curr, do the following: Choose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)]. This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board. If next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next. The game ends when you reach the square n2. A board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 are not the starting points of any snake or ladder. Note that you only take a snake or ladder at most once per dice roll. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent&nbsp;snake or ladder. For example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4. Return the least number of dice rolls required to reach the square n2. If it is not possible to reach the square, return -1. &nbsp; Example 1: Input: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]] Output: 4 Explanation: In the beginning, you start at square 1 (at row 5, column 0). You decide to move to square 2 and must take the ladder to square 15. You then decide to move to square 17 and must take the snake to square 13. You then decide to move to square 14 and must take the ladder to square 35. You then decide to move to square 36, ending the game. This is the lowest possible number of moves to reach the last square, so return 4. Example 2: Input: board = [[-1,-1],[-1,3]] Output: 1 &nbsp; Constraints: n == board.length == board[i].length 2 &lt;= n &lt;= 20 board[i][j] is either -1 or in the range [1, n2]. The squares labeled 1 and n2 are not the starting points of any snake or ladder."
    },
    {
      "number": 910,
      "title": "Smallest Range II",
      "titleSlug": "smallest-range-ii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math",
        "Greedy",
        "Sorting"
      ],
      "description": "You are given an integer array nums and an integer k. For each index i where 0 &lt;= i &lt; nums.length, change nums[i] to be either nums[i] + k or nums[i] - k. The score of nums is the difference between the maximum and minimum elements in nums. Return the minimum score of nums after changing the values at each index. &nbsp; Example 1: Input: nums = [1], k = 0 Output: 0 Explanation: The score is max(nums) - min(nums) = 1 - 1 = 0. Example 2: Input: nums = [0,10], k = 2 Output: 6 Explanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) = 8 - 2 = 6. Example 3: Input: nums = [1,3,6], k = 3 Output: 3 Explanation: Change nums to be [4, 6, 3]. The score is max(nums) - min(nums) = 6 - 3 = 3. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 0 &lt;= nums[i] &lt;= 104 0 &lt;= k &lt;= 104"
    },
    {
      "number": 911,
      "title": "Online Election",
      "titleSlug": "online-election",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Binary Search",
        "Design"
      ],
      "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i]. For each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins. Implement the TopVotedCandidate class: TopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays. int q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules. &nbsp; Example 1: Input [&quot;TopVotedCandidate&quot;, &quot;q&quot;, &quot;q&quot;, &quot;q&quot;, &quot;q&quot;, &quot;q&quot;, &quot;q&quot;] [[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]] Output [null, 0, 1, 1, 0, 0, 1] Explanation TopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]); topVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading. topVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading. topVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.) topVotedCandidate.q(15); // return 0 topVotedCandidate.q(24); // return 0 topVotedCandidate.q(8); // return 1 &nbsp; Constraints: 1 &lt;= persons.length &lt;= 5000 times.length == persons.length 0 &lt;= persons[i] &lt; persons.length 0 &lt;= times[i] &lt;= 109 times is sorted in a strictly increasing order. times[0] &lt;= t &lt;= 109 At most 104 calls will be made to q."
    },
    {
      "number": 912,
      "title": "Sort an Array",
      "titleSlug": "sort-an-array",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Divide and Conquer",
        "Sorting",
        "Heap (Priority Queue)",
        "Merge Sort",
        "Bucket Sort",
        "Radix Sort",
        "Counting Sort"
      ],
      "description": "Given an array of integers nums, sort the array in ascending order and return it. You must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible. &nbsp; Example 1: Input: nums = [5,2,3,1] Output: [1,2,3,5] Explanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5). Example 2: Input: nums = [5,1,1,2,0,0] Output: [0,0,1,1,2,5] Explanation: Note that the values of nums are not necessairly unique. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 5 * 104 -5 * 104 &lt;= nums[i] &lt;= 5 * 104"
    },
    {
      "number": 913,
      "title": "Cat and Mouse",
      "titleSlug": "cat-and-mouse",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "Dynamic Programming",
        "Graph",
        "Topological Sort",
        "Memoization",
        "Game Theory"
      ],
      "description": "A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph. The mouse starts at node 1 and goes first, the cat starts at node 2 and goes second, and there is a hole at node 0. During each player&#39;s turn, they must travel along one&nbsp;edge of the graph that meets where they are.&nbsp; For example, if the Mouse is at node 1, it must travel to any node in graph[1]. Additionally, it is not allowed for the Cat to travel to the Hole (node 0). Then, the game can end in three&nbsp;ways: If ever the Cat occupies the same node as the Mouse, the Cat wins. If ever the Mouse reaches the Hole, the Mouse wins. If ever a position is repeated (i.e., the players are in the same position as a previous turn, and&nbsp;it is the same player&#39;s turn to move), the game is a draw. Given a graph, and assuming both players play optimally, return 1&nbsp;if the mouse wins the game, 2&nbsp;if the cat wins the game, or 0&nbsp;if the game is a draw. &nbsp; Example 1: Input: graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] Output: 0 Example 2: Input: graph = [[1,3],[0],[3],[0,2]] Output: 1 &nbsp; Constraints: 3 &lt;= graph.length &lt;= 50 1&nbsp;&lt;= graph[i].length &lt; graph.length 0 &lt;= graph[i][j] &lt; graph.length graph[i][j] != i graph[i] is unique. The mouse and the cat can always move.&nbsp;"
    },
    {
      "number": 914,
      "title": "X of a Kind in a Deck of Cards",
      "titleSlug": "x-of-a-kind-in-a-deck-of-cards",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Math",
        "Counting",
        "Number Theory"
      ],
      "description": "You are given an integer array deck where deck[i] represents the number written on the ith card. Partition the cards into one or more groups such that: Each group has exactly x cards where x &gt; 1, and All the cards in one group have the same integer written on them. Return true if such partition is possible, or false otherwise. &nbsp; Example 1: Input: deck = [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]. Example 2: Input: deck = [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition. &nbsp; Constraints: 1 &lt;= deck.length &lt;= 104 0 &lt;= deck[i] &lt; 104"
    },
    {
      "number": 915,
      "title": "Partition Array into Disjoint Intervals",
      "titleSlug": "partition-array-into-disjoint-intervals",
      "difficulty": "Medium",
      "tags": [
        "Array"
      ],
      "description": "Given an integer array nums, partition it into two (contiguous) subarrays left and right so that: Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size. Return the length of left after such a partitioning. Test cases are generated such that partitioning exists. &nbsp; Example 1: Input: nums = [5,0,3,8,6] Output: 3 Explanation: left = [5,0,3], right = [8,6] Example 2: Input: nums = [1,1,1,0,6,12] Output: 4 Explanation: left = [1,1,1,0], right = [6,12] &nbsp; Constraints: 2 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 106 There is at least one valid answer for the given input."
    },
    {
      "number": 916,
      "title": "Word Subsets",
      "titleSlug": "word-subsets",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "You are given two string arrays words1 and words2. A string b is a subset of string a if every letter in b occurs in a including multiplicity. For example, &quot;wrr&quot; is a subset of &quot;warrior&quot; but is not a subset of &quot;world&quot;. A string a from words1 is universal if for every string b in words2, b is a subset of a. Return an array of all the universal strings in words1. You may return the answer in any order. &nbsp; Example 1: Input: words1 = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], words2 = [&quot;e&quot;,&quot;o&quot;] Output: [&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;] Example 2: Input: words1 = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], words2 = [&quot;lc&quot;,&quot;eo&quot;] Output: [&quot;leetcode&quot;] Example 3: Input: words1 = [&quot;acaac&quot;,&quot;cccbb&quot;,&quot;aacbb&quot;,&quot;caacc&quot;,&quot;bcbbb&quot;], words2 = [&quot;c&quot;,&quot;cc&quot;,&quot;b&quot;] Output: [&quot;cccbb&quot;] &nbsp; Constraints: 1 &lt;= words1.length, words2.length &lt;= 104 1 &lt;= words1[i].length, words2[i].length &lt;= 10 words1[i] and words2[i] consist only of lowercase English letters. All the strings of words1 are unique."
    },
    {
      "number": 917,
      "title": "Reverse Only Letters",
      "titleSlug": "reverse-only-letters",
      "difficulty": "Easy",
      "tags": [
        "Two Pointers",
        "String"
      ],
      "description": "Given a string s, reverse the string according to the following rules: All the characters that are not English letters remain in the same position. All the English letters (lowercase or uppercase) should be reversed. Return s after reversing it. &nbsp; Example 1: Input: s = \"ab-cd\" Output: \"dc-ba\" Example 2: Input: s = \"a-bC-dEf-ghIj\" Output: \"j-Ih-gfE-dCba\" Example 3: Input: s = \"Test1ng-Leet=code-Q!\" Output: \"Qedo1ct-eeLg=ntse-T!\" &nbsp; Constraints: 1 &lt;= s.length &lt;= 100 s consists of characters with ASCII values in the range [33, 122]. s does not contain &#39;\\&quot;&#39; or &#39;\\\\&#39;."
    },
    {
      "number": 918,
      "title": "Maximum Sum Circular Subarray",
      "titleSlug": "maximum-sum-circular-subarray",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Divide and Conquer",
        "Dynamic Programming",
        "Queue",
        "Monotonic Queue"
      ],
      "description": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums. A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n]. A subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i &lt;= k1, k2 &lt;= j with k1 % n == k2 % n. &nbsp; Example 1: Input: nums = [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3. Example 2: Input: nums = [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10. Example 3: Input: nums = [-3,-2,-3] Output: -2 Explanation: Subarray [-2] has maximum sum -2. &nbsp; Constraints: n == nums.length 1 &lt;= n &lt;= 3 * 104 -3 * 104 &lt;= nums[i] &lt;= 3 * 104"
    },
    {
      "number": 919,
      "title": "Complete Binary Tree Inserter",
      "titleSlug": "complete-binary-tree-inserter",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Breadth-First Search",
        "Design",
        "Binary Tree"
      ],
      "description": "A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Design an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion. Implement the CBTInserter class: CBTInserter(TreeNode root) Initializes the data structure with the root of the complete binary tree. int insert(int v) Inserts a TreeNode into the tree with value Node.val == val so that the tree remains complete, and returns the value of the parent of the inserted TreeNode. TreeNode get_root() Returns the root node of the tree. &nbsp; Example 1: Input [&quot;CBTInserter&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;get_root&quot;] [[[1, 2]], [3], [4], []] Output [null, 1, 2, [1, 2, 3, 4]] Explanation CBTInserter cBTInserter = new CBTInserter([1, 2]); cBTInserter.insert(3); // return 1 cBTInserter.insert(4); // return 2 cBTInserter.get_root(); // return [1, 2, 3, 4] &nbsp; Constraints: The number of nodes in the tree will be in the range [1, 1000]. 0 &lt;= Node.val &lt;= 5000 root is a complete binary tree. 0 &lt;= val &lt;= 5000 At most 104 calls will be made to insert and get_root."
    },
    {
      "number": 920,
      "title": "Number of Music Playlists",
      "titleSlug": "number-of-music-playlists",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "Dynamic Programming",
        "Combinatorics"
      ],
      "description": "Your music player contains n different songs. You want to listen to goal songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that: Every song is played at least once. A song can only be played again only if k other songs have been played. Given n, goal, and k, return the number of possible playlists that you can create. Since the answer can be very large, return it modulo 109 + 7. &nbsp; Example 1: Input: n = 3, goal = 3, k = 1 Output: 6 Explanation: There are 6 possible playlists: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. Example 2: Input: n = 2, goal = 3, k = 0 Output: 6 Explanation: There are 6 possible playlists: [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], and [1, 2, 2]. Example 3: Input: n = 2, goal = 3, k = 1 Output: 2 Explanation: There are 2 possible playlists: [1, 2, 1] and [2, 1, 2]. &nbsp; Constraints: 0 &lt;= k &lt; n &lt;= goal &lt;= 100"
    },
    {
      "number": 921,
      "title": "Minimum Add to Make Parentheses Valid",
      "titleSlug": "minimum-add-to-make-parentheses-valid",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Stack",
        "Greedy"
      ],
      "description": "A parentheses string is valid if and only if: It is the empty string, It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. You are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string. For example, if s = &quot;()))&quot;, you can insert an opening parenthesis to be &quot;(()))&quot; or a closing parenthesis to be &quot;())))&quot;. Return the minimum number of moves required to make s valid. &nbsp; Example 1: Input: s = &quot;())&quot; Output: 1 Example 2: Input: s = &quot;(((&quot; Output: 3 &nbsp; Constraints: 1 &lt;= s.length &lt;= 1000 s[i] is either &#39;(&#39; or &#39;)&#39;."
    },
    {
      "number": 922,
      "title": "Sort Array By Parity II",
      "titleSlug": "sort-array-by-parity-ii",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Two Pointers",
        "Sorting"
      ],
      "description": "Given an array of integers nums, half of the integers in nums are odd, and the other half are even. Sort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even. Return any answer array that satisfies this condition. &nbsp; Example 1: Input: nums = [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted. Example 2: Input: nums = [2,3] Output: [2,3] &nbsp; Constraints: 2 &lt;= nums.length &lt;= 2 * 104 nums.length is even. Half of the integers in nums are even. 0 &lt;= nums[i] &lt;= 1000 &nbsp; Follow Up: Could you solve it in-place?"
    },
    {
      "number": 923,
      "title": "3Sum With Multiplicity",
      "titleSlug": "3sum-with-multiplicity",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Two Pointers",
        "Sorting",
        "Counting"
      ],
      "description": "Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i &lt; j &lt; k and arr[i] + arr[j] + arr[k] == target. As the answer can be very large, return it modulo 109 + 7. &nbsp; Example 1: Input: arr = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation: Enumerating by the values (arr[i], arr[j], arr[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times. Example 2: Input: arr = [1,1,2,2,2,2], target = 5 Output: 12 Explanation: arr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times: We choose one 1 from [1,1] in 2 ways, and two 2s from [2,2,2,2] in 6 ways. Example 3: Input: arr = [2,1,3], target = 6 Output: 1 Explanation: (1, 2, 3) occured one time in the array so we return 1. &nbsp; Constraints: 3 &lt;= arr.length &lt;= 3000 0 &lt;= arr[i] &lt;= 100 0 &lt;= target &lt;= 300"
    },
    {
      "number": 924,
      "title": "Minimize Malware Spread",
      "titleSlug": "minimize-malware-spread",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Graph"
      ],
      "description": "You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1. Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial. Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread. &nbsp; Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0 Example 2: Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0 Example 3: Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1 &nbsp; Constraints: n == graph.length n == graph[i].length 2 &lt;= n &lt;= 300 graph[i][j] is 0 or 1. graph[i][j] == graph[j][i] graph[i][i] == 1 1 &lt;= initial.length &lt;= n 0 &lt;= initial[i] &lt;= n - 1 All the integers in initial are unique."
    },
    {
      "number": 925,
      "title": "Long Pressed Name",
      "titleSlug": "long-pressed-name",
      "difficulty": "Easy",
      "tags": [
        "Two Pointers",
        "String"
      ],
      "description": "Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed. &nbsp; Example 1: Input: name = &quot;alex&quot;, typed = &quot;aaleex&quot; Output: true Explanation: &#39;a&#39; and &#39;e&#39; in &#39;alex&#39; were long pressed. Example 2: Input: name = &quot;saeed&quot;, typed = &quot;ssaaedd&quot; Output: false Explanation: &#39;e&#39; must have been pressed twice, but it was not in the typed output. &nbsp; Constraints: 1 &lt;= name.length, typed.length &lt;= 1000 name and typed consist of only lowercase English letters."
    },
    {
      "number": 926,
      "title": "Flip String to Monotone Increasing",
      "titleSlug": "flip-string-to-monotone-increasing",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "A binary string is monotone increasing if it consists of some number of 0&#39;s (possibly none), followed by some number of 1&#39;s (also possibly none). You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0. Return the minimum number of flips to make s monotone increasing. &nbsp; Example 1: Input: s = &quot;00110&quot; Output: 1 Explanation: We flip the last digit to get 00111. Example 2: Input: s = &quot;010110&quot; Output: 2 Explanation: We flip to get 011111, or alternatively 000111. Example 3: Input: s = &quot;00011000&quot; Output: 2 Explanation: We flip to get 00000000. &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s[i] is either &#39;0&#39; or &#39;1&#39;."
    },
    {
      "number": 927,
      "title": "Three Equal Parts",
      "titleSlug": "three-equal-parts",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math"
      ],
      "description": "You are given an array arr which consists of only zeros and ones, divide the array into three non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i + 1 &lt; j, such that: arr[0], arr[1], ..., arr[i] is the first part, arr[i + 1], arr[i + 2], ..., arr[j - 1] is the second part, and arr[j], arr[j + 1], ..., arr[arr.length - 1] is the third part. All three parts have equal binary values. If it is not possible, return [-1, -1]. Note that the entire part is used when considering what binary value it represents. For example, [1,1,0] represents 6 in decimal, not 3. Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value. &nbsp; Example 1: Input: arr = [1,0,1,0,1] Output: [0,3] Example 2: Input: arr = [1,1,0,1,1] Output: [-1,-1] Example 3: Input: arr = [1,1,0,0,1] Output: [0,2] &nbsp; Constraints: 3 &lt;= arr.length &lt;= 3 * 104 arr[i] is 0 or 1"
    },
    {
      "number": 928,
      "title": "Minimize Malware Spread II",
      "titleSlug": "minimize-malware-spread-ii",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Graph"
      ],
      "description": "You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1. Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial, completely removing it and any connections from this node to any other node. Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. &nbsp; Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0 Example 2: Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1 Example 3: Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1 &nbsp; Constraints: n == graph.length n == graph[i].length 2 &lt;= n &lt;= 300 graph[i][j] is 0 or 1. graph[i][j] == graph[j][i] graph[i][i] == 1 1 &lt;= initial.length &lt;&nbsp;n 0 &lt;= initial[i] &lt;= n - 1 All the integers in initial are unique."
    },
    {
      "number": 929,
      "title": "Unique Email Addresses",
      "titleSlug": "unique-email-addresses",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "Every valid email consists of a local name and a domain name, separated by the &#39;@&#39; sign. Besides lowercase letters, the email may contain one or more &#39;.&#39; or &#39;+&#39;. For example, in &quot;alice@leetcode.com&quot;, &quot;alice&quot; is the local name, and &quot;leetcode.com&quot; is the domain name. If you add periods &#39;.&#39; between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names. For example, &quot;alice.z@leetcode.com&quot; and &quot;alicez@leetcode.com&quot; forward to the same email address. If you add a plus &#39;+&#39; in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names. For example, &quot;m.y+name@email.com&quot; will be forwarded to &quot;my@email.com&quot;. It is possible to use both of these rules at the same time. Given an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails. &nbsp; Example 1: Input: emails = [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;] Output: 2 Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails. Example 2: Input: emails = [&quot;a@leetcode.com&quot;,&quot;b@leetcode.com&quot;,&quot;c@leetcode.com&quot;] Output: 3 &nbsp; Constraints: 1 &lt;= emails.length &lt;= 100 1 &lt;= emails[i].length &lt;= 100 emails[i] consist of lowercase English letters, &#39;+&#39;, &#39;.&#39; and &#39;@&#39;. Each emails[i] contains exactly one &#39;@&#39; character. All local and domain names are non-empty. Local names do not start with a &#39;+&#39; character. Domain names end with the &quot;.com&quot; suffix. Domain names must contain at least one character before &quot;.com&quot; suffix."
    },
    {
      "number": 930,
      "title": "Binary Subarrays With Sum",
      "titleSlug": "binary-subarrays-with-sum",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Sliding Window",
        "Prefix Sum"
      ],
      "description": "Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal. A subarray is a contiguous part of the array. &nbsp; Example 1: Input: nums = [1,0,1,0,1], goal = 2 Output: 4 Explanation: The 4 subarrays are bolded and underlined below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] Example 2: Input: nums = [0,0,0,0,0], goal = 0 Output: 15 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 3 * 104 nums[i] is either 0 or 1. 0 &lt;= goal &lt;= nums.length"
    },
    {
      "number": 931,
      "title": "Minimum Falling Path Sum",
      "titleSlug": "minimum-falling-path-sum",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Matrix"
      ],
      "description": "Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix. A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1). &nbsp; Example 1: Input: matrix = [[2,1,3],[6,5,4],[7,8,9]] Output: 13 Explanation: There are two falling paths with a minimum sum as shown. Example 2: Input: matrix = [[-19,57],[-40,-5]] Output: -59 Explanation: The falling path with a minimum sum is shown. &nbsp; Constraints: n == matrix.length == matrix[i].length 1 &lt;= n &lt;= 100 -100 &lt;= matrix[i][j] &lt;= 100"
    },
    {
      "number": 932,
      "title": "Beautiful Array",
      "titleSlug": "beautiful-array",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math",
        "Divide and Conquer"
      ],
      "description": "An array nums of length n is beautiful if: nums is a permutation of the integers in the range [1, n]. For every 0 &lt;= i &lt; j &lt; n, there is no index k with i &lt; k &lt; j where 2 * nums[k] == nums[i] + nums[j]. Given the integer n, return any beautiful array nums of length n. There will be at least one valid answer for the given n. &nbsp; Example 1: Input: n = 4 Output: [2,1,4,3] Example 2: Input: n = 5 Output: [3,1,2,5,4] &nbsp; Constraints: 1 &lt;= n &lt;= 1000"
    },
    {
      "number": 933,
      "title": "Number of Recent Calls",
      "titleSlug": "number-of-recent-calls",
      "difficulty": "Easy",
      "tags": [
        "Design",
        "Queue",
        "Data Stream"
      ],
      "description": "You have a RecentCounter class which counts the number of recent requests within a certain time frame. Implement the RecentCounter class: RecentCounter() Initializes the counter with zero recent requests. int ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range [t - 3000, t]. It is guaranteed that every call to ping uses a strictly larger value of t than the previous call. &nbsp; Example 1: Input [&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;] [[], [1], [100], [3001], [3002]] Output [null, 1, 2, 3, 3] Explanation RecentCounter recentCounter = new RecentCounter(); recentCounter.ping(1); // requests = [1], range is [-2999,1], return 1 recentCounter.ping(100); // requests = [1, 100], range is [-2900,100], return 2 recentCounter.ping(3001); // requests = [1, 100, 3001], range is [1,3001], return 3 recentCounter.ping(3002); // requests = [1, 100, 3001, 3002], range is [2,3002], return 3 &nbsp; Constraints: 1 &lt;= t &lt;= 109 Each test case will call ping with strictly increasing values of t. At most 104 calls will be made to ping."
    },
    {
      "number": 934,
      "title": "Shortest Bridge",
      "titleSlug": "shortest-bridge",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Depth-First Search",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water. An island is a 4-directionally connected group of 1&#39;s not connected to any other 1&#39;s. There are exactly two islands in grid. You may change 0&#39;s to 1&#39;s to connect the two islands to form one island. Return the smallest number of 0&#39;s you must flip to connect the two islands. &nbsp; Example 1: Input: grid = [[0,1],[1,0]] Output: 1 Example 2: Input: grid = [[0,1,0],[0,0,0],[0,0,1]] Output: 2 Example 3: Input: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] Output: 1 &nbsp; Constraints: n == grid.length == grid[i].length 2 &lt;= n &lt;= 100 grid[i][j] is either 0 or 1. There are exactly two islands in grid."
    },
    {
      "number": 935,
      "title": "Knight Dialer",
      "titleSlug": "knight-dialer",
      "difficulty": "Medium",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "The chess knight has a unique movement,&nbsp;it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagram: A chess knight can move as indicated in the chess diagram below: We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell&nbsp;(i.e. blue cell). Given an integer n, return how many distinct phone numbers of length n we can dial. You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps. As the answer may be very large, return the answer modulo 109 + 7. &nbsp; Example 1: Input: n = 1 Output: 10 Explanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient. Example 2: Input: n = 2 Output: 20 Explanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94] Example 3: Input: n = 3131 Output: 136006598 Explanation: Please take care of the mod. &nbsp; Constraints: 1 &lt;= n &lt;= 5000"
    },
    {
      "number": 936,
      "title": "Stamping The Sequence",
      "titleSlug": "stamping-the-sequence",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Stack",
        "Greedy",
        "Queue"
      ],
      "description": "You are given two strings stamp and target. Initially, there is a string s of length target.length with all s[i] == &#39;?&#39;. In one turn, you can place stamp over s and replace every letter in the s with the corresponding letter from stamp. For example, if stamp = &quot;abc&quot; and target = &quot;abcba&quot;, then s is &quot;?????&quot; initially. In one turn you can: place stamp at index 0 of s to obtain &quot;abc??&quot;, place stamp at index 1 of s to obtain &quot;?abc?&quot;, or place stamp at index 2 of s to obtain &quot;??abc&quot;. Note that stamp must be fully contained in the boundaries of s in order to stamp (i.e., you cannot place stamp at index 3 of s). We want to convert s to target using at most 10 * target.length turns. Return an array of the index of the left-most letter being stamped at each turn. If we cannot obtain target from s within 10 * target.length turns, return an empty array. &nbsp; Example 1: Input: stamp = &quot;abc&quot;, target = &quot;ababc&quot; Output: [0,2] Explanation: Initially s = &quot;?????&quot;. - Place stamp at index 0 to get &quot;abc??&quot;. - Place stamp at index 2 to get &quot;ababc&quot;. [1,0,2] would also be accepted as an answer, as well as some other answers. Example 2: Input: stamp = &quot;abca&quot;, target = &quot;aabcaca&quot; Output: [3,0,1] Explanation: Initially s = &quot;???????&quot;. - Place stamp at index 3 to get &quot;???abca&quot;. - Place stamp at index 0 to get &quot;abcabca&quot;. - Place stamp at index 1 to get &quot;aabcaca&quot;. &nbsp; Constraints: 1 &lt;= stamp.length &lt;= target.length &lt;= 1000 stamp and target consist of lowercase English letters."
    },
    {
      "number": 937,
      "title": "Reorder Data in Log Files",
      "titleSlug": "reorder-data-in-log-files",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "String",
        "Sorting"
      ],
      "description": "You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier. There are two types of logs: Letter-logs: All words (except the identifier) consist of lowercase English letters. Digit-logs: All words (except the identifier) consist of digits. Reorder these logs so that: The letter-logs come before all digit-logs. The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers. The digit-logs maintain their relative ordering. Return the final order of the logs. &nbsp; Example 1: Input: logs = [&quot;dig1 8 1 5 1&quot;,&quot;let1 art can&quot;,&quot;dig2 3 6&quot;,&quot;let2 own kit dig&quot;,&quot;let3 art zero&quot;] Output: [&quot;let1 art can&quot;,&quot;let3 art zero&quot;,&quot;let2 own kit dig&quot;,&quot;dig1 8 1 5 1&quot;,&quot;dig2 3 6&quot;] Explanation: The letter-log contents are all different, so their ordering is &quot;art can&quot;, &quot;art zero&quot;, &quot;own kit dig&quot;. The digit-logs have a relative order of &quot;dig1 8 1 5 1&quot;, &quot;dig2 3 6&quot;. Example 2: Input: logs = [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;] Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;] &nbsp; Constraints: 1 &lt;= logs.length &lt;= 100 3 &lt;= logs[i].length &lt;= 100 All the tokens of logs[i] are separated by a single space. logs[i] is guaranteed to have an identifier and at least one word after the identifier."
    },
    {
      "number": 938,
      "title": "Range Sum of BST",
      "titleSlug": "range-sum-of-bst",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high]. &nbsp; Example 1: Input: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32. Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10 Output: 23 Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23. &nbsp; Constraints: The number of nodes in the tree is in the range [1, 2 * 104]. 1 &lt;= Node.val &lt;= 105 1 &lt;= low &lt;= high &lt;= 105 All Node.val are unique."
    },
    {
      "number": 939,
      "title": "Minimum Area Rectangle",
      "titleSlug": "minimum-area-rectangle",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Math",
        "Geometry",
        "Sorting"
      ],
      "description": "You are given an array of points in the X-Y plane points where points[i] = [xi, yi]. Return the minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes. If there is not any such rectangle, return 0. &nbsp; Example 1: Input: points = [[1,1],[1,3],[3,1],[3,3],[2,2]] Output: 4 Example 2: Input: points = [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] Output: 2 &nbsp; Constraints: 1 &lt;= points.length &lt;= 500 points[i].length == 2 0 &lt;= xi, yi &lt;= 4 * 104 All the given points are unique."
    },
    {
      "number": 940,
      "title": "Distinct Subsequences II",
      "titleSlug": "distinct-subsequences-ii",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "Given a string s, return the number of distinct non-empty subsequences of s. Since the answer may be very large, return it modulo 109 + 7. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not. &nbsp; Example 1: Input: s = &quot;abc&quot; Output: 7 Explanation: The 7 distinct subsequences are &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;, and &quot;abc&quot;. Example 2: Input: s = &quot;aba&quot; Output: 6 Explanation: The 6 distinct subsequences are &quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;aa&quot;, &quot;ba&quot;, and &quot;aba&quot;. Example 3: Input: s = &quot;aaa&quot; Output: 3 Explanation: The 3 distinct subsequences are &quot;a&quot;, &quot;aa&quot; and &quot;aaa&quot;. &nbsp; Constraints: 1 &lt;= s.length &lt;= 2000 s consists of lowercase English letters."
    },
    {
      "number": 941,
      "title": "Valid Mountain Array",
      "titleSlug": "valid-mountain-array",
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "description": "Given an array of integers arr, return true if and only if it is a valid mountain array. Recall that arr is a mountain array if and only if: arr.length &gt;= 3 There exists some i with 0 &lt; i &lt; arr.length - 1 such that: arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i] arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] &nbsp; Example 1: Input: arr = [2,1] Output: false Example 2: Input: arr = [3,5,5] Output: false Example 3: Input: arr = [0,3,2,1] Output: true &nbsp; Constraints: 1 &lt;= arr.length &lt;= 104 0 &lt;= arr[i] &lt;= 104"
    },
    {
      "number": 942,
      "title": "DI String Match",
      "titleSlug": "di-string-match",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Two Pointers",
        "String",
        "Greedy"
      ],
      "description": "A permutation perm of n + 1 integers of all the integers in the range [0, n] can be represented as a string s of length n where: s[i] == &#39;I&#39; if perm[i] &lt; perm[i + 1], and s[i] == &#39;D&#39; if perm[i] &gt; perm[i + 1]. Given a string s, reconstruct the permutation perm and return it. If there are multiple valid permutations perm, return any of them. &nbsp; Example 1: Input: s = \"IDID\" Output: [0,4,1,3,2] Example 2: Input: s = \"III\" Output: [0,1,2,3] Example 3: Input: s = \"DDI\" Output: [3,2,0,1] &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s[i] is either &#39;I&#39; or &#39;D&#39;."
    },
    {
      "number": 943,
      "title": "Find the Shortest Superstring",
      "titleSlug": "find-the-shortest-superstring",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "String",
        "Dynamic Programming",
        "Bit Manipulation",
        "Bitmask"
      ],
      "description": "Given an array of strings words, return the smallest string that contains each string in words as a substring. If there are multiple valid strings of the smallest length, return any of them. You may assume that no string in words is a substring of another string in words. &nbsp; Example 1: Input: words = [&quot;alex&quot;,&quot;loves&quot;,&quot;leetcode&quot;] Output: &quot;alexlovesleetcode&quot; Explanation: All permutations of &quot;alex&quot;,&quot;loves&quot;,&quot;leetcode&quot; would also be accepted. Example 2: Input: words = [&quot;catg&quot;,&quot;ctaagt&quot;,&quot;gcta&quot;,&quot;ttca&quot;,&quot;atgcatc&quot;] Output: &quot;gctaagttcatgcatc&quot; &nbsp; Constraints: 1 &lt;= words.length &lt;= 12 1 &lt;= words[i].length &lt;= 20 words[i] consists of lowercase English letters. All the strings of words are unique."
    },
    {
      "number": 944,
      "title": "Delete Columns to Make Sorted",
      "titleSlug": "delete-columns-to-make-sorted",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "String"
      ],
      "description": "You are given an array of n strings strs, all of the same length. The strings can be arranged such that there is one on each line, making a grid. For example, strs = [&quot;abc&quot;, &quot;bce&quot;, &quot;cae&quot;] can be arranged as follows: abc bce cae You want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) and 2 (&#39;c&#39;, &#39;e&#39;, &#39;e&#39;) are sorted, while column 1 (&#39;b&#39;, &#39;c&#39;, &#39;a&#39;) is not, so you would delete column 1. Return the number of columns that you will delete. &nbsp; Example 1: Input: strs = [&quot;cba&quot;,&quot;daf&quot;,&quot;ghi&quot;] Output: 1 Explanation: The grid looks as follows: cba daf ghi Columns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column. Example 2: Input: strs = [&quot;a&quot;,&quot;b&quot;] Output: 0 Explanation: The grid looks as follows: a b Column 0 is the only column and is sorted, so you will not delete any columns. Example 3: Input: strs = [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;] Output: 3 Explanation: The grid looks as follows: zyx wvu tsr All 3 columns are not sorted, so you will delete all 3. &nbsp; Constraints: n == strs.length 1 &lt;= n &lt;= 100 1 &lt;= strs[i].length &lt;= 1000 strs[i] consists of lowercase English letters."
    },
    {
      "number": 945,
      "title": "Minimum Increment to Make Array Unique",
      "titleSlug": "minimum-increment-to-make-array-unique",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Greedy",
        "Sorting",
        "Counting"
      ],
      "description": "You are given an integer array nums. In one move, you can pick an index i where 0 &lt;= i &lt; nums.length and increment nums[i] by 1. Return the minimum number of moves to make every value in nums unique. The test cases are generated so that the answer fits in a 32-bit integer. &nbsp; Example 1: Input: nums = [1,2,2] Output: 1 Explanation: After 1 move, the array could be [1, 2, 3]. Example 2: Input: nums = [3,2,1,2,1,7] Output: 6 Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7]. It can be shown that it is impossible for the array to have all unique values with 5 or less moves. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 105"
    },
    {
      "number": 946,
      "title": "Validate Stack Sequences",
      "titleSlug": "validate-stack-sequences",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Stack",
        "Simulation"
      ],
      "description": "Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise. &nbsp; Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -&gt; 4, push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. &nbsp; Constraints: 1 &lt;= pushed.length &lt;= 1000 0 &lt;= pushed[i] &lt;= 1000 All the elements of pushed are unique. popped.length == pushed.length popped is a permutation of pushed."
    },
    {
      "number": 947,
      "title": "Most Stones Removed with Same Row or Column",
      "titleSlug": "most-stones-removed-with-same-row-or-column",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Depth-First Search",
        "Union Find",
        "Graph"
      ],
      "description": "On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone. A stone can be removed if it shares either the same row or the same column as another stone that has not been removed. Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed. &nbsp; Example 1: Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5 Explanation: One way to remove 5 stones is as follows: 1. Remove stone [2,2] because it shares the same row as [2,1]. 2. Remove stone [2,1] because it shares the same column as [0,1]. 3. Remove stone [1,2] because it shares the same row as [1,0]. 4. Remove stone [1,0] because it shares the same column as [0,0]. 5. Remove stone [0,1] because it shares the same row as [0,0]. Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane. Example 2: Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output: 3 Explanation: One way to make 3 moves is as follows: 1. Remove stone [2,2] because it shares the same row as [2,0]. 2. Remove stone [2,0] because it shares the same column as [0,0]. 3. Remove stone [0,2] because it shares the same row as [0,0]. Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane. Example 3: Input: stones = [[0,0]] Output: 0 Explanation: [0,0] is the only stone on the plane, so you cannot remove it. &nbsp; Constraints: 1 &lt;= stones.length &lt;= 1000 0 &lt;= xi, yi &lt;= 104 No two stones are at the same coordinate point."
    },
    {
      "number": 948,
      "title": "Bag of Tokens",
      "titleSlug": "bag-of-tokens",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Greedy",
        "Sorting"
      ],
      "description": "You start with an initial power of power, an initial score of 0, and a bag of tokens given as an integer array tokens, where each&nbsp;tokens[i] denotes the value of tokeni. Your goal is to maximize the total score by strategically playing these tokens. In one move, you can play an unplayed token in one of the two ways (but not both for the same token): Face-up: If your current power is at least tokens[i], you may play tokeni, losing tokens[i] power and gaining 1 score. Face-down: If your current score is at least 1, you may play tokeni, gaining tokens[i] power and losing 1 score. Return the maximum possible score you can achieve after playing any number of tokens. &nbsp; Example 1: Input: tokens = [100], power = 50 Output: 0 Explanation: Since your score is 0 initially, you cannot play the token face-down. You also cannot play it face-up since your power (50) is less than tokens[0]&nbsp;(100). Example 2: Input: tokens = [200,100], power = 150 Output: 1 Explanation: Play token1 (100) face-up, reducing your power to&nbsp;50 and increasing your score to&nbsp;1. There is no need to play token0, since you cannot play it face-up to add to your score. The maximum score achievable is 1. Example 3: Input: tokens = [100,200,300,400], power = 200 Output: 2 Explanation: Play the tokens in this order to get a score of 2: Play token0 (100) face-up, reducing power to 100 and increasing score to 1. Play token3 (400) face-down, increasing power to 500 and reducing score to 0. Play token1 (200) face-up, reducing power to 300 and increasing score to 1. Play token2 (300) face-up, reducing power to 0 and increasing score to 2. The maximum score achievable is 2. &nbsp; Constraints: 0 &lt;= tokens.length &lt;= 1000 0 &lt;= tokens[i], power &lt; 104"
    },
    {
      "number": 949,
      "title": "Largest Time for Given Digits",
      "titleSlug": "largest-time-for-given-digits",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "String",
        "Backtracking",
        "Enumeration"
      ],
      "description": "Given an array arr of 4 digits, find the latest 24-hour time that can be made using each digit exactly once. 24-hour times are formatted as &quot;HH:MM&quot;, where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59. Return the latest 24-hour time in &quot;HH:MM&quot; format. If no valid time can be made, return an empty string. &nbsp; Example 1: Input: arr = [1,2,3,4] Output: &quot;23:41&quot; Explanation: The valid 24-hour times are &quot;12:34&quot;, &quot;12:43&quot;, &quot;13:24&quot;, &quot;13:42&quot;, &quot;14:23&quot;, &quot;14:32&quot;, &quot;21:34&quot;, &quot;21:43&quot;, &quot;23:14&quot;, and &quot;23:41&quot;. Of these times, &quot;23:41&quot; is the latest. Example 2: Input: arr = [5,5,5,5] Output: &quot;&quot; Explanation: There are no valid 24-hour times as &quot;55:55&quot; is not valid. &nbsp; Constraints: arr.length == 4 0 &lt;= arr[i] &lt;= 9"
    },
    {
      "number": 950,
      "title": "Reveal Cards In Increasing Order",
      "titleSlug": "reveal-cards-in-increasing-order",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Queue",
        "Sorting",
        "Simulation"
      ],
      "description": "You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i]. You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. You will do the following steps repeatedly until all cards are revealed: Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck then put the next top card of the deck at the bottom of the deck. If there are still unrevealed cards, go back to step 1. Otherwise, stop. Return an ordering of the deck that would reveal the cards in increasing order. Note that the first entry in the answer is considered to be the top of the deck. &nbsp; Example 1: Input: deck = [17,13,11,2,3,5,7] Output: [2,13,3,11,5,17,7] Explanation: We get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it. After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck. We reveal 2, and move 13 to the bottom. The deck is now [3,11,5,17,7,13]. We reveal 3, and move 11 to the bottom. The deck is now [5,17,7,13,11]. We reveal 5, and move 17 to the bottom. The deck is now [7,13,11,17]. We reveal 7, and move 13 to the bottom. The deck is now [11,17,13]. We reveal 11, and move 17 to the bottom. The deck is now [13,17]. We reveal 13, and move 17 to the bottom. The deck is now [17]. We reveal 17. Since all the cards revealed are in increasing order, the answer is correct. Example 2: Input: deck = [1,1000] Output: [1,1000] &nbsp; Constraints: 1 &lt;= deck.length &lt;= 1000 1 &lt;= deck[i] &lt;= 106 All the values of deck are unique."
    },
    {
      "number": 951,
      "title": "Flip Equivalent Binary Trees",
      "titleSlug": "flip-equivalent-binary-trees",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X&nbsp;is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations. Given the roots of two binary trees root1 and root2, return true if the two trees are flip equivalent or false otherwise. &nbsp; Example 1: Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] Output: true Explanation: We flipped at nodes with values 1, 3, and 5. Example 2: Input: root1 = [], root2 = [] Output: true Example 3: Input: root1 = [], root2 = [1] Output: false &nbsp; Constraints: The number of nodes in each tree is in the range [0, 100]. Each tree will have unique node values in the range [0, 99]."
    },
    {
      "number": 952,
      "title": "Largest Component Size by Common Factor",
      "titleSlug": "largest-component-size-by-common-factor",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Math",
        "Union Find",
        "Number Theory"
      ],
      "description": "You are given an integer array of unique positive integers nums. Consider the following graph: There are nums.length nodes, labeled nums[0] to nums[nums.length - 1], There is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1. Return the size of the largest connected component in the graph. &nbsp; Example 1: Input: nums = [4,6,15,35] Output: 4 Example 2: Input: nums = [20,50,9,63] Output: 2 Example 3: Input: nums = [2,3,6,7,4,12,21,39] Output: 8 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 2 * 104 1 &lt;= nums[i] &lt;= 105 All the values of nums are unique."
    },
    {
      "number": 953,
      "title": "Verifying an Alien Dictionary",
      "titleSlug": "verifying-an-alien-dictionary",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language. &nbsp; Example 1: Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot; Output: true Explanation: As &#39;h&#39; comes before &#39;l&#39; in this language, then the sequence is sorted. Example 2: Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot; Output: false Explanation: As &#39;d&#39; comes after &#39;l&#39; in this language, then words[0] &gt; words[1], hence the sequence is unsorted. Example 3: Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot; Output: false Explanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &#39;l&#39; &gt; &#39;&empty;&#39;, where &#39;&empty;&#39; is defined as the blank character which is less than any other character (More info). &nbsp; Constraints: 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 20 order.length == 26 All characters in words[i] and order are English lowercase letters."
    },
    {
      "number": 954,
      "title": "Array of Doubled Pairs",
      "titleSlug": "array-of-doubled-pairs",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Greedy",
        "Sorting"
      ],
      "description": "Given an integer array of even length arr, return true if it is possible to reorder arr such that arr[2 * i + 1] = 2 * arr[2 * i] for every 0 &lt;= i &lt; len(arr) / 2, or false otherwise. &nbsp; Example 1: Input: arr = [3,1,3,6] Output: false Example 2: Input: arr = [2,1,2,6] Output: false Example 3: Input: arr = [4,-2,2,-4] Output: true Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4]. &nbsp; Constraints: 2 &lt;= arr.length &lt;= 3 * 104 arr.length is even. -105 &lt;= arr[i] &lt;= 105"
    },
    {
      "number": 955,
      "title": "Delete Columns to Make Sorted II",
      "titleSlug": "delete-columns-to-make-sorted-ii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "String",
        "Greedy"
      ],
      "description": "You are given an array of n strings strs, all of the same length. We may choose any deletion indices, and we delete all the characters in those indices for each string. For example, if we have strs = [&quot;abcdef&quot;,&quot;uvwxyz&quot;] and deletion indices {0, 2, 3}, then the final array after deletions is [&quot;bef&quot;, &quot;vyz&quot;]. Suppose we chose a set of deletion indices answer such that after deletions, the final array has its elements in lexicographic order (i.e., strs[0] &lt;= strs[1] &lt;= strs[2] &lt;= ... &lt;= strs[n - 1]). Return the minimum possible value of answer.length. &nbsp; Example 1: Input: strs = [&quot;ca&quot;,&quot;bb&quot;,&quot;ac&quot;] Output: 1 Explanation: After deleting the first column, strs = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]. Now strs is in lexicographic order (ie. strs[0] &lt;= strs[1] &lt;= strs[2]). We require at least 1 deletion since initially strs was not in lexicographic order, so the answer is 1. Example 2: Input: strs = [&quot;xc&quot;,&quot;yb&quot;,&quot;za&quot;] Output: 0 Explanation: strs is already in lexicographic order, so we do not need to delete anything. Note that the rows of strs are not necessarily in lexicographic order: i.e., it is NOT necessarily true that (strs[0][0] &lt;= strs[0][1] &lt;= ...) Example 3: Input: strs = [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;] Output: 3 Explanation: We have to delete every column. &nbsp; Constraints: n == strs.length 1 &lt;= n &lt;= 100 1 &lt;= strs[i].length &lt;= 100 strs[i] consists of lowercase English letters."
    },
    {
      "number": 956,
      "title": "Tallest Billboard",
      "titleSlug": "tallest-billboard",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height. You are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6. Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0. &nbsp; Example 1: Input: rods = [1,2,3,6] Output: 6 Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6. Example 2: Input: rods = [1,2,3,4,5,6] Output: 10 Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10. Example 3: Input: rods = [1,2] Output: 0 Explanation: The billboard cannot be supported, so we return 0. &nbsp; Constraints: 1 &lt;= rods.length &lt;= 20 1 &lt;= rods[i] &lt;= 1000 sum(rods[i]) &lt;= 5000"
    },
    {
      "number": 957,
      "title": "Prison Cells After N Days",
      "titleSlug": "prison-cells-after-n-days",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Math",
        "Bit Manipulation"
      ],
      "description": "There are 8 prison cells in a row and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules: If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant. Note that because the prison is a row, the first and the last cells in the row can&#39;t have two adjacent neighbors. You are given an integer array cells where cells[i] == 1 if the ith cell is occupied and cells[i] == 0 if the ith cell is vacant, and you are given an integer n. Return the state of the prison after n days (i.e., n such changes described above). &nbsp; Example 1: Input: cells = [0,1,0,1,1,0,0,1], n = 7 Output: [0,0,1,1,0,0,0,0] Explanation: The following table summarizes the state of the prison on each day: Day 0: [0, 1, 0, 1, 1, 0, 0, 1] Day 1: [0, 1, 1, 0, 0, 0, 0, 0] Day 2: [0, 0, 0, 0, 1, 1, 1, 0] Day 3: [0, 1, 1, 0, 0, 1, 0, 0] Day 4: [0, 0, 0, 0, 0, 1, 0, 0] Day 5: [0, 1, 1, 1, 0, 1, 0, 0] Day 6: [0, 0, 1, 0, 1, 1, 0, 0] Day 7: [0, 0, 1, 1, 0, 0, 0, 0] Example 2: Input: cells = [1,0,0,1,0,0,1,0], n = 1000000000 Output: [0,0,1,1,1,1,1,0] &nbsp; Constraints: cells.length == 8 cells[i]&nbsp;is either 0 or 1. 1 &lt;= n &lt;= 109"
    },
    {
      "number": 958,
      "title": "Check Completeness of a Binary Tree",
      "titleSlug": "check-completeness-of-a-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, determine if it is a complete binary tree. In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. &nbsp; Example 1: Input: root = [1,2,3,4,5,6] Output: true Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible. Example 2: Input: root = [1,2,3,4,5,null,7] Output: false Explanation: The node with value 7 isn&#39;t as far left as possible. &nbsp; Constraints: The number of nodes in the tree is in the range [1, 100]. 1 &lt;= Node.val &lt;= 1000"
    },
    {
      "number": 959,
      "title": "Regions Cut By Slashes",
      "titleSlug": "regions-cut-by-slashes",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Matrix"
      ],
      "description": "An n x n grid is composed of 1 x 1 squares where each 1 x 1 square consists of a &#39;/&#39;, &#39;\\&#39;, or blank space &#39; &#39;. These characters divide the square into contiguous regions. Given the grid grid represented as a string array, return the number of regions. Note that backslash characters are escaped, so a &#39;\\&#39; is represented as &#39;\\\\&#39;. &nbsp; Example 1: Input: grid = [&quot; /&quot;,&quot;/ &quot;] Output: 2 Example 2: Input: grid = [&quot; /&quot;,&quot; &quot;] Output: 1 Example 3: Input: grid = [&quot;/\\\\&quot;,&quot;\\\\/&quot;] Output: 5 Explanation: Recall that because \\ characters are escaped, &quot;\\\\/&quot; refers to \\/, and &quot;/\\\\&quot; refers to /\\. &nbsp; Constraints: n == grid.length == grid[i].length 1 &lt;= n &lt;= 30 grid[i][j] is either &#39;/&#39;, &#39;\\&#39;, or &#39; &#39;."
    },
    {
      "number": 960,
      "title": "Delete Columns to Make Sorted III",
      "titleSlug": "delete-columns-to-make-sorted-iii",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "String",
        "Dynamic Programming"
      ],
      "description": "You are given an array of n strings strs, all of the same length. We may choose any deletion indices, and we delete all the characters in those indices for each string. For example, if we have strs = [&quot;abcdef&quot;,&quot;uvwxyz&quot;] and deletion indices {0, 2, 3}, then the final array after deletions is [&quot;bef&quot;, &quot;vyz&quot;]. Suppose we chose a set of deletion indices answer such that after deletions, the final array has every string (row) in lexicographic order. (i.e., (strs[0][0] &lt;= strs[0][1] &lt;= ... &lt;= strs[0][strs[0].length - 1]), and (strs[1][0] &lt;= strs[1][1] &lt;= ... &lt;= strs[1][strs[1].length - 1]), and so on). Return the minimum possible value of answer.length. &nbsp; Example 1: Input: strs = [&quot;babca&quot;,&quot;bbazb&quot;] Output: 3 Explanation: After deleting columns 0, 1, and 4, the final array is strs = [&quot;bc&quot;, &quot;az&quot;]. Both these rows are individually in lexicographic order (ie. strs[0][0] &lt;= strs[0][1] and strs[1][0] &lt;= strs[1][1]). Note that strs[0] &gt; strs[1] - the array strs is not necessarily in lexicographic order. Example 2: Input: strs = [&quot;edcba&quot;] Output: 4 Explanation: If we delete less than 4 columns, the only row will not be lexicographically sorted. Example 3: Input: strs = [&quot;ghi&quot;,&quot;def&quot;,&quot;abc&quot;] Output: 0 Explanation: All rows are already lexicographically sorted. &nbsp; Constraints: n == strs.length 1 &lt;= n &lt;= 100 1 &lt;= strs[i].length &lt;= 100 strs[i] consists of lowercase English letters. &nbsp;"
    },
    {
      "number": 961,
      "title": "N-Repeated Element in Size 2N Array",
      "titleSlug": "n-repeated-element-in-size-2n-array",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table"
      ],
      "description": "You are given an integer array nums with the following properties: nums.length == 2 * n. nums contains n + 1 unique elements. Exactly one element of nums is repeated n times. Return the element that is repeated n times. &nbsp; Example 1: Input: nums = [1,2,3,3] Output: 3 Example 2: Input: nums = [2,1,2,5,3,2] Output: 2 Example 3: Input: nums = [5,1,5,2,5,3,5,4] Output: 5 &nbsp; Constraints: 2 &lt;= n &lt;= 5000 nums.length == 2 * n 0 &lt;= nums[i] &lt;= 104 nums contains n + 1 unique elements and one of them is repeated exactly n times."
    },
    {
      "number": 962,
      "title": "Maximum Width Ramp",
      "titleSlug": "maximum-width-ramp",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Stack",
        "Monotonic Stack"
      ],
      "description": "A ramp in an integer array nums is a pair (i, j) for which i &lt; j and nums[i] &lt;= nums[j]. The width of such a ramp is j - i. Given an integer array nums, return the maximum width of a ramp in nums. If there is no ramp in nums, return 0. &nbsp; Example 1: Input: nums = [6,0,8,2,1,5] Output: 4 Explanation: The maximum width ramp is achieved at (i, j) = (1, 5): nums[1] = 0 and nums[5] = 5. Example 2: Input: nums = [9,8,1,0,1,9,4,0,4,1] Output: 7 Explanation: The maximum width ramp is achieved at (i, j) = (2, 9): nums[2] = 1 and nums[9] = 1. &nbsp; Constraints: 2 &lt;= nums.length &lt;= 5 * 104 0 &lt;= nums[i] &lt;= 5 * 104"
    },
    {
      "number": 963,
      "title": "Minimum Area Rectangle II",
      "titleSlug": "minimum-area-rectangle-ii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math",
        "Geometry"
      ],
      "description": "You are given an array of points in the X-Y plane points where points[i] = [xi, yi]. Return the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the X and Y axes. If there is not any such rectangle, return 0. Answers within 10-5 of the actual answer will be accepted. &nbsp; Example 1: Input: points = [[1,2],[2,1],[1,0],[0,1]] Output: 2.00000 Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2. Example 2: Input: points = [[0,1],[2,1],[1,1],[1,0],[2,0]] Output: 1.00000 Explanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1. Example 3: Input: points = [[0,3],[1,2],[3,1],[1,3],[2,1]] Output: 0 Explanation: There is no possible rectangle to form from these points. &nbsp; Constraints: 1 &lt;= points.length &lt;= 50 points[i].length == 2 0 &lt;= xi, yi &lt;= 4 * 104 All the given points are unique."
    },
    {
      "number": 964,
      "title": "Least Operators to Express Number",
      "titleSlug": "least-operators-to-express-number",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "Dynamic Programming",
        "Memoization"
      ],
      "description": "Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /). For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3. When writing such an expression, we adhere to the following conventions: The division operator (/) returns rational numbers. There are no parentheses placed anywhere. We use the usual order of operations: multiplication and division happen before addition and subtraction. It is not allowed to use the unary negation operator (-). For example, &quot;x - x&quot; is a valid expression as it only uses subtraction, but &quot;-x + x&quot; is not because it uses negation. We would like to write an expression with the least number of operators such that the expression equals the given target. Return the least number of operators used. &nbsp; Example 1: Input: x = 3, target = 19 Output: 5 Explanation: 3 * 3 + 3 * 3 + 3 / 3. The expression contains 5 operations. Example 2: Input: x = 5, target = 501 Output: 8 Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5. The expression contains 8 operations. Example 3: Input: x = 100, target = 100000000 Output: 3 Explanation: 100 * 100 * 100 * 100. The expression contains 3 operations. &nbsp; Constraints: 2 &lt;= x &lt;= 100 1 &lt;= target &lt;= 2 * 108"
    },
    {
      "number": 965,
      "title": "Univalued Binary Tree",
      "titleSlug": "univalued-binary-tree",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "A binary tree is uni-valued if every node in the tree has the same value. Given the root of a binary tree, return true if the given tree is uni-valued, or false otherwise. &nbsp; Example 1: Input: root = [1,1,1,1,1,null,1] Output: true Example 2: Input: root = [2,2,2,5,2] Output: false &nbsp; Constraints: The number of nodes in the tree is in the range [1, 100]. 0 &lt;= Node.val &lt; 100"
    },
    {
      "number": 966,
      "title": "Vowel Spellchecker",
      "titleSlug": "vowel-spellchecker",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word. For a given query word, the spell checker handles two categories of spelling mistakes: Capitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist. Example: wordlist = [&quot;yellow&quot;], query = &quot;YellOw&quot;: correct = &quot;yellow&quot; Example: wordlist = [&quot;Yellow&quot;], query = &quot;yellow&quot;: correct = &quot;Yellow&quot; Example: wordlist = [&quot;yellow&quot;], query = &quot;yellow&quot;: correct = &quot;yellow&quot; Vowel Errors: If after replacing the vowels (&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;) of the query word with any vowel individually, it matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the match in the wordlist. Example: wordlist = [&quot;YellOw&quot;], query = &quot;yollow&quot;: correct = &quot;YellOw&quot; Example: wordlist = [&quot;YellOw&quot;], query = &quot;yeellow&quot;: correct = &quot;&quot; (no match) Example: wordlist = [&quot;YellOw&quot;], query = &quot;yllw&quot;: correct = &quot;&quot; (no match) In addition, the spell checker operates under the following precedence rules: When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back. When the query matches a word up to capitlization, you should return the first such match in the wordlist. When the query matches a word up to vowel errors, you should return the first such match in the wordlist. If the query has no matches in the wordlist, you should return the empty string. Given some queries, return a list of words answer, where answer[i] is the correct word for query = queries[i]. &nbsp; Example 1: Input: wordlist = [\"KiTe\",\"kite\",\"hare\",\"Hare\"], queries = [\"kite\",\"Kite\",\"KiTe\",\"Hare\",\"HARE\",\"Hear\",\"hear\",\"keti\",\"keet\",\"keto\"] Output: [\"kite\",\"KiTe\",\"KiTe\",\"Hare\",\"hare\",\"\",\"\",\"KiTe\",\"\",\"KiTe\"] Example 2: Input: wordlist = [\"yellow\"], queries = [\"YellOw\"] Output: [\"yellow\"] &nbsp; Constraints: 1 &lt;= wordlist.length, queries.length &lt;= 5000 1 &lt;= wordlist[i].length, queries[i].length &lt;= 7 wordlist[i] and queries[i] consist only of only English letters."
    },
    {
      "number": 967,
      "title": "Numbers With Same Consecutive Differences",
      "titleSlug": "numbers-with-same-consecutive-differences",
      "difficulty": "Medium",
      "tags": [
        "Backtracking",
        "Breadth-First Search"
      ],
      "description": "Given two integers n and k, return an array of all the integers of length n where the difference between every two consecutive digits is k. You may return the answer in any order. Note that the integers should not have leading zeros. Integers as 02 and 043 are not allowed. &nbsp; Example 1: Input: n = 3, k = 7 Output: [181,292,707,818,929] Explanation: Note that 070 is not a valid number, because it has leading zeroes. Example 2: Input: n = 2, k = 1 Output: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98] &nbsp; Constraints: 2 &lt;= n &lt;= 9 0 &lt;= k &lt;= 9"
    },
    {
      "number": 968,
      "title": "Binary Tree Cameras",
      "titleSlug": "binary-tree-cameras",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children. Return the minimum number of cameras needed to monitor all nodes of the tree. &nbsp; Example 1: Input: root = [0,0,null,0,0] Output: 1 Explanation: One camera is enough to monitor all nodes if placed as shown. Example 2: Input: root = [0,0,null,0,null,0,null,null,0] Output: 2 Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement. &nbsp; Constraints: The number of nodes in the tree is in the range [1, 1000]. Node.val == 0"
    },
    {
      "number": 969,
      "title": "Pancake Sorting",
      "titleSlug": "pancake-sorting",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Greedy",
        "Sorting"
      ],
      "description": "Given an array of integers arr, sort the array by performing a series of pancake flips. In one pancake flip we do the following steps: Choose an integer k where 1 &lt;= k &lt;= arr.length. Reverse the sub-array arr[0...k-1] (0-indexed). For example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3. Return an array of the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct. &nbsp; Example 1: Input: arr = [3,2,4,1] Output: [4,2,4,3] Explanation: We perform 4 pancake flips, with k values 4, 2, 4, and 3. Starting state: arr = [3, 2, 4, 1] After 1st flip (k = 4): arr = [1, 4, 2, 3] After 2nd flip (k = 2): arr = [4, 1, 2, 3] After 3rd flip (k = 4): arr = [3, 2, 1, 4] After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted. Example 2: Input: arr = [1,2,3] Output: [] Explanation: The input is already sorted, so there is no need to flip anything. Note that other answers, such as [3, 3], would also be accepted. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 100 1 &lt;= arr[i] &lt;= arr.length All integers in arr are unique (i.e. arr is a permutation of the integers from 1 to arr.length)."
    },
    {
      "number": 970,
      "title": "Powerful Integers",
      "titleSlug": "powerful-integers",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Math",
        "Enumeration"
      ],
      "description": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound. An integer is powerful if it can be represented as xi + yj for some integers i &gt;= 0 and j &gt;= 0. You may return the answer in any order. In your answer, each value should occur at most once. &nbsp; Example 1: Input: x = 2, y = 3, bound = 10 Output: [2,3,4,5,7,9,10] Explanation: 2 = 20 + 30 3 = 21 + 30 4 = 20 + 31 5 = 21 + 31 7 = 22 + 31 9 = 23 + 30 10 = 20 + 32 Example 2: Input: x = 3, y = 5, bound = 15 Output: [2,4,6,8,10,14] &nbsp; Constraints: 1 &lt;= x, y &lt;= 100 0 &lt;= bound &lt;= 106"
    },
    {
      "number": 971,
      "title": "Flip Binary Tree To Match Preorder Traversal",
      "titleSlug": "flip-binary-tree-to-match-preorder-traversal",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "You are given the root of a binary tree with n nodes, where each node is uniquely assigned a value from 1 to n. You are also given a sequence of n values voyage, which is the desired pre-order traversal of the binary tree. Any node in the binary tree can be flipped by swapping its left and right subtrees. For example, flipping node 1 will have the following effect: Flip the smallest number of nodes so that the pre-order traversal of the tree matches voyage. Return a list of the values of all flipped nodes. You may return the answer in any order. If it is impossible to flip the nodes in the tree to make the pre-order traversal match voyage, return the list [-1]. &nbsp; Example 1: Input: root = [1,2], voyage = [2,1] Output: [-1] Explanation: It is impossible to flip the nodes such that the pre-order traversal matches voyage. Example 2: Input: root = [1,2,3], voyage = [1,3,2] Output: [1] Explanation: Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage. Example 3: Input: root = [1,2,3], voyage = [1,2,3] Output: [] Explanation: The tree&#39;s pre-order traversal already matches voyage, so no nodes need to be flipped. &nbsp; Constraints: The number of nodes in the tree is n. n == voyage.length 1 &lt;= n &lt;= 100 1 &lt;= Node.val, voyage[i] &lt;= n All the values in the tree are unique. All the values in voyage are unique."
    },
    {
      "number": 972,
      "title": "Equal Rational Numbers",
      "titleSlug": "equal-rational-numbers",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "String"
      ],
      "description": "Given two strings s and t, each of which represents a non-negative rational number, return true if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number. A rational number can be represented using up to three parts: &lt;IntegerPart&gt;, &lt;NonRepeatingPart&gt;, and a &lt;RepeatingPart&gt;. The number will be represented in one of the following three ways: &lt;IntegerPart&gt; For example, 12, 0, and 123. &lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt; For example, 0.5, 1., 2.12, and 123.0001. &lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;&lt;(&gt;&lt;RepeatingPart&gt;&lt;)&gt; For example, 0.1(6), 1.(9), 123.00(1212). The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets. For example: 1/6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66). &nbsp; Example 1: Input: s = &quot;0.(52)&quot;, t = &quot;0.5(25)&quot; Output: true Explanation: Because &quot;0.(52)&quot; represents 0.52525252..., and &quot;0.5(25)&quot; represents 0.52525252525..... , the strings represent the same number. Example 2: Input: s = &quot;0.1666(6)&quot;, t = &quot;0.166(66)&quot; Output: true Example 3: Input: s = &quot;0.9(9)&quot;, t = &quot;1.&quot; Output: true Explanation: &quot;0.9(9)&quot; represents 0.999999999... repeated forever, which equals 1. [See this link for an explanation.] &quot;1.&quot; represents the number 1, which is formed correctly: (IntegerPart) = &quot;1&quot; and (NonRepeatingPart) = &quot;&quot;. &nbsp; Constraints: Each part consists only of digits. The &lt;IntegerPart&gt; does not have leading zeros (except for the zero itself). 1 &lt;= &lt;IntegerPart&gt;.length &lt;= 4 0 &lt;= &lt;NonRepeatingPart&gt;.length &lt;= 4 1 &lt;= &lt;RepeatingPart&gt;.length &lt;= 4"
    },
    {
      "number": 973,
      "title": "K Closest Points to Origin",
      "titleSlug": "k-closest-points-to-origin",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math",
        "Divide and Conquer",
        "Geometry",
        "Sorting",
        "Heap (Priority Queue)",
        "Quickselect"
      ],
      "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., &radic;(x1 - x2)2 + (y1 - y2)2). You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in). &nbsp; Example 1: Input: points = [[1,3],[-2,2]], k = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin. We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]]. Example 2: Input: points = [[3,3],[5,-1],[-2,4]], k = 2 Output: [[3,3],[-2,4]] Explanation: The answer [[-2,4],[3,3]] would also be accepted. &nbsp; Constraints: 1 &lt;= k &lt;= points.length &lt;= 104 -104 &lt;= xi, yi &lt;= 104"
    },
    {
      "number": 974,
      "title": "Subarray Sums Divisible by K",
      "titleSlug": "subarray-sums-divisible-by-k",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Prefix Sum"
      ],
      "description": "Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k. A subarray is a contiguous part of an array. &nbsp; Example 1: Input: nums = [4,5,0,-2,-3,1], k = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by k = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] Example 2: Input: nums = [5], k = 9 Output: 0 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 2 &lt;= k &lt;= 104"
    },
    {
      "number": 975,
      "title": "Odd Even Jump",
      "titleSlug": "odd-even-jump",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Stack",
        "Monotonic Stack",
        "Ordered Set"
      ],
      "description": "You are given an integer array arr. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices. You may jump forward from index i to index j (with i &lt; j) in the following way: During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index j such that arr[i] &lt;= arr[j] and arr[j] is the smallest possible value. If there are multiple such indices j, you can only jump to the smallest such index j. During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index j such that arr[i] &gt;= arr[j] and arr[j] is the largest possible value. If there are multiple such indices j, you can only jump to the smallest such index j. It may be the case that for some index i, there are no legal jumps. A starting index is good if, starting from that index, you can reach the end of the array (index arr.length - 1) by jumping some number of times (possibly 0 or more than once). Return the number of good starting indices. &nbsp; Example 1: Input: arr = [10,13,12,14,15] Output: 2 Explanation: From starting index i = 0, we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1], arr[2], arr[3], arr[4] that is greater or equal to arr[0]), then we cannot jump any more. From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more. From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end. From starting index i = 4, we have reached the end already. In total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of jumps. Example 2: Input: arr = [2,3,1,1,4] Output: 3 Explanation: From starting index i = 0, we make jumps to i = 1, i = 2, i = 3: During our 1st jump (odd-numbered), we first jump to i = 1 because arr[1] is the smallest value in [arr[1], arr[2], arr[3], arr[4]] that is greater than or equal to arr[0]. During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2], arr[3], arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3 During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3], arr[4]] that is greater than or equal to arr[2]. We can&#39;t jump from i = 3 to i = 4, so the starting index i = 0 is not good. In a similar manner, we can deduce that: From starting index i = 1, we jump to i = 4, so we reach the end. From starting index i = 2, we jump to i = 3, and then we can&#39;t jump anymore. From starting index i = 3, we jump to i = 4, so we reach the end. From starting index i = 4, we are already at the end. In total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some number of jumps. Example 3: Input: arr = [5,1,3,4,2] Output: 3 Explanation: We can reach the end from starting indices 1, 2, and 4. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 2 * 104 0 &lt;= arr[i] &lt; 105"
    },
    {
      "number": 976,
      "title": "Largest Perimeter Triangle",
      "titleSlug": "largest-perimeter-triangle",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math",
        "Greedy",
        "Sorting"
      ],
      "description": "Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0. &nbsp; Example 1: Input: nums = [2,1,2] Output: 5 Explanation: You can form a triangle with three side lengths: 1, 2, and 2. Example 2: Input: nums = [1,2,1,10] Output: 0 Explanation: You cannot use the side lengths 1, 1, and 2 to form a triangle. You cannot use the side lengths 1, 1, and 10 to form a triangle. You cannot use the side lengths 1, 2, and 10 to form a triangle. As we cannot use any three side lengths to form a triangle of non-zero area, we return 0. &nbsp; Constraints: 3 &lt;= nums.length &lt;= 104 1 &lt;= nums[i] &lt;= 106"
    },
    {
      "number": 977,
      "title": "Squares of a Sorted Array",
      "titleSlug": "squares-of-a-sorted-array",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Two Pointers",
        "Sorting"
      ],
      "description": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. &nbsp; Example 1: Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2: Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121] &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums is sorted in non-decreasing order. &nbsp; Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?"
    },
    {
      "number": 978,
      "title": "Longest Turbulent Subarray",
      "titleSlug": "longest-turbulent-subarray",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Sliding Window"
      ],
      "description": "Given an integer array arr, return the length of a maximum size turbulent subarray of arr. A subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray. More formally, a subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent if and only if: For i &lt;= k &lt; j: arr[k] &gt; arr[k + 1] when k is odd, and arr[k] &lt; arr[k + 1] when k is even. Or, for i &lt;= k &lt; j: arr[k] &gt; arr[k + 1] when k is even, and arr[k] &lt; arr[k + 1] when k is odd. &nbsp; Example 1: Input: arr = [9,4,2,10,7,8,8,1,9] Output: 5 Explanation: arr[1] &gt; arr[2] &lt; arr[3] &gt; arr[4] &lt; arr[5] Example 2: Input: arr = [4,8,12,16] Output: 2 Example 3: Input: arr = [100] Output: 1 &nbsp; Constraints: 1 &lt;= arr.length &lt;= 4 * 104 0 &lt;= arr[i] &lt;= 109"
    },
    {
      "number": 979,
      "title": "Distribute Coins in Binary Tree",
      "titleSlug": "distribute-coins-in-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree. In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent. Return the minimum number of moves required to make every node have exactly one coin. &nbsp; Example 1: Input: root = [3,0,0] Output: 2 Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child. Example 2: Input: root = [0,3,0] Output: 3 Explanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child. &nbsp; Constraints: The number of nodes in the tree is n. 1 &lt;= n &lt;= 100 0 &lt;= Node.val &lt;= n The sum of all Node.val is n."
    },
    {
      "number": 980,
      "title": "Unique Paths III",
      "titleSlug": "unique-paths-iii",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Backtracking",
        "Bit Manipulation",
        "Matrix"
      ],
      "description": "You are given an m x n integer array grid where grid[i][j] could be: 1 representing the starting square. There is exactly one starting square. 2 representing the ending square. There is exactly one ending square. 0 representing empty squares we can walk over. -1 representing obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once. &nbsp; Example 1: Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]] Output: 2 Explanation: We have the following two paths: 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2) 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2) Example 2: Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]] Output: 4 Explanation: We have the following four paths: 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3) 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3) 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3) 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3) Example 3: Input: grid = [[0,1],[2,0]] Output: 0 Explanation: There is no path that walks over every empty square exactly once. Note that the starting and ending square can be anywhere in the grid. &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 20 1 &lt;= m * n &lt;= 20 -1 &lt;= grid[i][j] &lt;= 2 There is exactly one starting cell and one ending cell."
    },
    {
      "number": 981,
      "title": "Time Based Key-Value Store",
      "titleSlug": "time-based-key-value-store",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Binary Search",
        "Design"
      ],
      "description": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key&#39;s value at a certain timestamp. Implement the TimeMap class: TimeMap() Initializes the object of the data structure. void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev &lt;= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns &quot;&quot;. &nbsp; Example 1: Input [&quot;TimeMap&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;] [[], [&quot;foo&quot;, &quot;bar&quot;, 1], [&quot;foo&quot;, 1], [&quot;foo&quot;, 3], [&quot;foo&quot;, &quot;bar2&quot;, 4], [&quot;foo&quot;, 4], [&quot;foo&quot;, 5]] Output [null, null, &quot;bar&quot;, &quot;bar&quot;, null, &quot;bar2&quot;, &quot;bar2&quot;] Explanation TimeMap timeMap = new TimeMap(); timeMap.set(&quot;foo&quot;, &quot;bar&quot;, 1); // store the key &quot;foo&quot; and value &quot;bar&quot; along with timestamp = 1. timeMap.get(&quot;foo&quot;, 1); // return &quot;bar&quot; timeMap.get(&quot;foo&quot;, 3); // return &quot;bar&quot;, since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is &quot;bar&quot;. timeMap.set(&quot;foo&quot;, &quot;bar2&quot;, 4); // store the key &quot;foo&quot; and value &quot;bar2&quot; along with timestamp = 4. timeMap.get(&quot;foo&quot;, 4); // return &quot;bar2&quot; timeMap.get(&quot;foo&quot;, 5); // return &quot;bar2&quot; &nbsp; Constraints: 1 &lt;= key.length, value.length &lt;= 100 key and value consist of lowercase English letters and digits. 1 &lt;= timestamp &lt;= 107 All the timestamps timestamp of set are strictly increasing. At most 2 * 105 calls will be made to set and get."
    },
    {
      "number": 982,
      "title": "Triples with Bitwise AND Equal To Zero",
      "titleSlug": "triples-with-bitwise-and-equal-to-zero",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Bit Manipulation"
      ],
      "description": "Given an integer array nums, return the number of AND triples. An AND triple is a triple of indices (i, j, k) such that: 0 &lt;= i &lt; nums.length 0 &lt;= j &lt; nums.length 0 &lt;= k &lt; nums.length nums[i] &amp; nums[j] &amp; nums[k] == 0, where &amp; represents the bitwise-AND operator. &nbsp; Example 1: Input: nums = [2,1,3] Output: 12 Explanation: We could choose the following i, j, k triples: (i=0, j=0, k=1) : 2 &amp; 2 &amp; 1 (i=0, j=1, k=0) : 2 &amp; 1 &amp; 2 (i=0, j=1, k=1) : 2 &amp; 1 &amp; 1 (i=0, j=1, k=2) : 2 &amp; 1 &amp; 3 (i=0, j=2, k=1) : 2 &amp; 3 &amp; 1 (i=1, j=0, k=0) : 1 &amp; 2 &amp; 2 (i=1, j=0, k=1) : 1 &amp; 2 &amp; 1 (i=1, j=0, k=2) : 1 &amp; 2 &amp; 3 (i=1, j=1, k=0) : 1 &amp; 1 &amp; 2 (i=1, j=2, k=0) : 1 &amp; 3 &amp; 2 (i=2, j=0, k=1) : 3 &amp; 2 &amp; 1 (i=2, j=1, k=0) : 3 &amp; 1 &amp; 2 Example 2: Input: nums = [0,0,0] Output: 27 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt; 216"
    },
    {
      "number": 983,
      "title": "Minimum Cost For Tickets",
      "titleSlug": "minimum-cost-for-tickets",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365. Train tickets are sold in three different ways: a 1-day pass is sold for costs[0] dollars, a 7-day pass is sold for costs[1] dollars, and a 30-day pass is sold for costs[2] dollars. The passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8. Return the minimum number of dollars you need to travel every day in the given list of days. &nbsp; Example 1: Input: days = [1,4,6,7,8,20], costs = [2,7,15] Output: 11 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1. On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9. On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20. In total, you spent $11 and covered all the days of your travel. Example 2: Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation: For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total, you spent $17 and covered all the days of your travel. &nbsp; Constraints: 1 &lt;= days.length &lt;= 365 1 &lt;= days[i] &lt;= 365 days is in strictly increasing order. costs.length == 3 1 &lt;= costs[i] &lt;= 1000"
    },
    {
      "number": 984,
      "title": "String Without AAA or BBB",
      "titleSlug": "string-without-aaa-or-bbb",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Greedy"
      ],
      "description": "Given two integers a and b, return any string s such that: s has length a + b and contains exactly a &#39;a&#39; letters, and exactly b &#39;b&#39; letters, The substring &#39;aaa&#39; does not occur in s, and The substring &#39;bbb&#39; does not occur in s. &nbsp; Example 1: Input: a = 1, b = 2 Output: &quot;abb&quot; Explanation: &quot;abb&quot;, &quot;bab&quot; and &quot;bba&quot; are all correct answers. Example 2: Input: a = 4, b = 1 Output: &quot;aabaa&quot; &nbsp; Constraints: 0 &lt;= a, b &lt;= 100 It is guaranteed such an s exists for the given a and b."
    },
    {
      "number": 985,
      "title": "Sum of Even Numbers After Queries",
      "titleSlug": "sum-of-even-numbers-after-queries",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Simulation"
      ],
      "description": "You are given an integer array nums and an array queries where queries[i] = [vali, indexi]. For each query i, first, apply nums[indexi] = nums[indexi] + vali, then print the sum of the even values of nums. Return an integer array answer where answer[i] is the answer to the ith query. &nbsp; Example 1: Input: nums = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]] Output: [8,6,2,4] Explanation: At the beginning, the array is [1,2,3,4]. After adding 1 to nums[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8. After adding -3 to nums[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6. After adding -4 to nums[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2. After adding 2 to nums[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4. Example 2: Input: nums = [1], queries = [[4,0]] Output: [0] &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 1 &lt;= queries.length &lt;= 104 -104 &lt;= vali &lt;= 104 0 &lt;= indexi &lt; nums.length"
    },
    {
      "number": 986,
      "title": "Interval List Intersections",
      "titleSlug": "interval-list-intersections",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Line Sweep"
      ],
      "description": "You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. A closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b. The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3]. &nbsp; Example 1: Input: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]] Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] Example 2: Input: firstList = [[1,3],[5,9]], secondList = [] Output: [] &nbsp; Constraints: 0 &lt;= firstList.length, secondList.length &lt;= 1000 firstList.length + secondList.length &gt;= 1 0 &lt;= starti &lt; endi &lt;= 109 endi &lt; starti+1 0 &lt;= startj &lt; endj &lt;= 109 endj &lt; startj+1"
    },
    {
      "number": 987,
      "title": "Vertical Order Traversal of a Binary Tree",
      "titleSlug": "vertical-order-traversal-of-a-binary-tree",
      "difficulty": "Hard",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Sorting",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, calculate the vertical order traversal of the binary tree. For each node at position (row, col), its left and right children will be at positions (row + 1, col - 1) and (row + 1, col + 1) respectively. The root of the tree is at (0, 0). The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values. Return the vertical order traversal of the binary tree. &nbsp; Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Explanation: Column -1: Only node 9 is in this column. Column 0: Nodes 3 and 15 are in this column in that order from top to bottom. Column 1: Only node 20 is in this column. Column 2: Only node 7 is in this column. Example 2: Input: root = [1,2,3,4,5,6,7] Output: [[4],[2],[1,5,6],[3],[7]] Explanation: Column -2: Only node 4 is in this column. Column -1: Only node 2 is in this column. Column 0: Nodes 1, 5, and 6 are in this column. 1 is at the top, so it comes first. 5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6. Column 1: Only node 3 is in this column. Column 2: Only node 7 is in this column. Example 3: Input: root = [1,2,3,4,6,5,7] Output: [[4],[2],[1,5,6],[3],[7]] Explanation: This case is the exact same as example 2, but with nodes 5 and 6 swapped. Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values. &nbsp; Constraints: The number of nodes in the tree is in the range [1, 1000]. 0 &lt;= Node.val &lt;= 1000"
    },
    {
      "number": 988,
      "title": "Smallest String Starting From Leaf",
      "titleSlug": "smallest-string-starting-from-leaf",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Backtracking",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters &#39;a&#39; to &#39;z&#39;. Return the lexicographically smallest string that starts at a leaf of this tree and ends at the root. As a reminder, any shorter prefix of a string is lexicographically smaller. For example, &quot;ab&quot; is lexicographically smaller than &quot;aba&quot;. A leaf of a node is a node that has no children. &nbsp; Example 1: Input: root = [0,1,2,3,4,3,4] Output: &quot;dba&quot; Example 2: Input: root = [25,1,3,1,3,0,2] Output: &quot;adz&quot; Example 3: Input: root = [2,2,1,null,1,0,null,0] Output: &quot;abc&quot; &nbsp; Constraints: The number of nodes in the tree is in the range [1, 8500]. 0 &lt;= Node.val &lt;= 25"
    },
    {
      "number": 989,
      "title": "Add to Array-Form of Integer",
      "titleSlug": "add-to-array-form-of-integer",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math"
      ],
      "description": "The array-form of an integer num is an array representing its digits in left to right order. For example, for num = 1321, the array form is [1,3,2,1]. Given num, the array-form of an integer, and an integer k, return the array-form of the integer num + k. &nbsp; Example 1: Input: num = [1,2,0,0], k = 34 Output: [1,2,3,4] Explanation: 1200 + 34 = 1234 Example 2: Input: num = [2,7,4], k = 181 Output: [4,5,5] Explanation: 274 + 181 = 455 Example 3: Input: num = [2,1,5], k = 806 Output: [1,0,2,1] Explanation: 215 + 806 = 1021 &nbsp; Constraints: 1 &lt;= num.length &lt;= 104 0 &lt;= num[i] &lt;= 9 num does not contain any leading zeros except for the zero itself. 1 &lt;= k &lt;= 104"
    },
    {
      "number": 990,
      "title": "Satisfiability of Equality Equations",
      "titleSlug": "satisfiability-of-equality-equations",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "String",
        "Union Find",
        "Graph"
      ],
      "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: &quot;xi==yi&quot; or &quot;xi!=yi&quot;.Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names. Return true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise. &nbsp; Example 1: Input: equations = [&quot;a==b&quot;,&quot;b!=a&quot;] Output: false Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second. There is no way to assign the variables to satisfy both equations. Example 2: Input: equations = [&quot;b==a&quot;,&quot;a==b&quot;] Output: true Explanation: We could assign a = 1 and b = 1 to satisfy both equations. &nbsp; Constraints: 1 &lt;= equations.length &lt;= 500 equations[i].length == 4 equations[i][0] is a lowercase letter. equations[i][1] is either &#39;=&#39; or &#39;!&#39;. equations[i][2] is &#39;=&#39;. equations[i][3] is a lowercase letter."
    },
    {
      "number": 991,
      "title": "Broken Calculator",
      "titleSlug": "broken-calculator",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Greedy"
      ],
      "description": "There is a broken calculator that has the integer startValue on its display initially. In one operation, you can: multiply the number on display by 2, or subtract 1 from the number on display. Given two integers startValue and target, return the minimum number of operations needed to display target on the calculator. &nbsp; Example 1: Input: startValue = 2, target = 3 Output: 2 Explanation: Use double operation and then decrement operation {2 -&gt; 4 -&gt; 3}. Example 2: Input: startValue = 5, target = 8 Output: 2 Explanation: Use decrement and then double {5 -&gt; 4 -&gt; 8}. Example 3: Input: startValue = 3, target = 10 Output: 3 Explanation: Use double, decrement and double {3 -&gt; 6 -&gt; 5 -&gt; 10}. &nbsp; Constraints: 1 &lt;= startValue, target &lt;= 109"
    },
    {
      "number": 992,
      "title": "Subarrays with K Different Integers",
      "titleSlug": "subarrays-with-k-different-integers",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Sliding Window",
        "Counting"
      ],
      "description": "Given an integer array nums and an integer k, return the number of good subarrays of nums. A good array is an array where the number of different integers in that array is exactly k. For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3. A subarray is a contiguous part of an array. &nbsp; Example 1: Input: nums = [1,2,1,2,3], k = 2 Output: 7 Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2] Example 2: Input: nums = [1,2,1,3,4], k = 3 Output: 3 Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4]. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 2 * 104 1 &lt;= nums[i], k &lt;= nums.length"
    },
    {
      "number": 993,
      "title": "Cousins in Binary Tree",
      "titleSlug": "cousins-in-binary-tree",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree with unique values and the values of two different nodes of the tree x and y, return true if the nodes corresponding to the values x and y in the tree are cousins, or false otherwise. Two nodes of a binary tree are cousins if they have the same depth with different parents. Note that in a binary tree, the root node is at the depth 0, and children of each depth k node are at the depth k + 1. &nbsp; Example 1: Input: root = [1,2,3,4], x = 4, y = 3 Output: false Example 2: Input: root = [1,2,3,null,4,null,5], x = 5, y = 4 Output: true Example 3: Input: root = [1,2,3,null,4], x = 2, y = 3 Output: false &nbsp; Constraints: The number of nodes in the tree is in the range [2, 100]. 1 &lt;= Node.val &lt;= 100 Each node has a unique value. x != y x and y are exist in the tree."
    },
    {
      "number": 994,
      "title": "Rotting Oranges",
      "titleSlug": "rotting-oranges",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange. Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. &nbsp; Example 1: Input: grid = [[2,1,1],[1,1,0],[0,1,1]] Output: 4 Example 2: Input: grid = [[2,1,1],[0,1,1],[1,0,1]] Output: -1 Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally. Example 3: Input: grid = [[0,2]] Output: 0 Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0. &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 10 grid[i][j] is 0, 1, or 2."
    },
    {
      "number": 995,
      "title": "Minimum Number of K Consecutive Bit Flips",
      "titleSlug": "minimum-number-of-k-consecutive-bit-flips",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Bit Manipulation",
        "Queue",
        "Sliding Window",
        "Prefix Sum"
      ],
      "description": "You are given a binary array nums and an integer k. A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0. Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1. A subarray is a contiguous part of an array. &nbsp; Example 1: Input: nums = [0,1,0], k = 1 Output: 2 Explanation: Flip nums[0], then flip nums[2]. Example 2: Input: nums = [1,1,0], k = 2 Output: -1 Explanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1]. Example 3: Input: nums = [0,0,0,1,0,1,1,0], k = 3 Output: 3 Explanation: Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0] Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0] Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1] &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 1 &lt;= k &lt;= nums.length"
    },
    {
      "number": 996,
      "title": "Number of Squareful Arrays",
      "titleSlug": "number-of-squareful-arrays",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Math",
        "Dynamic Programming",
        "Backtracking",
        "Bit Manipulation",
        "Bitmask"
      ],
      "description": "An array is squareful if the sum of every pair of adjacent elements is a perfect square. Given an integer array nums, return the number of permutations of nums that are squareful. Two permutations perm1 and perm2 are different if there is some index i such that perm1[i] != perm2[i]. &nbsp; Example 1: Input: nums = [1,17,8] Output: 2 Explanation: [1,8,17] and [17,8,1] are the valid permutations. Example 2: Input: nums = [2,2,2] Output: 1 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 12 0 &lt;= nums[i] &lt;= 109"
    },
    {
      "number": 997,
      "title": "Find the Town Judge",
      "titleSlug": "find-the-town-judge",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Graph"
      ],
      "description": "In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: The town judge trusts nobody. Everybody (except for the town judge) trusts the town judge. There is exactly one person that satisfies properties 1 and 2. You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist. Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise. &nbsp; Example 1: Input: n = 2, trust = [[1,2]] Output: 2 Example 2: Input: n = 3, trust = [[1,3],[2,3]] Output: 3 Example 3: Input: n = 3, trust = [[1,3],[2,3],[3,1]] Output: -1 &nbsp; Constraints: 1 &lt;= n &lt;= 1000 0 &lt;= trust.length &lt;= 104 trust[i].length == 2 All the pairs of trust are unique. ai != bi 1 &lt;= ai, bi &lt;= n"
    },
    {
      "number": 998,
      "title": "Maximum Binary Tree II",
      "titleSlug": "maximum-binary-tree-ii",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Binary Tree"
      ],
      "description": "A maximum tree is a tree where every node has a value greater than any other value in its subtree. You are given the root of a maximum binary tree and an integer val. Just as in the previous problem, the given tree was constructed from a list a (root = Construct(a)) recursively with the following Construct(a) routine: If a is empty, return null. Otherwise, let a[i] be the largest element of a. Create a root node with the value a[i]. The left child of root will be Construct([a[0], a[1], ..., a[i - 1]]). The right child of root will be Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]]). Return root. Note that we were not given a directly, only a root node root = Construct(a). Suppose b is a copy of a with the value val appended to it. It is guaranteed that b has unique values. Return Construct(b). &nbsp; Example 1: Input: root = [4,1,3,null,null,2], val = 5 Output: [5,4,null,1,3,null,null,2] Explanation: a = [1,4,2,3], b = [1,4,2,3,5] Example 2: Input: root = [5,2,4,null,1], val = 3 Output: [5,2,4,null,1,null,3] Explanation: a = [2,1,5,4], b = [2,1,5,4,3] Example 3: Input: root = [5,2,3,null,1], val = 4 Output: [5,2,4,null,1,3] Explanation: a = [2,1,5,3], b = [2,1,5,3,4] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 100]. 1 &lt;= Node.val &lt;= 100 All the values of the tree are unique. 1 &lt;= val &lt;= 100"
    },
    {
      "number": 999,
      "title": "Available Captures for Rook",
      "titleSlug": "available-captures-for-rook",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Matrix",
        "Simulation"
      ],
      "description": "You are given an 8 x 8 matrix representing a chessboard. There is exactly one white rook represented by &#39;R&#39;, some number of white bishops &#39;B&#39;, and some number of black pawns &#39;p&#39;. Empty squares are represented by &#39;.&#39;. A rook can move any number of squares horizontally or vertically (up, down, left, right) until it reaches another piece or the edge of the board. A rook is attacking a pawn if it can move to the pawn&#39;s square in one move. Note: A rook cannot move through other pieces, such as bishops or pawns. This means a rook cannot attack a pawn if there is another piece blocking the path. Return the number of pawns the white rook is attacking. &nbsp; Example 1: Input: board = [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]] Output: 3 Explanation: In this example, the rook is attacking all the pawns. Example 2: Input: board = [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]] Output: 0 Explanation: The bishops are blocking the rook from attacking any of the pawns. Example 3: Input: board = [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]] Output: 3 Explanation: The rook is attacking the pawns at positions b5, d6, and f5. &nbsp; Constraints: board.length == 8 board[i].length == 8 board[i][j] is either &#39;R&#39;, &#39;.&#39;, &#39;B&#39;, or &#39;p&#39; There is exactly one cell with board[i][j] == &#39;R&#39;"
    },
    {
      "number": 1000,
      "title": "Minimum Cost to Merge Stones",
      "titleSlug": "minimum-cost-to-merge-stones",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Prefix Sum"
      ],
      "description": "There are n piles of stones arranged in a row. The ith pile has stones[i] stones. A move consists of merging exactly k consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these k piles. Return the minimum cost to merge all piles of stones into one pile. If it is impossible, return -1. &nbsp; Example 1: Input: stones = [3,2,4,1], k = 2 Output: 20 Explanation: We start with [3, 2, 4, 1]. We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1]. We merge [4, 1] for a cost of 5, and we are left with [5, 5]. We merge [5, 5] for a cost of 10, and we are left with [10]. The total cost was 20, and this is the minimum possible. Example 2: Input: stones = [3,2,4,1], k = 3 Output: -1 Explanation: After any merge operation, there are 2 piles left, and we can&#39;t merge anymore. So the task is impossible. Example 3: Input: stones = [3,5,1,2,6], k = 3 Output: 25 Explanation: We start with [3, 5, 1, 2, 6]. We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6]. We merge [3, 8, 6] for a cost of 17, and we are left with [17]. The total cost was 25, and this is the minimum possible. &nbsp; Constraints: n == stones.length 1 &lt;= n &lt;= 30 1 &lt;= stones[i] &lt;= 100 2 &lt;= k &lt;= 30"
    },
    {
      "number": 1001,
      "title": "Grid Illumination",
      "titleSlug": "grid-illumination",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table"
      ],
      "description": "There is a 2D grid of size n x n where each cell of this grid has a lamp that is initially turned off. You are given a 2D array of lamp positions lamps, where lamps[i] = [rowi, coli] indicates that the lamp at grid[rowi][coli] is turned on. Even if the same lamp is listed more than once, it is turned on. When a lamp is turned on, it illuminates its cell and all other cells in the same row, column, or diagonal. You are also given another 2D array queries, where queries[j] = [rowj, colj]. For the jth query, determine whether grid[rowj][colj] is illuminated or not. After answering the jth query, turn off the lamp at grid[rowj][colj] and its 8 adjacent lamps if they exist. A lamp is adjacent if its cell shares either a side or corner with grid[rowj][colj]. Return an array of integers ans, where ans[j] should be 1 if the cell in the jth query was illuminated, or 0 if the lamp was not. &nbsp; Example 1: Input: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]] Output: [1,0] Explanation: We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid[0][0] then turning on the lamp at grid[4][4]. The 0th&nbsp;query asks if the lamp at grid[1][1] is illuminated or not (the blue square). It is illuminated, so set ans[0] = 1. Then, we turn off all lamps in the red square. The 1st&nbsp;query asks if the lamp at grid[1][0] is illuminated or not (the blue square). It is not illuminated, so set ans[1] = 0. Then, we turn off all lamps in the red rectangle. Example 2: Input: n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]] Output: [1,1] Example 3: Input: n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]] Output: [1,1,0] &nbsp; Constraints: 1 &lt;= n &lt;= 109 0 &lt;= lamps.length &lt;= 20000 0 &lt;= queries.length &lt;= 20000 lamps[i].length == 2 0 &lt;= rowi, coli &lt; n queries[j].length == 2 0 &lt;= rowj, colj &lt; n"
    },
    {
      "number": 1002,
      "title": "Find Common Characters",
      "titleSlug": "find-common-characters",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order. &nbsp; Example 1: Input: words = [\"bella\",\"label\",\"roller\"] Output: [\"e\",\"l\",\"l\"] Example 2: Input: words = [\"cool\",\"lock\",\"cook\"] Output: [\"c\",\"o\"] &nbsp; Constraints: 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 100 words[i] consists of lowercase English letters."
    },
    {
      "number": 1003,
      "title": "Check If Word Is Valid After Substitutions",
      "titleSlug": "check-if-word-is-valid-after-substitutions",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Stack"
      ],
      "description": "Given a string s, determine if it is valid. A string s is valid if, starting with an empty string t = &quot;&quot;, you can transform t into s after performing the following operation any number of times: Insert string &quot;abc&quot; into any position in t. More formally, t becomes tleft + &quot;abc&quot; + tright, where t == tleft + tright. Note that tleft and tright may be empty. Return true if s is a valid string, otherwise, return false. &nbsp; Example 1: Input: s = &quot;aabcbc&quot; Output: true Explanation: &quot;&quot; -&gt; &quot;abc&quot; -&gt; &quot;aabcbc&quot; Thus, &quot;aabcbc&quot; is valid. Example 2: Input: s = &quot;abcabcababcc&quot; Output: true Explanation: &quot;&quot; -&gt; &quot;abc&quot; -&gt; &quot;abcabc&quot; -&gt; &quot;abcabcabc&quot; -&gt; &quot;abcabcababcc&quot; Thus, &quot;abcabcababcc&quot; is valid. Example 3: Input: s = &quot;abccba&quot; Output: false Explanation: It is impossible to get &quot;abccba&quot; using the operation. &nbsp; Constraints: 1 &lt;= s.length &lt;= 2 * 104 s consists of letters &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;"
    },
    {
      "number": 1004,
      "title": "Max Consecutive Ones III",
      "titleSlug": "max-consecutive-ones-iii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search",
        "Sliding Window",
        "Prefix Sum"
      ],
      "description": "Given a binary array nums and an integer k, return the maximum number of consecutive 1&#39;s in the array if you can flip at most k 0&#39;s. &nbsp; Example 1: Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Example 2: Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3 Output: 10 Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 nums[i] is either 0 or 1. 0 &lt;= k &lt;= nums.length"
    },
    {
      "number": 1005,
      "title": "Maximize Sum Of Array After K Negations",
      "titleSlug": "maximize-sum-of-array-after-k-negations",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Greedy",
        "Sorting"
      ],
      "description": "Given an integer array nums and an integer k, modify the array in the following way: choose an index i and replace nums[i] with -nums[i]. You should apply this process exactly k times. You may choose the same index i multiple times. Return the largest possible sum of the array after modifying it in this way. &nbsp; Example 1: Input: nums = [4,2,3], k = 1 Output: 5 Explanation: Choose index 1 and nums becomes [4,-2,3]. Example 2: Input: nums = [3,-1,0,2], k = 3 Output: 6 Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2]. Example 3: Input: nums = [2,-3,-1,5,-4], k = 2 Output: 13 Explanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4]. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 -100 &lt;= nums[i] &lt;= 100 1 &lt;= k &lt;= 104"
    },
    {
      "number": 1006,
      "title": "Clumsy Factorial",
      "titleSlug": "clumsy-factorial",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Stack",
        "Simulation"
      ],
      "description": "The factorial of a positive integer n is the product of all positive integers less than or equal to n. For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1. We make a clumsy factorial using the integers in decreasing order by swapping out the multiply operations for a fixed rotation of operations with multiply &#39;*&#39;, divide &#39;/&#39;, add &#39;+&#39;, and subtract &#39;-&#39; in this order. For example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1. However, these operations are still applied using the usual order of operations of arithmetic. We do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right. Additionally, the division that we use is floor division such that 10 * 9 / 8 = 90 / 8 = 11. Given an integer n, return the clumsy factorial of n. &nbsp; Example 1: Input: n = 4 Output: 7 Explanation: 7 = 4 * 3 / 2 + 1 Example 2: Input: n = 10 Output: 12 Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1 &nbsp; Constraints: 1 &lt;= n &lt;= 104"
    },
    {
      "number": 1007,
      "title": "Minimum Domino Rotations For Equal Row",
      "titleSlug": "minimum-domino-rotations-for-equal-row",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Greedy"
      ],
      "description": "In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.) We may rotate the ith domino, so that tops[i] and bottoms[i] swap values. Return the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same. If it cannot be done, return -1. &nbsp; Example 1: Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2] Output: 2 Explanation: The first figure represents the dominoes as given by tops and bottoms: before we do any rotations. If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure. Example 2: Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4] Output: -1 Explanation: In this case, it is not possible to rotate the dominoes to make one row of values equal. &nbsp; Constraints: 2 &lt;= tops.length &lt;= 2 * 104 bottoms.length == tops.length 1 &lt;= tops[i], bottoms[i] &lt;= 6"
    },
    {
      "number": 1008,
      "title": "Construct Binary Search Tree from Preorder Traversal",
      "titleSlug": "construct-binary-search-tree-from-preorder-traversal",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Stack",
        "Tree",
        "Binary Search Tree",
        "Monotonic Stack",
        "Binary Tree"
      ],
      "description": "Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root. It is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases. A binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, and any descendant of Node.right has a value strictly greater than Node.val. A preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right. &nbsp; Example 1: Input: preorder = [8,5,1,7,10,12] Output: [8,5,10,1,7,null,12] Example 2: Input: preorder = [1,3] Output: [1,null,3] &nbsp; Constraints: 1 &lt;= preorder.length &lt;= 100 1 &lt;= preorder[i] &lt;= 1000 All the values of preorder are unique."
    },
    {
      "number": 1009,
      "title": "Complement of Base 10 Integer",
      "titleSlug": "complement-of-base-10-integer",
      "difficulty": "Easy",
      "tags": [
        "Bit Manipulation"
      ],
      "description": "The complement of an integer is the integer you get when you flip all the 0&#39;s to 1&#39;s and all the 1&#39;s to 0&#39;s in its binary representation. For example, The integer 5 is &quot;101&quot; in binary and its complement is &quot;010&quot; which is the integer 2. Given an integer n, return its complement. &nbsp; Example 1: Input: n = 5 Output: 2 Explanation: 5 is &quot;101&quot; in binary, with complement &quot;010&quot; in binary, which is 2 in base-10. Example 2: Input: n = 7 Output: 0 Explanation: 7 is &quot;111&quot; in binary, with complement &quot;000&quot; in binary, which is 0 in base-10. Example 3: Input: n = 10 Output: 5 Explanation: 10 is &quot;1010&quot; in binary, with complement &quot;0101&quot; in binary, which is 5 in base-10. &nbsp; Constraints: 0 &lt;= n &lt; 109 &nbsp; Note: This question is the same as 476: https://leetcode.com/problems/number-complement/"
    },
    {
      "number": 1010,
      "title": "Pairs of Songs With Total Durations Divisible by 60",
      "titleSlug": "pairs-of-songs-with-total-durations-divisible-by-60",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Counting"
      ],
      "description": "You are given a list of songs where the ith song has a duration of time[i] seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i &lt; j with (time[i] + time[j]) % 60 == 0. &nbsp; Example 1: Input: time = [30,20,150,100,40] Output: 3 Explanation: Three pairs have a total duration divisible by 60: (time[0] = 30, time[2] = 150): total duration 180 (time[1] = 20, time[3] = 100): total duration 120 (time[1] = 20, time[4] = 40): total duration 60 Example 2: Input: time = [60,60,60] Output: 3 Explanation: All three pairs have a total duration of 120, which is divisible by 60. &nbsp; Constraints: 1 &lt;= time.length &lt;= 6 * 104 1 &lt;= time[i] &lt;= 500"
    },
    {
      "number": 1011,
      "title": "Capacity To Ship Packages Within D Days",
      "titleSlug": "capacity-to-ship-packages-within-d-days",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search"
      ],
      "description": "A conveyor belt has packages that must be shipped from one port to another within days days. The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship. Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days. &nbsp; Example 1: Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5 Output: 15 Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this: 1st day: 1, 2, 3, 4, 5 2nd day: 6, 7 3rd day: 8 4th day: 9 5th day: 10 Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. Example 2: Input: weights = [3,2,2,4,1,4], days = 3 Output: 6 Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this: 1st day: 3, 2 2nd day: 2, 4 3rd day: 1, 4 Example 3: Input: weights = [1,2,3,1,1], days = 4 Output: 3 Explanation: 1st day: 1 2nd day: 2 3rd day: 3 4th day: 1, 1 &nbsp; Constraints: 1 &lt;= days &lt;= weights.length &lt;= 5 * 104 1 &lt;= weights[i] &lt;= 500"
    },
    {
      "number": 1012,
      "title": "Numbers With Repeated Digits",
      "titleSlug": "numbers-with-repeated-digits",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "Dynamic Programming"
      ],
      "description": "Given an integer n, return the number of positive integers in the range [1, n] that have at least one repeated digit. &nbsp; Example 1: Input: n = 20 Output: 1 Explanation: The only positive number (&lt;= 20) with at least 1 repeated digit is 11. Example 2: Input: n = 100 Output: 10 Explanation: The positive numbers (&lt;= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100. Example 3: Input: n = 1000 Output: 262 &nbsp; Constraints: 1 &lt;= n &lt;= 109"
    },
    {
      "number": 1013,
      "title": "Partition Array Into Three Parts With Equal Sum",
      "titleSlug": "partition-array-into-three-parts-with-equal-sum",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Greedy"
      ],
      "description": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums. Formally, we can partition the array if we can find indexes i + 1 &lt; j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]) &nbsp; Example 1: Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1] Output: true Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1 Example 2: Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1] Output: false Example 3: Input: arr = [3,3,6,5,-2,2,5,1,-9,4] Output: true Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4 &nbsp; Constraints: 3 &lt;= arr.length &lt;= 5 * 104 -104 &lt;= arr[i] &lt;= 104"
    },
    {
      "number": 1014,
      "title": "Best Sightseeing Pair",
      "titleSlug": "best-sightseeing-pair",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them. The score of a pair (i &lt; j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them. Return the maximum score of a pair of sightseeing spots. &nbsp; Example 1: Input: values = [8,1,5,2,6] Output: 11 Explanation: i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11 Example 2: Input: values = [1,2] Output: 2 &nbsp; Constraints: 2 &lt;= values.length &lt;= 5 * 104 1 &lt;= values[i] &lt;= 1000"
    },
    {
      "number": 1015,
      "title": "Smallest Integer Divisible by K",
      "titleSlug": "smallest-integer-divisible-by-k",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Math"
      ],
      "description": "Given a positive integer k, you need to find the length of the smallest positive integer n such that n is divisible by k, and n only contains the digit 1. Return the length of n. If there is no such n, return -1. Note: n may not fit in a 64-bit signed integer. &nbsp; Example 1: Input: k = 1 Output: 1 Explanation: The smallest answer is n = 1, which has length 1. Example 2: Input: k = 2 Output: -1 Explanation: There is no such positive integer n divisible by 2. Example 3: Input: k = 3 Output: 3 Explanation: The smallest answer is n = 111, which has length 3. &nbsp; Constraints: 1 &lt;= k &lt;= 105"
    },
    {
      "number": 1016,
      "title": "Binary String With Substrings Representing 1 To N",
      "titleSlug": "binary-string-with-substrings-representing-1-to-n",
      "difficulty": "Medium",
      "tags": [
        "String"
      ],
      "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise. A substring is a contiguous sequence of characters within a string. &nbsp; Example 1: Input: s = \"0110\", n = 3 Output: true Example 2: Input: s = \"0110\", n = 4 Output: false &nbsp; Constraints: 1 &lt;= s.length &lt;= 1000 s[i] is either &#39;0&#39; or &#39;1&#39;. 1 &lt;= n &lt;= 109"
    },
    {
      "number": 1017,
      "title": "Convert to Base -2",
      "titleSlug": "convert-to-base-2",
      "difficulty": "Medium",
      "tags": [
        "Math"
      ],
      "description": "Given an integer n, return a binary string representing its representation in base -2. Note that the returned string should not have leading zeros unless the string is &quot;0&quot;. &nbsp; Example 1: Input: n = 2 Output: &quot;110&quot; Explantion: (-2)2 + (-2)1 = 2 Example 2: Input: n = 3 Output: &quot;111&quot; Explantion: (-2)2 + (-2)1 + (-2)0 = 3 Example 3: Input: n = 4 Output: &quot;100&quot; Explantion: (-2)2 = 4 &nbsp; Constraints: 0 &lt;= n &lt;= 109"
    },
    {
      "number": 1018,
      "title": "Binary Prefix Divisible By 5",
      "titleSlug": "binary-prefix-divisible-by-5",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Bit Manipulation"
      ],
      "description": "You are given a binary array nums (0-indexed). We define xi as the number whose binary representation is the subarray nums[0..i] (from most-significant-bit to least-significant-bit). For example, if nums = [1,0,1], then x0 = 1, x1 = 2, and x2 = 5. Return an array of booleans answer where answer[i] is true if xi is divisible by 5. &nbsp; Example 1: Input: nums = [0,1,1] Output: [true,false,false] Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10. Only the first number is divisible by 5, so answer[0] is true. Example 2: Input: nums = [1,1,1] Output: [false,false,false] &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 nums[i] is either 0 or 1."
    },
    {
      "number": 1019,
      "title": "Next Greater Node In Linked List",
      "titleSlug": "next-greater-node-in-linked-list",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Linked List",
        "Stack",
        "Monotonic Stack"
      ],
      "description": "You are given the head of a linked list with n nodes. For each node in the list, find the value of the next greater node. That is, for each node, find the value of the first node that is next to it and has a strictly larger value than it. Return an integer array answer where answer[i] is the value of the next greater node of the ith node (1-indexed). If the ith node does not have a next greater node, set answer[i] = 0. &nbsp; Example 1: Input: head = [2,1,5] Output: [5,5,0] Example 2: Input: head = [2,7,4,3,5] Output: [7,0,5,5,0] &nbsp; Constraints: The number of nodes in the list is n. 1 &lt;= n &lt;= 104 1 &lt;= Node.val &lt;= 109"
    },
    {
      "number": 1020,
      "title": "Number of Enclaves",
      "titleSlug": "number-of-enclaves",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Matrix"
      ],
      "description": "You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell. A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid. Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves. &nbsp; Example 1: Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] Output: 3 Explanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary. Example 2: Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] Output: 0 Explanation: All 1s are either on the boundary or can reach the boundary. &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 500 grid[i][j] is either 0 or 1."
    },
    {
      "number": 1021,
      "title": "Remove Outermost Parentheses",
      "titleSlug": "remove-outermost-parentheses",
      "difficulty": "Easy",
      "tags": [
        "String",
        "Stack"
      ],
      "description": "A valid parentheses string is either empty &quot;&quot;, &quot;(&quot; + A + &quot;)&quot;, or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, &quot;&quot;, &quot;()&quot;, &quot;(())()&quot;, and &quot;(()(()))&quot; are all valid parentheses strings. A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings. Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings. Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s. &nbsp; Example 1: Input: s = &quot;(()())(())&quot; Output: &quot;()()()&quot; Explanation: The input string is &quot;(()())(())&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot;. After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;. Example 2: Input: s = &quot;(()())(())(()(()))&quot; Output: &quot;()()()()(())&quot; Explanation: The input string is &quot;(()())(())(()(()))&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;. After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;. Example 3: Input: s = &quot;()()&quot; Output: &quot;&quot; Explanation: The input string is &quot;()()&quot;, with primitive decomposition &quot;()&quot; + &quot;()&quot;. After removing outer parentheses of each part, this is &quot;&quot; + &quot;&quot; = &quot;&quot;. &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s[i] is either &#39;(&#39; or &#39;)&#39;. s is a valid parentheses string."
    },
    {
      "number": 1022,
      "title": "Sum of Root To Leaf Binary Numbers",
      "titleSlug": "sum-of-root-to-leaf-binary-numbers",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1, then this could represent 01101 in binary, which is 13. For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers. The test cases are generated so that the answer fits in a 32-bits integer. &nbsp; Example 1: Input: root = [1,0,1,0,1,0,1] Output: 22 Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 Example 2: Input: root = [0] Output: 0 &nbsp; Constraints: The number of nodes in the tree is in the range [1, 1000]. Node.val is 0 or 1."
    },
    {
      "number": 1023,
      "title": "Camelcase Matching",
      "titleSlug": "camelcase-matching",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "String",
        "Trie",
        "String Matching"
      ],
      "description": "Given an array of strings queries and a string pattern, return a boolean array answer where answer[i] is true if queries[i] matches pattern, and false otherwise. A query word queries[i] matches pattern if you can insert lowercase English letters into the pattern so that it equals the query. You may insert a character at any position in pattern or you may choose not to insert any characters at all. &nbsp; Example 1: Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot; Output: [true,false,true,true,false] Explanation: &quot;FooBar&quot; can be generated like this &quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;. &quot;FootBall&quot; can be generated like this &quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;. &quot;FrameBuffer&quot; can be generated like this &quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;. Example 2: Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBa&quot; Output: [true,false,true,false,false] Explanation: &quot;FooBar&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot;. &quot;FootBall&quot; can be generated like this &quot;Fo&quot; + &quot;ot&quot; + &quot;Ba&quot; + &quot;ll&quot;. Example 3: Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBaT&quot; Output: [false,true,false,false,false] Explanation: &quot;FooBarTest&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot; + &quot;T&quot; + &quot;est&quot;. &nbsp; Constraints: 1 &lt;= pattern.length, queries.length &lt;= 100 1 &lt;= queries[i].length &lt;= 100 queries[i] and pattern consist of English letters."
    },
    {
      "number": 1024,
      "title": "Video Stitching",
      "titleSlug": "video-stitching",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Greedy"
      ],
      "description": "You are given a series of video clips from a sporting event that lasted time seconds. These video clips can be overlapping with each other and have varying lengths. Each video clip is described by an array clips where clips[i] = [starti, endi] indicates that the ith clip started at starti and ended at endi. We can cut these clips into segments freely. For example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7]. Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event [0, time]. If the task is impossible, return -1. &nbsp; Example 1: Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10 Output: 3 Explanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips. Then, we can reconstruct the sporting event as follows: We cut [1,9] into segments [1,2] + [2,8] + [8,9]. Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10]. Example 2: Input: clips = [[0,1],[1,2]], time = 5 Output: -1 Explanation: We cannot cover [0,5] with only [0,1] and [1,2]. Example 3: Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9 Output: 3 Explanation: We can take clips [0,4], [4,7], and [6,9]. &nbsp; Constraints: 1 &lt;= clips.length &lt;= 100 0 &lt;= starti &lt;= endi &lt;= 100 1 &lt;= time &lt;= 100"
    },
    {
      "number": 1025,
      "title": "Divisor Game",
      "titleSlug": "divisor-game",
      "difficulty": "Easy",
      "tags": [
        "Math",
        "Dynamic Programming",
        "Brainteaser",
        "Game Theory"
      ],
      "description": "Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number n on the chalkboard. On each player&#39;s turn, that player makes a move consisting of: Choosing any x with 0 &lt; x &lt; n and n % x == 0. Replacing the number n on the chalkboard with n - x. Also, if a player cannot make a move, they lose the game. Return true if and only if Alice wins the game, assuming both players play optimally. &nbsp; Example 1: Input: n = 2 Output: true Explanation: Alice chooses 1, and Bob has no more moves. Example 2: Input: n = 3 Output: false Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves. &nbsp; Constraints: 1 &lt;= n &lt;= 1000"
    },
    {
      "number": 1026,
      "title": "Maximum Difference Between Node and Ancestor",
      "titleSlug": "maximum-difference-between-node-and-ancestor",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b. A node a is an ancestor of b if either: any child of a is equal to b&nbsp;or any child of a is an ancestor of b. &nbsp; Example 1: Input: root = [8,3,10,1,6,null,14,null,null,4,7,13] Output: 7 Explanation: We have various ancestor-node differences, some of which are given below : |8 - 3| = 5 |3 - 7| = 4 |8 - 1| = 7 |10 - 13| = 3 Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7. Example 2: Input: root = [1,null,2,null,0,3] Output: 3 &nbsp; Constraints: The number of nodes in the tree is in the range [2, 5000]. 0 &lt;= Node.val &lt;= 105"
    },
    {
      "number": 1027,
      "title": "Longest Arithmetic Subsequence",
      "titleSlug": "longest-arithmetic-subsequence",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Binary Search",
        "Dynamic Programming"
      ],
      "description": "Given an array nums of integers, return the length of the longest arithmetic subsequence in nums. Note that: A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. A sequence seq is arithmetic if seq[i + 1] - seq[i] are all the same value (for 0 &lt;= i &lt; seq.length - 1). &nbsp; Example 1: Input: nums = [3,6,9,12] Output: 4 Explanation: The whole array is an arithmetic sequence with steps of length = 3. Example 2: Input: nums = [9,4,7,2,10] Output: 3 Explanation: The longest arithmetic subsequence is [4,7,10]. Example 3: Input: nums = [20,1,15,3,10,5,8] Output: 4 Explanation: The longest arithmetic subsequence is [20,15,10,5]. &nbsp; Constraints: 2 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 500"
    },
    {
      "number": 1028,
      "title": "Recover a Tree From Preorder Traversal",
      "titleSlug": "recover-a-tree-from-preorder-traversal",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "We run a&nbsp;preorder&nbsp;depth-first search (DFS) on the root of a binary tree. At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.&nbsp; If the depth of a node is D, the depth of its immediate child is D + 1.&nbsp; The depth of the root node is 0. If a node has only one child, that child is guaranteed to be the left child. Given the output traversal of this traversal, recover the tree and return its root. &nbsp; Example 1: Input: traversal = &quot;1-2--3--4-5--6--7&quot; Output: [1,2,5,3,4,6,7] Example 2: Input: traversal = &quot;1-2--3---4-5--6---7&quot; Output: [1,2,5,3,null,6,null,4,null,7] Example 3: Input: traversal = &quot;1-401--349---90--88&quot; Output: [1,401,null,349,88,90] &nbsp; Constraints: The number of nodes in the original tree is in the range [1, 1000]. 1 &lt;= Node.val &lt;= 109"
    },
    {
      "number": 1029,
      "title": "Two City Scheduling",
      "titleSlug": "two-city-scheduling",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Greedy",
        "Sorting"
      ],
      "description": "A company is planning to interview 2n people. Given the array costs where costs[i] = [aCosti, bCosti],&nbsp;the cost of flying the ith person to city a is aCosti, and the cost of flying the ith person to city b is bCosti. Return the minimum cost to fly every person to a city such that exactly n people arrive in each city. &nbsp; Example 1: Input: costs = [[10,20],[30,200],[400,50],[30,20]] Output: 110 Explanation: The first person goes to city A for a cost of 10. The second person goes to city A for a cost of 30. The third person goes to city B for a cost of 50. The fourth person goes to city B for a cost of 20. The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city. Example 2: Input: costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]] Output: 1859 Example 3: Input: costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]] Output: 3086 &nbsp; Constraints: 2 * n == costs.length 2 &lt;= costs.length &lt;= 100 costs.length is even. 1 &lt;= aCosti, bCosti &lt;= 1000"
    },
    {
      "number": 1030,
      "title": "Matrix Cells in Distance Order",
      "titleSlug": "matrix-cells-in-distance-order",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math",
        "Geometry",
        "Sorting",
        "Matrix"
      ],
      "description": "You are given four integers row, cols, rCenter, and cCenter. There is a rows x cols matrix and you are on the cell with the coordinates (rCenter, cCenter). Return the coordinates of all cells in the matrix, sorted by their distance from (rCenter, cCenter) from the smallest distance to the largest distance. You may return the answer in any order that satisfies this condition. The distance between two cells (r1, c1) and (r2, c2) is |r1 - r2| + |c1 - c2|. &nbsp; Example 1: Input: rows = 1, cols = 2, rCenter = 0, cCenter = 0 Output: [[0,0],[0,1]] Explanation: The distances from (0, 0) to other cells are: [0,1] Example 2: Input: rows = 2, cols = 2, rCenter = 0, cCenter = 1 Output: [[0,1],[0,0],[1,1],[1,0]] Explanation: The distances from (0, 1) to other cells are: [0,1,1,2] The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct. Example 3: Input: rows = 2, cols = 3, rCenter = 1, cCenter = 2 Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]] Explanation: The distances from (1, 2) to other cells are: [0,1,1,2,2,3] There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]. &nbsp; Constraints: 1 &lt;= rows, cols &lt;= 100 0 &lt;= rCenter &lt; rows 0 &lt;= cCenter &lt; cols"
    },
    {
      "number": 1031,
      "title": "Maximum Sum of Two Non-Overlapping Subarrays",
      "titleSlug": "maximum-sum-of-two-non-overlapping-subarrays",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Sliding Window"
      ],
      "description": "Given an integer array nums and two integers firstLen and secondLen, return the maximum sum of elements in two non-overlapping subarrays with lengths firstLen and secondLen. The array with length firstLen could occur before or after the array with length secondLen, but they have to be non-overlapping. A subarray is a contiguous part of an array. &nbsp; Example 1: Input: nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2 Output: 20 Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2. Example 2: Input: nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2 Output: 29 Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2. Example 3: Input: nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3 Output: 31 Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [0,3,8] with length 3. &nbsp; Constraints: 1 &lt;= firstLen, secondLen &lt;= 1000 2 &lt;= firstLen + secondLen &lt;= 1000 firstLen + secondLen &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000"
    },
    {
      "number": 1032,
      "title": "Stream of Characters",
      "titleSlug": "stream-of-characters",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "String",
        "Design",
        "Trie",
        "Data Stream"
      ],
      "description": "Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings words. For example, if words = [&quot;abc&quot;, &quot;xyz&quot;]&nbsp;and the stream added the four characters (one by one) &#39;a&#39;, &#39;x&#39;, &#39;y&#39;, and &#39;z&#39;, your algorithm should detect that the suffix &quot;xyz&quot; of the characters &quot;axyz&quot; matches &quot;xyz&quot; from words. Implement the StreamChecker class: StreamChecker(String[] words) Initializes the object with the strings array words. boolean query(char letter) Accepts a new character from the stream and returns true if any non-empty suffix from the stream forms a word that is in words. &nbsp; Example 1: Input [&quot;StreamChecker&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;] [[[&quot;cd&quot;, &quot;f&quot;, &quot;kl&quot;]], [&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;], [&quot;d&quot;], [&quot;e&quot;], [&quot;f&quot;], [&quot;g&quot;], [&quot;h&quot;], [&quot;i&quot;], [&quot;j&quot;], [&quot;k&quot;], [&quot;l&quot;]] Output [null, false, false, false, true, false, true, false, false, false, false, false, true] Explanation StreamChecker streamChecker = new StreamChecker([&quot;cd&quot;, &quot;f&quot;, &quot;kl&quot;]); streamChecker.query(&quot;a&quot;); // return False streamChecker.query(&quot;b&quot;); // return False streamChecker.query(&quot;c&quot;); // return False streamChecker.query(&quot;d&quot;); // return True, because &#39;cd&#39; is in the wordlist streamChecker.query(&quot;e&quot;); // return False streamChecker.query(&quot;f&quot;); // return True, because &#39;f&#39; is in the wordlist streamChecker.query(&quot;g&quot;); // return False streamChecker.query(&quot;h&quot;); // return False streamChecker.query(&quot;i&quot;); // return False streamChecker.query(&quot;j&quot;); // return False streamChecker.query(&quot;k&quot;); // return False streamChecker.query(&quot;l&quot;); // return True, because &#39;kl&#39; is in the wordlist &nbsp; Constraints: 1 &lt;= words.length &lt;= 2000 1 &lt;= words[i].length &lt;= 200 words[i] consists of lowercase English letters. letter is a lowercase English letter. At most 4 * 104 calls will be made to query."
    },
    {
      "number": 1033,
      "title": "Moving Stones Until Consecutive",
      "titleSlug": "moving-stones-until-consecutive",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Brainteaser"
      ],
      "description": "There are three stones in different positions on the X-axis. You are given three integers a, b, and c, the positions of the stones. In one move, you pick up a stone at an endpoint (i.e., either the lowest or highest position stone), and move it to an unoccupied position between those endpoints. Formally, let&#39;s say the stones are currently at positions x, y, and z with x &lt; y &lt; z. You pick up the stone at either position x or position z, and move that stone to an integer position k, with x &lt; k &lt; z and k != y. The game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions). Return an integer array answer of length 2 where: answer[0] is the minimum number of moves you can play, and answer[1] is the maximum number of moves you can play. &nbsp; Example 1: Input: a = 1, b = 2, c = 5 Output: [1,2] Explanation: Move the stone from 5 to 3, or move the stone from 5 to 4 to 3. Example 2: Input: a = 4, b = 3, c = 2 Output: [0,0] Explanation: We cannot make any moves. Example 3: Input: a = 3, b = 5, c = 1 Output: [1,2] Explanation: Move the stone from 1 to 4; or move the stone from 1 to 2 to 4. &nbsp; Constraints: 1 &lt;= a, b, c &lt;= 100 a, b, and c have different values."
    },
    {
      "number": 1034,
      "title": "Coloring A Border",
      "titleSlug": "coloring-a-border",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Depth-First Search",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "You are given an m x n integer matrix grid, and three integers row, col, and color. Each value in the grid represents the color of the grid square at that location. Two squares are called adjacent if they are next to each other in any of the 4 directions. Two squares belong to the same connected component if they have the same color and they are adjacent. The border of a connected component is all the squares in the connected component that are either adjacent to (at least) a square not in the component, or on the boundary of the grid (the first or last row or column). You should color the border of the connected component that contains the square grid[row][col] with color. Return the final grid. &nbsp; Example 1: Input: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3 Output: [[3,3],[3,2]] Example 2: Input: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3 Output: [[1,3,3],[2,3,3]] Example 3: Input: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2 Output: [[2,2,2],[2,1,2],[2,2,2]] &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 50 1 &lt;= grid[i][j], color &lt;= 1000 0 &lt;= row &lt; m 0 &lt;= col &lt; n"
    },
    {
      "number": 1035,
      "title": "Uncrossed Lines",
      "titleSlug": "uncrossed-lines",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "You are given two integer arrays nums1 and nums2. We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines. We may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that: nums1[i] == nums2[j], and the line we draw does not intersect any other connecting (non-horizontal) line. Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line). Return the maximum number of connecting lines we can draw in this way. &nbsp; Example 1: Input: nums1 = [1,4,2], nums2 = [1,2,4] Output: 2 Explanation: We can draw 2 uncrossed lines as in the diagram. We cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2. Example 2: Input: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2] Output: 3 Example 3: Input: nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1] Output: 2 &nbsp; Constraints: 1 &lt;= nums1.length, nums2.length &lt;= 500 1 &lt;= nums1[i], nums2[j] &lt;= 2000"
    },
    {
      "number": 1036,
      "title": "Escape a Large Maze",
      "titleSlug": "escape-a-large-maze",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Depth-First Search",
        "Breadth-First Search"
      ],
      "description": "There is a 1 million by 1 million grid on an XY-plane, and the coordinates of each grid square are (x, y). We start at the source = [sx, sy] square and want to reach the target = [tx, ty] square. There is also an array of blocked squares, where each blocked[i] = [xi, yi] represents a blocked square with coordinates (xi, yi). Each move, we can walk one square north, east, south, or west if the square is not in the array of blocked squares. We are also not allowed to walk outside of the grid. Return true if and only if it is possible to reach the target square from the source square through a sequence of valid moves. &nbsp; Example 1: Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2] Output: false Explanation: The target square is inaccessible starting from the source square because we cannot move. We cannot move north or east because those squares are blocked. We cannot move south or west because we cannot go outside of the grid. Example 2: Input: blocked = [], source = [0,0], target = [999999,999999] Output: true Explanation: Because there are no blocked cells, it is possible to reach the target square. &nbsp; Constraints: 0 &lt;= blocked.length &lt;= 200 blocked[i].length == 2 0 &lt;= xi, yi &lt; 106 source.length == target.length == 2 0 &lt;= sx, sy, tx, ty &lt; 106 source != target It is guaranteed that source and target are not blocked."
    },
    {
      "number": 1037,
      "title": "Valid Boomerang",
      "titleSlug": "valid-boomerang",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math",
        "Geometry"
      ],
      "description": "Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang. A boomerang is a set of three points that are all distinct and not in a straight line. &nbsp; Example 1: Input: points = [[1,1],[2,3],[3,2]] Output: true Example 2: Input: points = [[1,1],[2,2],[3,3]] Output: false &nbsp; Constraints: points.length == 3 points[i].length == 2 0 &lt;= xi, yi &lt;= 100"
    },
    {
      "number": 1038,
      "title": "Binary Search Tree to Greater Sum Tree",
      "titleSlug": "binary-search-tree-to-greater-sum-tree",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only nodes with keys less than the node&#39;s key. The right subtree of a node contains only nodes with keys greater than the node&#39;s key. Both the left and right subtrees must also be binary search trees. &nbsp; Example 1: Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] Example 2: Input: root = [0,null,1] Output: [1,null,1] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 100]. 0 &lt;= Node.val &lt;= 100 All the values in the tree are unique. &nbsp; Note: This question is the same as 538: https://leetcode.com/problems/convert-bst-to-greater-tree/"
    },
    {
      "number": 1039,
      "title": "Minimum Score Triangulation of Polygon",
      "titleSlug": "minimum-score-triangulation-of-polygon",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "You have a convex n-sided polygon where each vertex has an integer value. You are given an integer array values where values[i] is the value of the ith vertex in clockwise order. Polygon triangulation is a process where you divide a polygon into a set of triangles and the vertices of each triangle must also be vertices of the original polygon. Note that no other shapes other than triangles are allowed in the division. This process will result in n - 2 triangles. You will triangulate the polygon. For each triangle, the weight of that triangle is the product of the values at its vertices. The total score of the triangulation is the sum of these weights over all n - 2 triangles. Return the minimum possible score that you can achieve with some triangulation of the polygon. &nbsp; Example 1: Input: values = [1,2,3] Output: 6 Explanation: The polygon is already triangulated, and the score of the only triangle is 6. Example 2: Input: values = [3,7,4,5] Output: 144 Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144. The minimum score is 144. Example 3: Input: values = [1,3,1,4,1,5] Output: 13 Explanation: The minimum score triangulation is 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13. &nbsp; Constraints: n == values.length 3 &lt;= n &lt;= 50 1 &lt;= values[i] &lt;= 100"
    },
    {
      "number": 1040,
      "title": "Moving Stones Until Consecutive II",
      "titleSlug": "moving-stones-until-consecutive-ii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math",
        "Sliding Window",
        "Sorting"
      ],
      "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones. Call a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone. In particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone. The game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions). Return an integer array answer of length 2 where: answer[0] is the minimum number of moves you can play, and answer[1] is the maximum number of moves you can play. &nbsp; Example 1: Input: stones = [7,4,9] Output: [1,2] Explanation: We can move 4 -&gt; 8 for one move to finish the game. Or, we can move 9 -&gt; 5, 4 -&gt; 6 for two moves to finish the game. Example 2: Input: stones = [6,5,4,3,10] Output: [2,3] Explanation: We can move 3 -&gt; 8 then 10 -&gt; 7 to finish the game. Or, we can move 3 -&gt; 7, 4 -&gt; 8, 5 -&gt; 9 to finish the game. Notice we cannot move 10 -&gt; 2 to finish the game, because that would be an illegal move. &nbsp; Constraints: 3 &lt;= stones.length &lt;= 104 1 &lt;= stones[i] &lt;= 109 All the values of stones are unique."
    },
    {
      "number": 1041,
      "title": "Robot Bounded In Circle",
      "titleSlug": "robot-bounded-in-circle",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "String",
        "Simulation"
      ],
      "description": "On an infinite plane, a robot initially stands at (0, 0) and faces north. Note that: The north direction is the positive direction of the y-axis. The south direction is the negative direction of the y-axis. The east direction is the positive direction of the x-axis. The west direction is the negative direction of the x-axis. The robot can receive one of three instructions: &quot;G&quot;: go straight 1 unit. &quot;L&quot;: turn 90 degrees to the left (i.e., anti-clockwise direction). &quot;R&quot;: turn 90 degrees to the right (i.e., clockwise direction). The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in the plane such that the robot never leaves the circle. &nbsp; Example 1: Input: instructions = &quot;GGLLGG&quot; Output: true Explanation: The robot is initially at (0, 0) facing the north direction. &quot;G&quot;: move one step. Position: (0, 1). Direction: North. &quot;G&quot;: move one step. Position: (0, 2). Direction: North. &quot;L&quot;: turn 90 degrees anti-clockwise. Position: (0, 2). Direction: West. &quot;L&quot;: turn 90 degrees anti-clockwise. Position: (0, 2). Direction: South. &quot;G&quot;: move one step. Position: (0, 1). Direction: South. &quot;G&quot;: move one step. Position: (0, 0). Direction: South. Repeating the instructions, the robot goes into the cycle: (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 1) --&gt; (0, 0). Based on that, we return true. Example 2: Input: instructions = &quot;GG&quot; Output: false Explanation: The robot is initially at (0, 0) facing the north direction. &quot;G&quot;: move one step. Position: (0, 1). Direction: North. &quot;G&quot;: move one step. Position: (0, 2). Direction: North. Repeating the instructions, keeps advancing in the north direction and does not go into cycles. Based on that, we return false. Example 3: Input: instructions = &quot;GL&quot; Output: true Explanation: The robot is initially at (0, 0) facing the north direction. &quot;G&quot;: move one step. Position: (0, 1). Direction: North. &quot;L&quot;: turn 90 degrees anti-clockwise. Position: (0, 1). Direction: West. &quot;G&quot;: move one step. Position: (-1, 1). Direction: West. &quot;L&quot;: turn 90 degrees anti-clockwise. Position: (-1, 1). Direction: South. &quot;G&quot;: move one step. Position: (-1, 0). Direction: South. &quot;L&quot;: turn 90 degrees anti-clockwise. Position: (-1, 0). Direction: East. &quot;G&quot;: move one step. Position: (0, 0). Direction: East. &quot;L&quot;: turn 90 degrees anti-clockwise. Position: (0, 0). Direction: North. Repeating the instructions, the robot goes into the cycle: (0, 0) --&gt; (0, 1) --&gt; (-1, 1) --&gt; (-1, 0) --&gt; (0, 0). Based on that, we return true. &nbsp; Constraints: 1 &lt;= instructions.length &lt;= 100 instructions[i] is &#39;G&#39;, &#39;L&#39; or, &#39;R&#39;."
    },
    {
      "number": 1042,
      "title": "Flower Planting With No Adjacent",
      "titleSlug": "flower-planting-with-no-adjacent",
      "difficulty": "Medium",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Graph"
      ],
      "description": "You have n gardens, labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes a bidirectional path between garden xi to garden yi. In each garden, you want to plant one of 4 types of flowers. All gardens have at most 3 paths coming into or leaving it. Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers. Return any such a choice as an array answer, where answer[i] is the type of flower planted in the (i+1)th garden. The flower types are denoted 1, 2, 3, or 4. It is guaranteed an answer exists. &nbsp; Example 1: Input: n = 3, paths = [[1,2],[2,3],[3,1]] Output: [1,2,3] Explanation: Gardens 1 and 2 have different types. Gardens 2 and 3 have different types. Gardens 3 and 1 have different types. Hence, [1,2,3] is a valid answer. Other valid answers include [1,2,4], [1,4,2], and [3,2,1]. Example 2: Input: n = 4, paths = [[1,2],[3,4]] Output: [1,2,1,2] Example 3: Input: n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]] Output: [1,2,3,4] &nbsp; Constraints: 1 &lt;= n &lt;= 104 0 &lt;= paths.length &lt;= 2 * 104 paths[i].length == 2 1 &lt;= xi, yi &lt;= n xi != yi Every garden has at most 3 paths coming into or leaving it."
    },
    {
      "number": 1043,
      "title": "Partition Array for Maximum Sum",
      "titleSlug": "partition-array-for-maximum-sum",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray. Return the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer. &nbsp; Example 1: Input: arr = [1,15,7,9,2,5,10], k = 3 Output: 84 Explanation: arr becomes [15,15,15,9,10,10,10] Example 2: Input: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4 Output: 83 Example 3: Input: arr = [1], k = 1 Output: 1 &nbsp; Constraints: 1 &lt;= arr.length &lt;= 500 0 &lt;= arr[i] &lt;= 109 1 &lt;= k &lt;= arr.length"
    },
    {
      "number": 1044,
      "title": "Longest Duplicate Substring",
      "titleSlug": "longest-duplicate-substring",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Binary Search",
        "Sliding Window",
        "Rolling Hash",
        "Suffix Array",
        "Hash Function"
      ],
      "description": "Given a string s, consider all duplicated substrings: (contiguous) substrings of s that occur 2 or more times.&nbsp;The occurrences&nbsp;may overlap. Return any duplicated&nbsp;substring that has the longest possible length.&nbsp;If s does not have a duplicated substring, the answer is &quot;&quot;. &nbsp; Example 1: Input: s = \"banana\" Output: \"ana\" Example 2: Input: s = \"abcd\" Output: \"\" &nbsp; Constraints: 2 &lt;= s.length &lt;= 3 * 104 s consists of lowercase English letters."
    },
    {
      "number": 1045,
      "title": "Customers Who Bought All Products",
      "titleSlug": "customers-who-bought-all-products",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Customer +-------------+---------+ | Column Name | Type | +-------------+---------+ | customer_id | int | | product_key | int | +-------------+---------+ This table may contain duplicates rows. customer_id is not NULL. product_key is a foreign key (reference column) to Product table. &nbsp; Table: Product +-------------+---------+ | Column Name | Type | +-------------+---------+ | product_key | int | +-------------+---------+ product_key is the primary key (column with unique values) for this table. &nbsp; Write a solution to report the customer ids from the Customer table that bought all the products in the Product table. Return the result table in any order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Customer table: +-------------+-------------+ | customer_id | product_key | +-------------+-------------+ | 1 | 5 | | 2 | 6 | | 3 | 5 | | 3 | 6 | | 1 | 6 | +-------------+-------------+ Product table: +-------------+ | product_key | +-------------+ | 5 | | 6 | +-------------+ Output: +-------------+ | customer_id | +-------------+ | 1 | | 3 | +-------------+ Explanation: The customers who bought all the products (5 and 6) are customers with IDs 1 and 3."
    },
    {
      "number": 1046,
      "title": "Last Stone Weight",
      "titleSlug": "last-stone-weight",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Heap (Priority Queue)"
      ],
      "description": "You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;= y. The result of this smash is: If x == y, both stones are destroyed, and If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x. At the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0. &nbsp; Example 1: Input: stones = [2,7,4,1,8,1] Output: 1 Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that&#39;s the value of the last stone. Example 2: Input: stones = [1] Output: 1 &nbsp; Constraints: 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 1000"
    },
    {
      "number": 1047,
      "title": "Remove All Adjacent Duplicates In String",
      "titleSlug": "remove-all-adjacent-duplicates-in-string",
      "difficulty": "Easy",
      "tags": [
        "String",
        "Stack"
      ],
      "description": "You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them. We repeatedly make duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique. &nbsp; Example 1: Input: s = &quot;abbaca&quot; Output: &quot;ca&quot; Explanation: For example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is &quot;aaca&quot;, of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;. Example 2: Input: s = &quot;azxxzy&quot; Output: &quot;ay&quot; &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s consists of lowercase English letters."
    },
    {
      "number": 1048,
      "title": "Longest String Chain",
      "titleSlug": "longest-string-chain",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Two Pointers",
        "String",
        "Dynamic Programming",
        "Sorting"
      ],
      "description": "You are given an array of words where each word consists of lowercase English letters. wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB. For example, &quot;abc&quot; is a predecessor of &quot;abac&quot;, while &quot;cba&quot; is not a predecessor of &quot;bcad&quot;. A word chain is a sequence of words [word1, word2, ..., wordk] with k &gt;= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1. Return the length of the longest possible word chain with words chosen from the given list of words. &nbsp; Example 1: Input: words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;] Output: 4 Explanation: One of the longest word chains is [&quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;]. Example 2: Input: words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;] Output: 5 Explanation: All the words can be put in a word chain [&quot;xb&quot;, &quot;xbc&quot;, &quot;cxbc&quot;, &quot;pcxbc&quot;, &quot;pcxbcf&quot;]. Example 3: Input: words = [&quot;abcd&quot;,&quot;dbqca&quot;] Output: 1 Explanation: The trivial word chain [&quot;abcd&quot;] is one of the longest word chains. [&quot;abcd&quot;,&quot;dbqca&quot;] is not a valid word chain because the ordering of the letters is changed. &nbsp; Constraints: 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 16 words[i] only consists of lowercase English letters."
    },
    {
      "number": 1049,
      "title": "Last Stone Weight II",
      "titleSlug": "last-stone-weight-ii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x &lt;= y. The result of this smash is: If x == y, both stones are destroyed, and If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x. At the end of the game, there is at most one stone left. Return the smallest possible weight of the left stone. If there are no stones left, return 0. &nbsp; Example 1: Input: stones = [2,7,4,1,8,1] Output: 1 Explanation: We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then, we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then, we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then, we can combine 1 and 1 to get 0, so the array converts to [1], then that&#39;s the optimal value. Example 2: Input: stones = [31,26,33,21,40] Output: 5 &nbsp; Constraints: 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 100"
    },
    {
      "number": 1050,
      "title": "Actors and Directors Who Cooperated At Least Three Times",
      "titleSlug": "actors-and-directors-who-cooperated-at-least-three-times",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: ActorDirector +-------------+---------+ | Column Name | Type | +-------------+---------+ | actor_id | int | | director_id | int | | timestamp | int | +-------------+---------+ timestamp is the primary key (column with unique values) for this table. &nbsp; Write a solution to find all the pairs (actor_id, director_id) where the actor has cooperated with the director at least three times. Return the result table in any order. The result format is in the following example. &nbsp; Example 1: Input: ActorDirector table: +-------------+-------------+-------------+ | actor_id | director_id | timestamp | +-------------+-------------+-------------+ | 1 | 1 | 0 | | 1 | 1 | 1 | | 1 | 1 | 2 | | 1 | 2 | 3 | | 1 | 2 | 4 | | 2 | 1 | 5 | | 2 | 1 | 6 | +-------------+-------------+-------------+ Output: +-------------+-------------+ | actor_id | director_id | +-------------+-------------+ | 1 | 1 | +-------------+-------------+ Explanation: The only pair is (1, 1) where they cooperated exactly 3 times."
    },
    {
      "number": 1051,
      "title": "Height Checker",
      "titleSlug": "height-checker",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Sorting",
        "Counting Sort"
      ],
      "description": "A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line. You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed). Return the number of indices where heights[i] != expected[i]. &nbsp; Example 1: Input: heights = [1,1,4,2,1,3] Output: 3 Explanation: heights: [1,1,4,2,1,3] expected: [1,1,1,2,3,4] Indices 2, 4, and 5 do not match. Example 2: Input: heights = [5,1,2,3,4] Output: 5 Explanation: heights: [5,1,2,3,4] expected: [1,2,3,4,5] All indices do not match. Example 3: Input: heights = [1,2,3,4,5] Output: 0 Explanation: heights: [1,2,3,4,5] expected: [1,2,3,4,5] All indices match. &nbsp; Constraints: 1 &lt;= heights.length &lt;= 100 1 &lt;= heights[i] &lt;= 100"
    },
    {
      "number": 1052,
      "title": "Grumpy Bookstore Owner",
      "titleSlug": "grumpy-bookstore-owner",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Sliding Window"
      ],
      "description": "There is a bookstore owner that has a store open for n minutes. You are given an integer array customers of length n where customers[i] is the number of the customers that enter the store at the start of the ith minute and all those customers leave after the end of that minute. During certain minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise. When the bookstore owner is grumpy, the customers entering during that minute are not satisfied. Otherwise, they are satisfied. The bookstore owner knows a secret technique to remain not grumpy for minutes consecutive minutes, but this technique can only be used once. Return the maximum number of customers that can be satisfied throughout the day. &nbsp; Example 1: Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3 Output: 16 Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16. Example 2: Input: customers = [1], grumpy = [0], minutes = 1 Output: 1 &nbsp; Constraints: n == customers.length == grumpy.length 1 &lt;= minutes &lt;= n &lt;= 2 * 104 0 &lt;= customers[i] &lt;= 1000 grumpy[i] is either 0 or 1."
    },
    {
      "number": 1053,
      "title": "Previous Permutation With One Swap",
      "titleSlug": "previous-permutation-with-one-swap",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Greedy"
      ],
      "description": "Given an array of positive integers arr (not necessarily distinct), return the lexicographically largest permutation that is smaller than arr, that can be made with exactly one swap. If it cannot be done, then return the same array. Note that a swap exchanges the positions of two numbers arr[i] and arr[j] &nbsp; Example 1: Input: arr = [3,2,1] Output: [3,1,2] Explanation: Swapping 2 and 1. Example 2: Input: arr = [1,1,5] Output: [1,1,5] Explanation: This is already the smallest permutation. Example 3: Input: arr = [1,9,4,6,7] Output: [1,7,4,6,9] Explanation: Swapping 9 and 7. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 104 1 &lt;= arr[i] &lt;= 104"
    },
    {
      "number": 1054,
      "title": "Distant Barcodes",
      "titleSlug": "distant-barcodes",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Greedy",
        "Sorting",
        "Heap (Priority Queue)",
        "Counting"
      ],
      "description": "In a warehouse, there is a row of barcodes, where the ith barcode is barcodes[i]. Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists. &nbsp; Example 1: Input: barcodes = [1,1,1,2,2,2] Output: [2,1,2,1,2,1] Example 2: Input: barcodes = [1,1,1,1,2,2,3,3] Output: [1,3,1,3,1,2,1,2] &nbsp; Constraints: 1 &lt;= barcodes.length &lt;= 10000 1 &lt;= barcodes[i] &lt;= 10000"
    },
    {
      "number": 1061,
      "title": "Lexicographically Smallest Equivalent String",
      "titleSlug": "lexicographically-smallest-equivalent-string",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Union Find"
      ],
      "description": "You are given two strings of the same length s1 and s2 and a string baseStr. We say s1[i] and s2[i] are equivalent characters. For example, if s1 = &quot;abc&quot; and s2 = &quot;cde&quot;, then we have &#39;a&#39; == &#39;c&#39;, &#39;b&#39; == &#39;d&#39;, and &#39;c&#39; == &#39;e&#39;. Equivalent characters follow the usual rules of any equivalence relation: Reflexivity: &#39;a&#39; == &#39;a&#39;. Symmetry: &#39;a&#39; == &#39;b&#39; implies &#39;b&#39; == &#39;a&#39;. Transitivity: &#39;a&#39; == &#39;b&#39; and &#39;b&#39; == &#39;c&#39; implies &#39;a&#39; == &#39;c&#39;. For example, given the equivalency information from s1 = &quot;abc&quot; and s2 = &quot;cde&quot;, &quot;acd&quot; and &quot;aab&quot; are equivalent strings of baseStr = &quot;eed&quot;, and &quot;aab&quot; is the lexicographically smallest equivalent string of baseStr. Return the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2. &nbsp; Example 1: Input: s1 = &quot;parker&quot;, s2 = &quot;morris&quot;, baseStr = &quot;parser&quot; Output: &quot;makkek&quot; Explanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i]. The characters in each group are equivalent and sorted in lexicographical order. So the answer is &quot;makkek&quot;. Example 2: Input: s1 = &quot;hello&quot;, s2 = &quot;world&quot;, baseStr = &quot;hold&quot; Output: &quot;hdld&quot; Explanation: Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r]. So only the second letter &#39;o&#39; in baseStr is changed to &#39;d&#39;, the answer is &quot;hdld&quot;. Example 3: Input: s1 = &quot;leetcode&quot;, s2 = &quot;programs&quot;, baseStr = &quot;sourcecode&quot; Output: &quot;aauaaaaada&quot; Explanation: We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except &#39;u&#39; and &#39;d&#39; are transformed to &#39;a&#39;, the answer is &quot;aauaaaaada&quot;. &nbsp; Constraints: 1 &lt;= s1.length, s2.length, baseStr &lt;= 1000 s1.length == s2.length s1, s2, and baseStr consist of lowercase English letters."
    },
    {
      "number": 1068,
      "title": "Product Sales Analysis I",
      "titleSlug": "product-sales-analysis-i",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Sales +-------------+-------+ | Column Name | Type | +-------------+-------+ | sale_id | int | | product_id | int | | year | int | | quantity | int | | price | int | +-------------+-------+ (sale_id, year) is the primary key (combination of columns with unique values) of this table. product_id is a foreign key (reference column) to Product table. Each row of this table shows a sale on the product product_id in a certain year. Note that the price is per unit. &nbsp; Table: Product +--------------+---------+ | Column Name | Type | +--------------+---------+ | product_id | int | | product_name | varchar | +--------------+---------+ product_id is the primary key (column with unique values) of this table. Each row of this table indicates the product name of each product. &nbsp; Write a solution to report the product_name, year, and price for each sale_id in the Sales table. Return the resulting table in any order. The result format is in the following example. &nbsp; Example 1: Input: Sales table: +---------+------------+------+----------+-------+ | sale_id | product_id | year | quantity | price | +---------+------------+------+----------+-------+ | 1 | 100 | 2008 | 10 | 5000 | | 2 | 100 | 2009 | 12 | 5000 | | 7 | 200 | 2011 | 15 | 9000 | +---------+------------+------+----------+-------+ Product table: +------------+--------------+ | product_id | product_name | +------------+--------------+ | 100 | Nokia | | 200 | Apple | | 300 | Samsung | +------------+--------------+ Output: +--------------+-------+-------+ | product_name | year | price | +--------------+-------+-------+ | Nokia | 2008 | 5000 | | Nokia | 2009 | 5000 | | Apple | 2011 | 9000 | +--------------+-------+-------+ Explanation: From sale_id = 1, we can conclude that Nokia was sold for 5000 in the year 2008. From sale_id = 2, we can conclude that Nokia was sold for 5000 in the year 2009. From sale_id = 7, we can conclude that Apple was sold for 9000 in the year 2011."
    },
    {
      "number": 1070,
      "title": "Product Sales Analysis III",
      "titleSlug": "product-sales-analysis-iii",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Sales +-------------+-------+ | Column Name | Type | +-------------+-------+ | sale_id | int | | product_id | int | | year | int | | quantity | int | | price | int | +-------------+-------+ (sale_id, year) is the primary key (combination of columns with unique values) of this table. product_id is a foreign key (reference column) to Product table. Each row of this table shows a sale on the product product_id in a certain year. Note that the price is per unit. Table: Product +--------------+---------+ | Column Name | Type | +--------------+---------+ | product_id | int | | product_name | varchar | +--------------+---------+ product_id is the primary key (column with unique values) of this table. Each row of this table indicates the product name of each product. Write a solution to select the product id, year, quantity, and price for the first year of every product sold. If any product is bought multiple times in its first year, return all sales separately. Return the resulting table in any order. The result format is in the following example. &nbsp; Example 1: Input: Sales table: +---------+------------+------+----------+-------+ | sale_id | product_id | year | quantity | price | +---------+------------+------+----------+-------+ | 1 | 100 | 2008 | 10 | 5000 | | 2 | 100 | 2009 | 12 | 5000 | | 7 | 200 | 2011 | 15 | 9000 | +---------+------------+------+----------+-------+ Product table: +------------+--------------+ | product_id | product_name | +------------+--------------+ | 100 | Nokia | | 200 | Apple | | 300 | Samsung | +------------+--------------+ Output: +------------+------------+----------+-------+ | product_id | first_year | quantity | price | +------------+------------+----------+-------+ | 100 | 2008 | 10 | 5000 | | 200 | 2011 | 15 | 9000 | +------------+------------+----------+-------+"
    },
    {
      "number": 1071,
      "title": "Greatest Common Divisor of Strings",
      "titleSlug": "greatest-common-divisor-of-strings",
      "difficulty": "Easy",
      "tags": [
        "Math",
        "String"
      ],
      "description": "For two strings s and t, we say &quot;t divides s&quot; if and only if s = t + t + t + ... + t + t (i.e., t is concatenated with itself one or more times). Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2. &nbsp; Example 1: Input: str1 = &quot;ABCABC&quot;, str2 = &quot;ABC&quot; Output: &quot;ABC&quot; Example 2: Input: str1 = &quot;ABABAB&quot;, str2 = &quot;ABAB&quot; Output: &quot;AB&quot; Example 3: Input: str1 = &quot;LEET&quot;, str2 = &quot;CODE&quot; Output: &quot;&quot; &nbsp; Constraints: 1 &lt;= str1.length, str2.length &lt;= 1000 str1 and str2 consist of English uppercase letters."
    },
    {
      "number": 1072,
      "title": "Flip Columns For Maximum Number of Equal Rows",
      "titleSlug": "flip-columns-for-maximum-number-of-equal-rows",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Matrix"
      ],
      "description": "You are given an m x n binary matrix matrix. You can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from 0 to 1 or vice versa). Return the maximum number of rows that have all values equal after some number of flips. &nbsp; Example 1: Input: matrix = [[0,1],[1,1]] Output: 1 Explanation: After flipping no values, 1 row has all values equal. Example 2: Input: matrix = [[0,1],[1,0]] Output: 2 Explanation: After flipping values in the first column, both rows have equal values. Example 3: Input: matrix = [[0,0,0],[0,0,1],[1,1,0]] Output: 2 Explanation: After flipping values in the first two columns, the last two rows have equal values. &nbsp; Constraints: m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 300 matrix[i][j] is either&nbsp;0 or 1."
    },
    {
      "number": 1073,
      "title": "Adding Two Negabinary Numbers",
      "titleSlug": "adding-two-negabinary-numbers",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math"
      ],
      "description": "Given two numbers arr1 and arr2 in base -2, return the result of adding them together. Each number is given in array format:&nbsp; as an array of 0s and 1s, from most significant bit to least significant bit.&nbsp; For example, arr = [1,1,0,1] represents the number (-2)^3&nbsp;+ (-2)^2 + (-2)^0 = -3.&nbsp; A number arr in array, format is also guaranteed to have no leading zeros: either&nbsp;arr == [0] or arr[0] == 1. Return the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros. &nbsp; Example 1: Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1] Output: [1,0,0,0,0] Explanation: arr1 represents 11, arr2 represents 5, the output represents 16. Example 2: Input: arr1 = [0], arr2 = [0] Output: [0] Example 3: Input: arr1 = [0], arr2 = [1] Output: [1] &nbsp; Constraints: 1 &lt;= arr1.length,&nbsp;arr2.length &lt;= 1000 arr1[i]&nbsp;and arr2[i] are&nbsp;0 or 1 arr1 and arr2 have no leading zeros"
    },
    {
      "number": 1074,
      "title": "Number of Submatrices That Sum to Target",
      "titleSlug": "number-of-submatrices-that-sum-to-target",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Matrix",
        "Prefix Sum"
      ],
      "description": "Given a matrix&nbsp;and a target, return the number of non-empty submatrices that sum to target. A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 &lt;= x &lt;= x2 and y1 &lt;= y &lt;= y2. Two submatrices (x1, y1, x2, y2) and (x1&#39;, y1&#39;, x2&#39;, y2&#39;) are different if they have some coordinate&nbsp;that is different: for example, if x1 != x1&#39;. &nbsp; Example 1: Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0 Output: 4 Explanation: The four 1x1 submatrices that only contain 0. Example 2: Input: matrix = [[1,-1],[-1,1]], target = 0 Output: 5 Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix. Example 3: Input: matrix = [[904]], target = 0 Output: 0 &nbsp; Constraints: 1 &lt;= matrix.length &lt;= 100 1 &lt;= matrix[0].length &lt;= 100 -1000 &lt;= matrix[i][j] &lt;= 1000 -10^8 &lt;= target &lt;= 10^8"
    },
    {
      "number": 1075,
      "title": "Project Employees I",
      "titleSlug": "project-employees-i",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Project +-------------+---------+ | Column Name | Type | +-------------+---------+ | project_id | int | | employee_id | int | +-------------+---------+ (project_id, employee_id) is the primary key of this table. employee_id is a foreign key to Employee table. Each row of this table indicates that the employee with employee_id is working on the project with project_id. &nbsp; Table: Employee +------------------+---------+ | Column Name | Type | +------------------+---------+ | employee_id | int | | name | varchar | | experience_years | int | +------------------+---------+ employee_id is the primary key of this table. It&#39;s guaranteed that experience_years is not NULL. Each row of this table contains information about one employee. &nbsp; Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits. Return the result table in any order. The query result format is in the following example. &nbsp; Example 1: Input: Project table: +-------------+-------------+ | project_id | employee_id | +-------------+-------------+ | 1 | 1 | | 1 | 2 | | 1 | 3 | | 2 | 1 | | 2 | 4 | +-------------+-------------+ Employee table: +-------------+--------+------------------+ | employee_id | name | experience_years | +-------------+--------+------------------+ | 1 | Khaled | 3 | | 2 | Ali | 2 | | 3 | John | 1 | | 4 | Doe | 2 | +-------------+--------+------------------+ Output: +-------------+---------------+ | project_id | average_years | +-------------+---------------+ | 1 | 2.00 | | 2 | 2.50 | +-------------+---------------+ Explanation: The average experience years for the first project is (3 + 2 + 1) / 3 = 2.00 and for the second project is (3 + 2) / 2 = 2.50"
    },
    {
      "number": 1078,
      "title": "Occurrences After Bigram",
      "titleSlug": "occurrences-after-bigram",
      "difficulty": "Easy",
      "tags": [
        "String"
      ],
      "description": "Given two strings first and second, consider occurrences in some text of the form &quot;first second third&quot;, where second comes immediately after first, and third comes immediately after second. Return an array of all the words third for each occurrence of &quot;first second third&quot;. &nbsp; Example 1: Input: text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\" Output: [\"girl\",\"student\"] Example 2: Input: text = \"we will we will rock you\", first = \"we\", second = \"will\" Output: [\"we\",\"rock\"] &nbsp; Constraints: 1 &lt;= text.length &lt;= 1000 text consists of lowercase English letters and spaces. All the words in text are separated by a single space. 1 &lt;= first.length, second.length &lt;= 10 first and second consist of lowercase English letters. text will not have any leading or trailing spaces."
    },
    {
      "number": 1079,
      "title": "Letter Tile Possibilities",
      "titleSlug": "letter-tile-possibilities",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Backtracking",
        "Counting"
      ],
      "description": "You have n&nbsp;&nbsp;tiles, where each tile has one letter tiles[i] printed on it. Return the number of possible non-empty sequences of letters you can make using the letters printed on those tiles. &nbsp; Example 1: Input: tiles = &quot;AAB&quot; Output: 8 Explanation: The possible sequences are &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;. Example 2: Input: tiles = &quot;AAABBC&quot; Output: 188 Example 3: Input: tiles = &quot;V&quot; Output: 1 &nbsp; Constraints: 1 &lt;= tiles.length &lt;= 7 tiles consists of uppercase English letters."
    },
    {
      "number": 1080,
      "title": "Insufficient Nodes in Root to Leaf Paths",
      "titleSlug": "insufficient-nodes-in-root-to-leaf-paths",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree and an integer limit, delete all insufficient nodes in the tree simultaneously, and return the root of the resulting binary tree. A node is insufficient if every root to leaf path intersecting this node has a sum strictly less than limit. A leaf is a node with no children. &nbsp; Example 1: Input: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1 Output: [1,2,3,4,null,null,7,8,9,null,14] Example 2: Input: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22 Output: [5,4,8,11,null,17,4,7,null,null,null,5] Example 3: Input: root = [1,2,-3,-5,null,4,null], limit = -1 Output: [1,null,-3,4] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 5000]. -105 &lt;= Node.val &lt;= 105 -109 &lt;= limit &lt;= 109"
    },
    {
      "number": 1081,
      "title": "Smallest Subsequence of Distinct Characters",
      "titleSlug": "smallest-subsequence-of-distinct-characters",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Stack",
        "Greedy",
        "Monotonic Stack"
      ],
      "description": "Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once. &nbsp; Example 1: Input: s = &quot;bcabc&quot; Output: &quot;abc&quot; Example 2: Input: s = &quot;cbacdcbc&quot; Output: &quot;acdb&quot; &nbsp; Constraints: 1 &lt;= s.length &lt;= 1000 s consists of lowercase English letters. &nbsp; Note: This question is the same as 316: https://leetcode.com/problems/remove-duplicate-letters/"
    },
    {
      "number": 1084,
      "title": "Sales Analysis III",
      "titleSlug": "sales-analysis-iii",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Product +--------------+---------+ | Column Name | Type | +--------------+---------+ | product_id | int | | product_name | varchar | | unit_price | int | +--------------+---------+ product_id is the primary key (column with unique values) of this table. Each row of this table indicates the name and the price of each product. Table: Sales +-------------+---------+ | Column Name | Type | +-------------+---------+ | seller_id | int | | product_id | int | | buyer_id | int | | sale_date | date | | quantity | int | | price | int | +-------------+---------+ This table can have duplicate rows. product_id is a foreign key (reference column) to the Product table. Each row of this table contains some information about one sale. &nbsp; Write a solution to&nbsp;report&nbsp;the products that were only sold in the first quarter of 2019. That is, between 2019-01-01 and 2019-03-31 inclusive. Return the result table in any order. The result format is in the following example. &nbsp; Example 1: Input: Product table: +------------+--------------+------------+ | product_id | product_name | unit_price | +------------+--------------+------------+ | 1 | S8 | 1000 | | 2 | G4 | 800 | | 3 | iPhone | 1400 | +------------+--------------+------------+ Sales table: +-----------+------------+----------+------------+----------+-------+ | seller_id | product_id | buyer_id | sale_date | quantity | price | +-----------+------------+----------+------------+----------+-------+ | 1 | 1 | 1 | 2019-01-21 | 2 | 2000 | | 1 | 2 | 2 | 2019-02-17 | 1 | 800 | | 2 | 2 | 3 | 2019-06-02 | 1 | 800 | | 3 | 3 | 4 | 2019-05-13 | 2 | 2800 | +-----------+------------+----------+------------+----------+-------+ Output: +-------------+--------------+ | product_id | product_name | +-------------+--------------+ | 1 | S8 | +-------------+--------------+ Explanation: The product with id 1 was only sold in the spring of 2019. The product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019. The product with id 3 was sold after spring 2019. We return only product 1 as it is the product that was only sold in the spring of 2019."
    },
    {
      "number": 1089,
      "title": "Duplicate Zeros",
      "titleSlug": "duplicate-zeros",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Two Pointers"
      ],
      "description": "Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything. &nbsp; Example 1: Input: arr = [1,0,2,3,0,4,5,0] Output: [1,0,0,2,3,0,0,4] Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] Example 2: Input: arr = [1,2,3] Output: [1,2,3] Explanation: After calling your function, the input array is modified to: [1,2,3] &nbsp; Constraints: 1 &lt;= arr.length &lt;= 104 0 &lt;= arr[i] &lt;= 9"
    },
    {
      "number": 1090,
      "title": "Largest Values From Labels",
      "titleSlug": "largest-values-from-labels",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Greedy",
        "Sorting",
        "Counting"
      ],
      "description": "You are given n item&#39;s value and label as two integer arrays values and labels. You are also given two integers numWanted and useLimit. Your task is to find a subset of items with the maximum sum of their values such that: The number of items is at most numWanted. The number of items with the same label is at most useLimit. Return the maximum sum. &nbsp; Example 1: Input: values = [5,4,3,2,1], labels = [1,1,2,2,3], numWanted = 3, useLimit = 1 Output: 9 Explanation: The subset chosen is the first, third, and fifth items with the sum of values 5 + 3 + 1. Example 2: Input: values = [5,4,3,2,1], labels = [1,3,3,3,2], numWanted = 3, useLimit = 2 Output: 12 Explanation: The subset chosen is the first, second, and third items with the sum of values 5 + 4 + 3. Example 3: Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], numWanted = 3, useLimit = 1 Output: 16 Explanation: The subset chosen is the first and fourth items with the sum of values 9 + 7. &nbsp; Constraints: n == values.length == labels.length 1 &lt;= n &lt;= 2 * 104 0 &lt;= values[i], labels[i] &lt;= 2 * 104 1 &lt;= numWanted, useLimit &lt;= n"
    },
    {
      "number": 1091,
      "title": "Shortest Path in Binary Matrix",
      "titleSlug": "shortest-path-in-binary-matrix",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that: All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner). The length of a clear path is the number of visited cells of this path. &nbsp; Example 1: Input: grid = [[0,1],[1,0]] Output: 2 Example 2: Input: grid = [[0,0,0],[1,1,0],[1,1,0]] Output: 4 Example 3: Input: grid = [[1,0,0],[1,1,0],[1,1,0]] Output: -1 &nbsp; Constraints: n == grid.length n == grid[i].length 1 &lt;= n &lt;= 100 grid[i][j] is 0 or 1"
    },
    {
      "number": 1092,
      "title": "Shortest Common Supersequence ",
      "titleSlug": "shortest-common-supersequence",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences. If there are multiple valid strings, return any of them. A string s is a subsequence of string t if deleting some number of characters from t (possibly 0) results in the string s. &nbsp; Example 1: Input: str1 = &quot;abac&quot;, str2 = &quot;cab&quot; Output: &quot;cabac&quot; Explanation: str1 = &quot;abac&quot; is a subsequence of &quot;cabac&quot; because we can delete the first &quot;c&quot;. str2 = &quot;cab&quot; is a subsequence of &quot;cabac&quot; because we can delete the last &quot;ac&quot;. The answer provided is the shortest such string that satisfies these properties. Example 2: Input: str1 = &quot;aaaaaaaa&quot;, str2 = &quot;aaaaaaaa&quot; Output: &quot;aaaaaaaa&quot; &nbsp; Constraints: 1 &lt;= str1.length, str2.length &lt;= 1000 str1 and str2 consist of lowercase English letters."
    },
    {
      "number": 1093,
      "title": "Statistics from a Large Sample",
      "titleSlug": "statistics-from-a-large-sample",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math",
        "Probability and Statistics"
      ],
      "description": "You are given a large sample of integers in the range [0, 255]. Since the sample is so large, it is represented by an array count&nbsp;where count[k] is the number of times that k appears in the sample. Calculate the following statistics: minimum: The minimum element in the sample. maximum: The maximum element in the sample. mean: The average of the sample, calculated as the total sum of all elements divided by the total number of elements. median: If the sample has an odd number of elements, then the median is the middle element once the sample is sorted. If the sample has an even number of elements, then the median is the average of the two middle elements once the sample is sorted. mode: The number that appears the most in the sample. It is guaranteed to be unique. Return the statistics of the sample as an array of floating-point numbers [minimum, maximum, mean, median, mode]. Answers within 10-5 of the actual answer will be accepted. &nbsp; Example 1: Input: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: [1.00000,3.00000,2.37500,2.50000,3.00000] Explanation: The sample represented by count is [1,2,2,2,3,3,3,3]. The minimum and maximum are 1 and 3 respectively. The mean is (1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375. Since the size of the sample is even, the median is the average of the two middle elements 2 and 3, which is 2.5. The mode is 3 as it appears the most in the sample. Example 2: Input: count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: [1.00000,4.00000,2.18182,2.00000,1.00000] Explanation: The sample represented by count is [1,1,1,1,2,2,2,3,3,4,4]. The minimum and maximum are 1 and 4 respectively. The mean is (1+1+1+1+2+2+2+3+3+4+4) / 11 = 24 / 11 = 2.18181818... (for display purposes, the output shows the rounded number 2.18182). Since the size of the sample is odd, the median is the middle element 2. The mode is 1 as it appears the most in the sample. &nbsp; Constraints: count.length == 256 0 &lt;= count[i] &lt;= 109 1 &lt;= sum(count) &lt;= 109 The mode of the sample that count represents is unique."
    },
    {
      "number": 1094,
      "title": "Car Pooling",
      "titleSlug": "car-pooling",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Sorting",
        "Heap (Priority Queue)",
        "Simulation",
        "Prefix Sum"
      ],
      "description": "There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west). You are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car&#39;s initial location. Return true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise. &nbsp; Example 1: Input: trips = [[2,1,5],[3,3,7]], capacity = 4 Output: false Example 2: Input: trips = [[2,1,5],[3,3,7]], capacity = 5 Output: true &nbsp; Constraints: 1 &lt;= trips.length &lt;= 1000 trips[i].length == 3 1 &lt;= numPassengersi &lt;= 100 0 &lt;= fromi &lt; toi &lt;= 1000 1 &lt;= capacity &lt;= 105"
    },
    {
      "number": 1095,
      "title": "Find in Mountain Array",
      "titleSlug": "find-in-mountain-array",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Binary Search",
        "Interactive"
      ],
      "description": "(This problem is an interactive problem.) You may recall that an array arr is a mountain array if and only if: arr.length &gt;= 3 There exists some i with 0 &lt; i &lt; arr.length - 1 such that: arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i] arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target. If such an index does not exist, return -1. You cannot access the mountain array directly. You may only access the array using a MountainArray interface: MountainArray.get(k) returns the element of the array at index k (0-indexed). MountainArray.length() returns the length of the array. Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification. &nbsp; Example 1: Input: mountainArr = [1,2,3,4,5,3,1], target = 3 Output: 2 Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2. Example 2: Input: mountainArr = [0,1,2,4,2,1], target = 3 Output: -1 Explanation: 3 does not exist in the array, so we return -1. &nbsp; Constraints: 3 &lt;= mountainArr.length() &lt;= 104 0 &lt;= target &lt;= 109 0 &lt;= mountainArr.get(index) &lt;= 109"
    },
    {
      "number": 1096,
      "title": "Brace Expansion II",
      "titleSlug": "brace-expansion-ii",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Backtracking",
        "Stack",
        "Breadth-First Search"
      ],
      "description": "Under the grammar given below, strings can represent a set of lowercase words. Let&nbsp;R(expr)&nbsp;denote the set of words the expression represents. The grammar can best be understood through simple examples: Single letters represent a singleton set containing that word. R(&quot;a&quot;) = {&quot;a&quot;} R(&quot;w&quot;) = {&quot;w&quot;} When we take a comma-delimited list of two or more expressions, we take the union of possibilities. R(&quot;{a,b,c}&quot;) = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;} R(&quot;{{a,b},{b,c}}&quot;) = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;} (notice the final set only contains each word at most once) When we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression. R(&quot;{a,b}{c,d}&quot;) = {&quot;ac&quot;,&quot;ad&quot;,&quot;bc&quot;,&quot;bd&quot;} R(&quot;a{b,c}{d,e}f{g,h}&quot;) = {&quot;abdfg&quot;, &quot;abdfh&quot;, &quot;abefg&quot;, &quot;abefh&quot;, &quot;acdfg&quot;, &quot;acdfh&quot;, &quot;acefg&quot;, &quot;acefh&quot;} Formally, the three rules for our grammar: For every lowercase letter x, we have R(x) = {x}. For expressions e1, e2, ... , ek with k &gt;= 2, we have R({e1, e2, ...}) = R(e1) &cup; R(e2) &cup; ... For expressions e1 and e2, we have R(e1 + e2) = {a + b for (a, b) in R(e1) &times; R(e2)}, where + denotes concatenation, and &times; denotes the cartesian product. Given an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents. &nbsp; Example 1: Input: expression = &quot;{a,b}{c,{d,e}}&quot; Output: [&quot;ac&quot;,&quot;ad&quot;,&quot;ae&quot;,&quot;bc&quot;,&quot;bd&quot;,&quot;be&quot;] Example 2: Input: expression = &quot;{{a,z},a{b,c},{ab,z}}&quot; Output: [&quot;a&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;z&quot;] Explanation: Each distinct word is written only once in the final answer. &nbsp; Constraints: 1 &lt;= expression.length &lt;= 60 expression[i] consists of &#39;{&#39;, &#39;}&#39;, &#39;,&#39;or lowercase English letters. The given&nbsp;expression&nbsp;represents a set of words based on the grammar given in the description."
    },
    {
      "number": 1103,
      "title": "Distribute Candies to People",
      "titleSlug": "distribute-candies-to-people",
      "difficulty": "Easy",
      "tags": [
        "Math",
        "Simulation"
      ],
      "description": "We distribute some&nbsp;number of candies, to a row of n =&nbsp;num_people&nbsp;people in the following way: We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n&nbsp;candies to the last person. Then, we go back to the start of the row, giving n&nbsp;+ 1 candies to the first person, n&nbsp;+ 2 candies to the second person, and so on until we give 2 * n&nbsp;candies to the last person. This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.&nbsp; The last person will receive all of our remaining candies (not necessarily one more than the previous gift). Return an array (of length num_people&nbsp;and sum candies) that represents the final distribution of candies. &nbsp; Example 1: Input: candies = 7, num_people = 4 Output: [1,2,3,1] Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0,0]. On the third turn, ans[2] += 3, and the array is [1,2,3,0]. On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1]. Example 2: Input: candies = 10, num_people = 3 Output: [5,2,3] Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0]. On the third turn, ans[2] += 3, and the array is [1,2,3]. On the fourth turn, ans[0] += 4, and the final array is [5,2,3]. &nbsp; Constraints: 1 &lt;= candies &lt;= 10^9 1 &lt;= num_people &lt;= 1000"
    },
    {
      "number": 1104,
      "title": "Path In Zigzag Labelled Binary Tree",
      "titleSlug": "path-in-zigzag-labelled-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Tree",
        "Binary Tree"
      ],
      "description": "In an infinite binary tree where every node has two children, the nodes are labelled in row order. In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left. Given the label of a node in this tree, return the labels in the path from the root of the tree to the&nbsp;node with that label. &nbsp; Example 1: Input: label = 14 Output: [1,3,4,14] Example 2: Input: label = 26 Output: [1,2,6,10,26] &nbsp; Constraints: 1 &lt;= label &lt;= 10^6"
    },
    {
      "number": 1105,
      "title": "Filling Bookcase Shelves",
      "titleSlug": "filling-bookcase-shelves",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "You are given an array books where books[i] = [thicknessi, heighti] indicates the thickness and height of the ith book. You are also given an integer shelfWidth. We want to place these books in order onto bookcase shelves that have a total width shelfWidth. We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to shelfWidth, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place. Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books. For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf. Return the minimum possible height that the total bookshelf can be after placing shelves in this manner. &nbsp; Example 1: Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4 Output: 6 Explanation: The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6. Notice that book number 2 does not have to be on the first shelf. Example 2: Input: books = [[1,3],[2,4],[3,2]], shelfWidth = 6 Output: 4 &nbsp; Constraints: 1 &lt;= books.length &lt;= 1000 1 &lt;= thicknessi &lt;= shelfWidth &lt;= 1000 1 &lt;= heighti &lt;= 1000"
    },
    {
      "number": 1106,
      "title": "Parsing A Boolean Expression",
      "titleSlug": "parsing-a-boolean-expression",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Stack",
        "Recursion"
      ],
      "description": "A boolean expression is an expression that evaluates to either true or false. It can be in one of the following shapes: &#39;t&#39; that evaluates to true. &#39;f&#39; that evaluates to false. &#39;!(subExpr)&#39; that evaluates to the logical NOT of the inner expression subExpr. &#39;&amp;(subExpr1, subExpr2, ..., subExprn)&#39; that evaluates to the logical AND of the inner expressions subExpr1, subExpr2, ..., subExprn where n &gt;= 1. &#39;|(subExpr1, subExpr2, ..., subExprn)&#39; that evaluates to the logical OR of the inner expressions subExpr1, subExpr2, ..., subExprn where n &gt;= 1. Given a string expression that represents a boolean expression, return the evaluation of that expression. It is guaranteed that the given expression is valid and follows the given rules. &nbsp; Example 1: Input: expression = &quot;&amp;(|(f))&quot; Output: false Explanation: First, evaluate |(f) --&gt; f. The expression is now &quot;&amp;(f)&quot;. Then, evaluate &amp;(f) --&gt; f. The expression is now &quot;f&quot;. Finally, return false. Example 2: Input: expression = &quot;|(f,f,f,t)&quot; Output: true Explanation: The evaluation of (false OR false OR false OR true) is true. Example 3: Input: expression = &quot;!(&amp;(f,t))&quot; Output: true Explanation: First, evaluate &amp;(f,t) --&gt; (false AND true) --&gt; false --&gt; f. The expression is now &quot;!(f)&quot;. Then, evaluate !(f) --&gt; NOT false --&gt; true. We return true. &nbsp; Constraints: 1 &lt;= expression.length &lt;= 2 * 104 expression[i] is one following characters: &#39;(&#39;, &#39;)&#39;, &#39;&amp;&#39;, &#39;|&#39;, &#39;!&#39;, &#39;t&#39;, &#39;f&#39;, and &#39;,&#39;."
    },
    {
      "number": 1108,
      "title": "Defanging an IP Address",
      "titleSlug": "defanging-an-ip-address",
      "difficulty": "Easy",
      "tags": [
        "String"
      ],
      "description": "Given a valid (IPv4) IP address, return a defanged version of that IP address. A defanged&nbsp;IP address&nbsp;replaces every period &quot;.&quot; with &quot;[.]&quot;. &nbsp; Example 1: Input: address = \"1.1.1.1\" Output: \"1[.]1[.]1[.]1\" Example 2: Input: address = \"255.100.50.0\" Output: \"255[.]100[.]50[.]0\" &nbsp; Constraints: The given address is a valid IPv4 address."
    },
    {
      "number": 1109,
      "title": "Corporate Flight Bookings",
      "titleSlug": "corporate-flight-bookings",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Prefix Sum"
      ],
      "description": "There are n flights that are labeled from 1 to n. You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range. Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i. &nbsp; Example 1: Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 Output: [10,55,45,25,25] Explanation: Flight labels: 1 2 3 4 5 Booking 1 reserved: 10 10 Booking 2 reserved: 20 20 Booking 3 reserved: 25 25 25 25 Total seats: 10 55 45 25 25 Hence, answer = [10,55,45,25,25] Example 2: Input: bookings = [[1,2,10],[2,2,15]], n = 2 Output: [10,25] Explanation: Flight labels: 1 2 Booking 1 reserved: 10 10 Booking 2 reserved: 15 Total seats: 10 25 Hence, answer = [10,25] &nbsp; Constraints: 1 &lt;= n &lt;= 2 * 104 1 &lt;= bookings.length &lt;= 2 * 104 bookings[i].length == 3 1 &lt;= firsti &lt;= lasti &lt;= n 1 &lt;= seatsi &lt;= 104"
    },
    {
      "number": 1110,
      "title": "Delete Nodes And Return Forest",
      "titleSlug": "delete-nodes-and-return-forest",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, each node in the tree has a distinct value. After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees). Return the roots of the trees in the remaining forest. You may return the result in any order. &nbsp; Example 1: Input: root = [1,2,3,4,5,6,7], to_delete = [3,5] Output: [[1,2,null,4],[6],[7]] Example 2: Input: root = [1,2,4,null,3], to_delete = [3] Output: [[1,2,4]] &nbsp; Constraints: The number of nodes in the given tree is at most 1000. Each node has a distinct value between 1 and 1000. to_delete.length &lt;= 1000 to_delete contains distinct values between 1 and 1000."
    },
    {
      "number": 1111,
      "title": "Maximum Nesting Depth of Two Valid Parentheses Strings",
      "titleSlug": "maximum-nesting-depth-of-two-valid-parentheses-strings",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Stack"
      ],
      "description": "A string is a valid parentheses string&nbsp;(denoted VPS) if and only if it consists of &quot;(&quot; and &quot;)&quot; characters only, and: It is the empty string, or It can be written as&nbsp;AB&nbsp;(A&nbsp;concatenated with&nbsp;B), where&nbsp;A&nbsp;and&nbsp;B&nbsp;are VPS&#39;s, or It can be written as&nbsp;(A), where&nbsp;A&nbsp;is a VPS. We can&nbsp;similarly define the nesting depth depth(S) of any VPS S as follows: depth(&quot;&quot;) = 0 depth(A + B) = max(depth(A), depth(B)), where A and B are VPS&#39;s depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A), where A is a VPS. For example,&nbsp; &quot;&quot;,&nbsp;&quot;()()&quot;, and&nbsp;&quot;()(()())&quot;&nbsp;are VPS&#39;s (with nesting depths 0, 1, and 2), and &quot;)(&quot; and &quot;(()&quot; are not VPS&#39;s. &nbsp; Given a VPS seq, split it into two disjoint subsequences A and B, such that&nbsp;A and B are VPS&#39;s (and&nbsp;A.length + B.length = seq.length). Now choose any such A and B such that&nbsp;max(depth(A), depth(B)) is the minimum possible value. Return an answer array (of length seq.length) that encodes such a&nbsp;choice of A and B:&nbsp; answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.&nbsp; Note that even though multiple answers may exist, you may return any of them. &nbsp; Example 1: Input: seq = &quot;(()())&quot; Output: [0,1,1,1,1,0] Example 2: Input: seq = &quot;()(())()&quot; Output: [0,0,0,1,1,0,1,1] &nbsp; Constraints: 1 &lt;= seq.size &lt;= 10000"
    },
    {
      "number": 1114,
      "title": "Print in Order",
      "titleSlug": "print-in-order",
      "difficulty": "Easy",
      "tags": [
        "Concurrency"
      ],
      "description": "Suppose we have a class: public class Foo { public void first() { print(&quot;first&quot;); } public void second() { print(&quot;second&quot;); } public void third() { print(&quot;third&quot;); } } The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second(). Note: We do not know how the threads will be scheduled in the operating system, even though the numbers in the input seem to imply the ordering. The input format you see is mainly to ensure our tests&#39; comprehensiveness. &nbsp; Example 1: Input: nums = [1,2,3] Output: &quot;firstsecondthird&quot; Explanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). &quot;firstsecondthird&quot; is the correct output. Example 2: Input: nums = [1,3,2] Output: &quot;firstsecondthird&quot; Explanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). &quot;firstsecondthird&quot; is the correct output. &nbsp; Constraints: nums is a permutation of [1, 2, 3]."
    },
    {
      "number": 1115,
      "title": "Print FooBar Alternately",
      "titleSlug": "print-foobar-alternately",
      "difficulty": "Medium",
      "tags": [
        "Concurrency"
      ],
      "description": "Suppose you are given the following code: class FooBar { public void foo() { for (int i = 0; i &lt; n; i++) { print(&quot;foo&quot;); } } public void bar() { for (int i = 0; i &lt; n; i++) { print(&quot;bar&quot;); } } } The same instance of FooBar will be passed to two different threads: thread A will call foo(), while thread B will call bar(). Modify the given program to output &quot;foobar&quot; n times. &nbsp; Example 1: Input: n = 1 Output: &quot;foobar&quot; Explanation: There are two threads being fired asynchronously. One of them calls foo(), while the other calls bar(). &quot;foobar&quot; is being output 1 time. Example 2: Input: n = 2 Output: &quot;foobarfoobar&quot; Explanation: &quot;foobar&quot; is being output 2 times. &nbsp; Constraints: 1 &lt;= n &lt;= 1000"
    },
    {
      "number": 1116,
      "title": "Print Zero Even Odd",
      "titleSlug": "print-zero-even-odd",
      "difficulty": "Medium",
      "tags": [
        "Concurrency"
      ],
      "description": "You have a function printNumber that can be called with an integer parameter and prints it to the console. For example, calling printNumber(7) prints 7 to the console. You are given an instance of the class ZeroEvenOdd that has three functions: zero, even, and odd. The same instance of ZeroEvenOdd will be passed to three different threads: Thread A: calls zero() that should only output 0&#39;s. Thread B: calls even() that should only output even numbers. Thread C: calls odd() that should only output odd numbers. Modify the given class to output the series &quot;010203040506...&quot; where the length of the series must be 2n. Implement the ZeroEvenOdd class: ZeroEvenOdd(int n) Initializes the object with the number n that represents the numbers that should be printed. void zero(printNumber) Calls printNumber to output one zero. void even(printNumber) Calls printNumber to output one even number. void odd(printNumber) Calls printNumber to output one odd number. &nbsp; Example 1: Input: n = 2 Output: &quot;0102&quot; Explanation: There are three threads being fired asynchronously. One of them calls zero(), the other calls even(), and the last one calls odd(). &quot;0102&quot; is the correct output. Example 2: Input: n = 5 Output: &quot;0102030405&quot; &nbsp; Constraints: 1 &lt;= n &lt;= 1000"
    },
    {
      "number": 1117,
      "title": "Building H2O",
      "titleSlug": "building-h2o",
      "difficulty": "Medium",
      "tags": [
        "Concurrency"
      ],
      "description": "There are two kinds of threads: oxygen and hydrogen. Your goal is to group these threads to form water molecules. There is a barrier where each thread has to wait until a complete molecule can be formed. Hydrogen and oxygen threads will be given releaseHydrogen and releaseOxygen methods respectively, which will allow them to pass the barrier. These threads should pass the barrier in groups of three, and they must immediately bond with each other to form a water molecule. You must guarantee that all the threads from one molecule bond before any other threads from the next molecule do. In other words: If an oxygen thread arrives at the barrier when no hydrogen threads are present, it must wait for two hydrogen threads. If a hydrogen thread arrives at the barrier when no other threads are present, it must wait for an oxygen thread and another hydrogen thread. We do not have to worry about matching the threads up explicitly; the threads do not necessarily know which other threads they are paired up with. The key is that threads pass the barriers in complete sets; thus, if we examine the sequence of threads that bind and divide them into groups of three, each group should contain one oxygen and two hydrogen threads. Write synchronization code for oxygen and hydrogen molecules that enforces these constraints. &nbsp; Example 1: Input: water = &quot;HOH&quot; Output: &quot;HHO&quot; Explanation: &quot;HOH&quot; and &quot;OHH&quot; are also valid answers. Example 2: Input: water = &quot;OOHHHH&quot; Output: &quot;HHOHHO&quot; Explanation: &quot;HOHHHO&quot;, &quot;OHHHHO&quot;, &quot;HHOHOH&quot;, &quot;HOHHOH&quot;, &quot;OHHHOH&quot;, &quot;HHOOHH&quot;, &quot;HOHOHH&quot; and &quot;OHHOHH&quot; are also valid answers. &nbsp; Constraints: 3 * n == water.length 1 &lt;= n &lt;= 20 water[i] is either &#39;H&#39; or &#39;O&#39;. There will be exactly 2 * n &#39;H&#39; in water. There will be exactly n &#39;O&#39; in water."
    },
    {
      "number": 1122,
      "title": "Relative Sort Array",
      "titleSlug": "relative-sort-array",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Sorting",
        "Counting Sort"
      ],
      "description": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1. Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order. &nbsp; Example 1: Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19] Example 2: Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6] Output: [22,28,8,6,17,44] &nbsp; Constraints: 1 &lt;= arr1.length, arr2.length &lt;= 1000 0 &lt;= arr1[i], arr2[i] &lt;= 1000 All the elements of arr2 are distinct. Each&nbsp;arr2[i] is in arr1."
    },
    {
      "number": 1123,
      "title": "Lowest Common Ancestor of Deepest Leaves",
      "titleSlug": "lowest-common-ancestor-of-deepest-leaves",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return the lowest common ancestor of its deepest leaves. Recall that: The node of a binary tree is a leaf if and only if it has no children The depth of the root of the tree is 0. if the depth of a node is d, the depth of each of its children is d + 1. The lowest common ancestor of a set S of nodes, is the node A with the largest depth such that every node in S is in the subtree with root A. &nbsp; Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4] Output: [2,7,4] Explanation: We return the node with value 2, colored in yellow in the diagram. The nodes coloured in blue are the deepest leaf-nodes of the tree. Note that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3. Example 2: Input: root = [1] Output: [1] Explanation: The root is the deepest node in the tree, and it&#39;s the lca of itself. Example 3: Input: root = [0,1,3,null,2] Output: [2] Explanation: The deepest leaf node in the tree is 2, the lca of one node is itself. &nbsp; Constraints: The number of nodes in the tree will be in the range [1, 1000]. 0 &lt;= Node.val &lt;= 1000 The values of the nodes in the tree are unique. &nbsp; Note: This question is the same as 865: https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/"
    },
    {
      "number": 1124,
      "title": "Longest Well-Performing Interval",
      "titleSlug": "longest-well-performing-interval",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Stack",
        "Monotonic Stack",
        "Prefix Sum"
      ],
      "description": "We are given hours, a list of the number of hours worked per day for a given employee. A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8. A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days. Return the length of the longest well-performing interval. &nbsp; Example 1: Input: hours = [9,9,6,0,6,6,9] Output: 3 Explanation: The longest well-performing interval is [9,9,6]. Example 2: Input: hours = [6,6,6] Output: 0 &nbsp; Constraints: 1 &lt;= hours.length &lt;= 104 0 &lt;= hours[i] &lt;= 16"
    },
    {
      "number": 1125,
      "title": "Smallest Sufficient Team",
      "titleSlug": "smallest-sufficient-team",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Bit Manipulation",
        "Bitmask"
      ],
      "description": "In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has. Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. We can represent these teams by the index of each person. For example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3]. Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order. It is guaranteed an answer exists. &nbsp; Example 1: Input: req_skills = [\"java\",\"nodejs\",\"reactjs\"], people = [[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]] Output: [0,2] Example 2: Input: req_skills = [\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"], people = [[\"algorithms\",\"math\",\"java\"],[\"algorithms\",\"math\",\"reactjs\"],[\"java\",\"csharp\",\"aws\"],[\"reactjs\",\"csharp\"],[\"csharp\",\"math\"],[\"aws\",\"java\"]] Output: [1,2] &nbsp; Constraints: 1 &lt;= req_skills.length &lt;= 16 1 &lt;= req_skills[i].length &lt;= 16 req_skills[i] consists of lowercase English letters. All the strings of req_skills are unique. 1 &lt;= people.length &lt;= 60 0 &lt;= people[i].length &lt;= 16 1 &lt;= people[i][j].length &lt;= 16 people[i][j] consists of lowercase English letters. All the strings of people[i] are unique. Every skill in people[i] is a skill in req_skills. It is guaranteed a sufficient team exists."
    },
    {
      "number": 1128,
      "title": "Number of Equivalent Domino Pairs",
      "titleSlug": "number-of-equivalent-domino-pairs",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Counting"
      ],
      "description": "Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino. Return the number of pairs (i, j) for which 0 &lt;= i &lt; j &lt; dominoes.length, and dominoes[i] is equivalent to dominoes[j]. &nbsp; Example 1: Input: dominoes = [[1,2],[2,1],[3,4],[5,6]] Output: 1 Example 2: Input: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]] Output: 3 &nbsp; Constraints: 1 &lt;= dominoes.length &lt;= 4 * 104 dominoes[i].length == 2 1 &lt;= dominoes[i][j] &lt;= 9"
    },
    {
      "number": 1129,
      "title": "Shortest Path with Alternating Colors",
      "titleSlug": "shortest-path-with-alternating-colors",
      "difficulty": "Medium",
      "tags": [
        "Breadth-First Search",
        "Graph"
      ],
      "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges. You are given two arrays redEdges and blueEdges where: redEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and blueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph. Return an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist. &nbsp; Example 1: Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = [] Output: [0,1,-1] Example 2: Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]] Output: [0,1,-1] &nbsp; Constraints: 1 &lt;= n &lt;= 100 0 &lt;= redEdges.length,&nbsp;blueEdges.length &lt;= 400 redEdges[i].length == blueEdges[j].length == 2 0 &lt;= ai, bi, uj, vj &lt; n"
    },
    {
      "number": 1130,
      "title": "Minimum Cost Tree From Leaf Values",
      "titleSlug": "minimum-cost-tree-from-leaf-values",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Stack",
        "Greedy",
        "Monotonic Stack"
      ],
      "description": "Given an array arr of positive integers, consider all binary trees such that: Each node has either 0 or 2 children; The values of arr correspond to the values of each leaf in an in-order traversal of the tree. The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively. Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer. A node is a leaf if and only if it has zero children. &nbsp; Example 1: Input: arr = [6,2,4] Output: 32 Explanation: There are two possible trees shown. The first has a non-leaf node sum 36, and the second has non-leaf node sum 32. Example 2: Input: arr = [4,11] Output: 44 &nbsp; Constraints: 2 &lt;= arr.length &lt;= 40 1 &lt;= arr[i] &lt;= 15 It is guaranteed that the answer fits into a 32-bit signed integer (i.e., it is less than 231)."
    },
    {
      "number": 1131,
      "title": "Maximum of Absolute Value Expression",
      "titleSlug": "maximum-of-absolute-value-expression",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math"
      ],
      "description": "Given two arrays of integers with equal lengths, return the maximum value of: |arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j| where the maximum is taken over all 0 &lt;= i, j &lt; arr1.length. &nbsp; Example 1: Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6] Output: 13 Example 2: Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4] Output: 20 &nbsp; Constraints: 2 &lt;= arr1.length == arr2.length &lt;= 40000 -10^6 &lt;= arr1[i], arr2[i] &lt;= 10^6"
    },
    {
      "number": 1137,
      "title": "N-th Tribonacci Number",
      "titleSlug": "n-th-tribonacci-number",
      "difficulty": "Easy",
      "tags": [
        "Math",
        "Dynamic Programming",
        "Memoization"
      ],
      "description": "The Tribonacci sequence Tn is defined as follows:&nbsp; T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &gt;= 0. Given n, return the value of Tn. &nbsp; Example 1: Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2: Input: n = 25 Output: 1389537 &nbsp; Constraints: 0 &lt;= n &lt;= 37 The answer is guaranteed to fit within a 32-bit integer, ie. answer &lt;= 2^31 - 1."
    },
    {
      "number": 1138,
      "title": "Alphabet Board Path",
      "titleSlug": "alphabet-board-path",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String"
      ],
      "description": "On an alphabet board, we start at position (0, 0), corresponding to character&nbsp;board[0][0]. Here, board = [&quot;abcde&quot;, &quot;fghij&quot;, &quot;klmno&quot;, &quot;pqrst&quot;, &quot;uvwxy&quot;, &quot;z&quot;], as shown in the diagram below. We may make the following moves: &#39;U&#39; moves our position up one row, if the position exists on the board; &#39;D&#39; moves our position down one row, if the position exists on the board; &#39;L&#39; moves our position left one column, if the position exists on the board; &#39;R&#39; moves our position right one column, if the position exists on the board; &#39;!&#39;&nbsp;adds the character board[r][c] at our current position (r, c)&nbsp;to the&nbsp;answer. (Here, the only positions that exist on the board are positions with letters on them.) Return a sequence of moves that makes our answer equal to target&nbsp;in the minimum number of moves.&nbsp; You may return any path that does so. &nbsp; Example 1: Input: target = \"leet\" Output: \"DDR!UURRR!!DDD!\" Example 2: Input: target = \"code\" Output: \"RR!DDRR!UUL!R!\" &nbsp; Constraints: 1 &lt;= target.length &lt;= 100 target consists only of English lowercase letters."
    },
    {
      "number": 1139,
      "title": "Largest 1-Bordered Square",
      "titleSlug": "largest-1-bordered-square",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Matrix"
      ],
      "description": "Given a 2D grid of 0s and 1s, return the number of elements in&nbsp;the largest square&nbsp;subgrid that has all 1s on its border, or 0 if such a subgrid&nbsp;doesn&#39;t exist in the grid. &nbsp; Example 1: Input: grid = [[1,1,1],[1,0,1],[1,1,1]] Output: 9 Example 2: Input: grid = [[1,1,0,0]] Output: 1 &nbsp; Constraints: 1 &lt;= grid.length &lt;= 100 1 &lt;= grid[0].length &lt;= 100 grid[i][j] is 0 or 1"
    },
    {
      "number": 1140,
      "title": "Stone Game II",
      "titleSlug": "stone-game-ii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math",
        "Dynamic Programming",
        "Prefix Sum",
        "Game Theory"
      ],
      "description": "Alice and Bob continue their games with piles of stones. There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. Alice and Bob take turns, with Alice starting first. On each player&#39;s turn, that player can take all the stones in the first X remaining piles, where 1 &lt;= X &lt;= 2M. Then, we set M = max(M, X). Initially, M = 1. The game continues until all the stones have been taken. Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get. &nbsp; Example 1: Input: piles = [2,7,9,4,4] Output: 10 Explanation: If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 stones in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 stones in total. So we return 10 since it&#39;s larger. Example 2: Input: piles = [1,2,3,4,5,100] Output: 104 &nbsp; Constraints: 1 &lt;= piles.length &lt;= 100 1 &lt;= piles[i]&nbsp;&lt;= 104"
    },
    {
      "number": 1141,
      "title": "User Activity for the Past 30 Days I",
      "titleSlug": "user-activity-for-the-past-30-days-i",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Activity +---------------+---------+ | Column Name | Type | +---------------+---------+ | user_id | int | | session_id | int | | activity_date | date | | activity_type | enum | +---------------+---------+ This table may have duplicate rows. The activity_type column is an ENUM (category) of type (&#39;open_session&#39;, &#39;end_session&#39;, &#39;scroll_down&#39;, &#39;send_message&#39;). The table shows the user activities for a social media website. Note that each session belongs to exactly one user. &nbsp; Write a solution to find the daily active user count for a period of 30 days ending 2019-07-27 inclusively. A user was active on someday if they made at least one activity on that day. Return the result table in any order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Activity table: +---------+------------+---------------+---------------+ | user_id | session_id | activity_date | activity_type | +---------+------------+---------------+---------------+ | 1 | 1 | 2019-07-20 | open_session | | 1 | 1 | 2019-07-20 | scroll_down | | 1 | 1 | 2019-07-20 | end_session | | 2 | 4 | 2019-07-20 | open_session | | 2 | 4 | 2019-07-21 | send_message | | 2 | 4 | 2019-07-21 | end_session | | 3 | 2 | 2019-07-21 | open_session | | 3 | 2 | 2019-07-21 | send_message | | 3 | 2 | 2019-07-21 | end_session | | 4 | 3 | 2019-06-25 | open_session | | 4 | 3 | 2019-06-25 | end_session | +---------+------------+---------------+---------------+ Output: +------------+--------------+ | day | active_users | +------------+--------------+ | 2019-07-20 | 2 | | 2019-07-21 | 2 | +------------+--------------+ Explanation: Note that we do not care about days with zero active users."
    },
    {
      "number": 1143,
      "title": "Longest Common Subsequence",
      "titleSlug": "longest-common-subsequence",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, &quot;ace&quot; is a subsequence of &quot;abcde&quot;. A common subsequence of two strings is a subsequence that is common to both strings. &nbsp; Example 1: Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; Output: 3 Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3. Example 2: Input: text1 = &quot;abc&quot;, text2 = &quot;abc&quot; Output: 3 Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3. Example 3: Input: text1 = &quot;abc&quot;, text2 = &quot;def&quot; Output: 0 Explanation: There is no such common subsequence, so the result is 0. &nbsp; Constraints: 1 &lt;= text1.length, text2.length &lt;= 1000 text1 and text2 consist of only lowercase English characters."
    },
    {
      "number": 1144,
      "title": "Decrease Elements To Make Array Zigzag",
      "titleSlug": "decrease-elements-to-make-array-zigzag",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Greedy"
      ],
      "description": "Given an array nums of integers, a move&nbsp;consists of choosing any element and decreasing it by 1. An array A is a&nbsp;zigzag array&nbsp;if either: Every even-indexed element is greater than adjacent elements, ie.&nbsp;A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ... OR, every odd-indexed element is greater than adjacent elements, ie.&nbsp;A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ... Return the minimum number of moves to transform the given array nums into a zigzag array. &nbsp; Example 1: Input: nums = [1,2,3] Output: 2 Explanation: We can decrease 2 to 0 or 3 to 1. Example 2: Input: nums = [9,6,1,6,2] Output: 4 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= 1000"
    },
    {
      "number": 1145,
      "title": "Binary Tree Coloring Game",
      "titleSlug": "binary-tree-coloring-game",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Two players play a turn based game on a binary tree. We are given the root of this binary tree, and the number of nodes n in the tree. n is odd, and each node has a distinct value from 1 to n. Initially, the first player names a value x with 1 &lt;= x &lt;= n, and the second player names a value y with 1 &lt;= y &lt;= n and y != x. The first player colors the node with value x red, and the second player colors the node with value y blue. Then, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.) If (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes. You are the second player. If it is possible to choose such a y to ensure you win the game, return true. If it is not possible, return false. &nbsp; Example 1: Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3 Output: true Explanation: The second player can choose the node with value 2. Example 2: Input: root = [1,2,3], n = 3, x = 1 Output: false &nbsp; Constraints: The number of nodes in the tree is n. 1 &lt;= x &lt;= n &lt;= 100 n is odd. 1 &lt;= Node.val &lt;= n All the values of the tree are unique."
    },
    {
      "number": 1146,
      "title": "Snapshot Array",
      "titleSlug": "snapshot-array",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Binary Search",
        "Design"
      ],
      "description": "Implement a SnapshotArray that supports the following interface: SnapshotArray(int length) initializes an array-like data structure with the given length. Initially, each element equals 0. void set(index, val) sets the element at the given index to be equal to val. int snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1. int get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id &nbsp; Example 1: Input: [&quot;SnapshotArray&quot;,&quot;set&quot;,&quot;snap&quot;,&quot;set&quot;,&quot;get&quot;] [[3],[0,5],[],[0,6],[0,0]] Output: [null,null,0,null,5] Explanation: SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3 snapshotArr.set(0,5); // Set array[0] = 5 snapshotArr.snap(); // Take a snapshot, return snap_id = 0 snapshotArr.set(0,6); snapshotArr.get(0,0); // Get the value of array[0] with snap_id = 0, return 5 &nbsp; Constraints: 1 &lt;= length &lt;= 5 * 104 0 &lt;= index &lt; length 0 &lt;= val &lt;= 109 0 &lt;= snap_id &lt; (the total number of times we call snap()) At most 5 * 104 calls will be made to set, snap, and get."
    },
    {
      "number": 1147,
      "title": "Longest Chunked Palindrome Decomposition",
      "titleSlug": "longest-chunked-palindrome-decomposition",
      "difficulty": "Hard",
      "tags": [
        "Two Pointers",
        "String",
        "Dynamic Programming",
        "Greedy",
        "Rolling Hash",
        "Hash Function"
      ],
      "description": "You are given a string text. You should split it to k substrings (subtext1, subtext2, ..., subtextk) such that: subtexti is a non-empty string. The concatenation of all the substrings is equal to text (i.e., subtext1 + subtext2 + ... + subtextk == text). subtexti == subtextk - i + 1 for all valid values of i (i.e., 1 &lt;= i &lt;= k). Return the largest possible value of k. &nbsp; Example 1: Input: text = &quot;ghiabcdefhelloadamhelloabcdefghi&quot; Output: 7 Explanation: We can split the string on &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;. Example 2: Input: text = &quot;merchant&quot; Output: 1 Explanation: We can split the string on &quot;(merchant)&quot;. Example 3: Input: text = &quot;antaprezatepzapreanta&quot; Output: 11 Explanation: We can split the string on &quot;(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)&quot;. &nbsp; Constraints: 1 &lt;= text.length &lt;= 1000 text consists only of lowercase English characters."
    },
    {
      "number": 1148,
      "title": "Article Views I",
      "titleSlug": "article-views-i",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Views +---------------+---------+ | Column Name | Type | +---------------+---------+ | article_id | int | | author_id | int | | viewer_id | int | | view_date | date | +---------------+---------+ There is no primary key (column with unique values) for this table, the table may have duplicate rows. Each row of this table indicates that some viewer viewed an article (written by some author) on some date. Note that equal author_id and viewer_id indicate the same person. &nbsp; Write a solution to find all the authors that viewed at least one of their own articles. Return the result table sorted by id in ascending order. The result format is in the following example. &nbsp; Example 1: Input: Views table: +------------+-----------+-----------+------------+ | article_id | author_id | viewer_id | view_date | +------------+-----------+-----------+------------+ | 1 | 3 | 5 | 2019-08-01 | | 1 | 3 | 6 | 2019-08-02 | | 2 | 7 | 7 | 2019-08-01 | | 2 | 7 | 6 | 2019-08-02 | | 4 | 7 | 1 | 2019-07-22 | | 3 | 4 | 4 | 2019-07-21 | | 3 | 4 | 4 | 2019-07-21 | +------------+-----------+-----------+------------+ Output: +------+ | id | +------+ | 4 | | 7 | +------+"
    },
    {
      "number": 1154,
      "title": "Day of the Year",
      "titleSlug": "day-of-the-year",
      "difficulty": "Easy",
      "tags": [
        "Math",
        "String"
      ],
      "description": "Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year. &nbsp; Example 1: Input: date = &quot;2019-01-09&quot; Output: 9 Explanation: Given date is the 9th day of the year in 2019. Example 2: Input: date = &quot;2019-02-10&quot; Output: 41 &nbsp; Constraints: date.length == 10 date[4] == date[7] == &#39;-&#39;, and all other date[i]&#39;s are digits date represents a calendar date between Jan 1st, 1900 and Dec 31st, 2019."
    },
    {
      "number": 1155,
      "title": "Number of Dice Rolls With Target Sum",
      "titleSlug": "number-of-dice-rolls-with-target-sum",
      "difficulty": "Medium",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "You have n dice, and each dice has k faces numbered from 1 to k. Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice, so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7. &nbsp; Example 1: Input: n = 1, k = 6, target = 3 Output: 1 Explanation: You throw one die with 6 faces. There is only one way to get a sum of 3. Example 2: Input: n = 2, k = 6, target = 7 Output: 6 Explanation: You throw two dice, each with 6 faces. There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1. Example 3: Input: n = 30, k = 30, target = 500 Output: 222616187 Explanation: The answer must be returned modulo 109 + 7. &nbsp; Constraints: 1 &lt;= n, k &lt;= 30 1 &lt;= target &lt;= 1000"
    },
    {
      "number": 1156,
      "title": "Swap For Longest Repeated Character Substring",
      "titleSlug": "swap-for-longest-repeated-character-substring",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Sliding Window"
      ],
      "description": "You are given a string text. You can swap two of the characters in the text. Return the length of the longest substring with repeated characters. &nbsp; Example 1: Input: text = &quot;ababa&quot; Output: 3 Explanation: We can swap the first &#39;b&#39; with the last &#39;a&#39;, or the last &#39;b&#39; with the first &#39;a&#39;. Then, the longest repeated character substring is &quot;aaa&quot; with length 3. Example 2: Input: text = &quot;aaabaaa&quot; Output: 6 Explanation: Swap &#39;b&#39; with the last &#39;a&#39; (or the first &#39;a&#39;), and we get longest repeated character substring &quot;aaaaaa&quot; with length 6. Example 3: Input: text = &quot;aaaaa&quot; Output: 5 Explanation: No need to swap, longest repeated character substring is &quot;aaaaa&quot; with length is 5. &nbsp; Constraints: 1 &lt;= text.length &lt;= 2 * 104 text consist of lowercase English characters only."
    },
    {
      "number": 1157,
      "title": "Online Majority Element In Subarray",
      "titleSlug": "online-majority-element-in-subarray",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Binary Search",
        "Design",
        "Binary Indexed Tree",
        "Segment Tree"
      ],
      "description": "Design a data structure that efficiently finds the majority element of a given subarray. The majority element of a subarray is an element that occurs threshold times or more in the subarray. Implementing the MajorityChecker class: MajorityChecker(int[] arr) Initializes the instance of the class with the given array arr. int query(int left, int right, int threshold) returns the element in the subarray arr[left...right] that occurs at least threshold times, or -1 if no such element exists. &nbsp; Example 1: Input [&quot;MajorityChecker&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;] [[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]] Output [null, 1, -1, 2] Explanation MajorityChecker majorityChecker = new MajorityChecker([1, 1, 2, 2, 1, 1]); majorityChecker.query(0, 5, 4); // return 1 majorityChecker.query(0, 3, 3); // return -1 majorityChecker.query(2, 3, 2); // return 2 &nbsp; Constraints: 1 &lt;= arr.length &lt;= 2 * 104 1 &lt;= arr[i] &lt;= 2 * 104 0 &lt;= left &lt;= right &lt; arr.length threshold &lt;= right - left + 1 2 * threshold &gt; right - left + 1 At most 104 calls will be made to query."
    },
    {
      "number": 1158,
      "title": "Market Analysis I",
      "titleSlug": "market-analysis-i",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Users +----------------+---------+ | Column Name | Type | +----------------+---------+ | user_id | int | | join_date | date | | favorite_brand | varchar | +----------------+---------+ user_id is the primary key (column with unique values) of this table. This table has the info of the users of an online shopping website where users can sell and buy items. &nbsp; Table: Orders +---------------+---------+ | Column Name | Type | +---------------+---------+ | order_id | int | | order_date | date | | item_id | int | | buyer_id | int | | seller_id | int | +---------------+---------+ order_id is the primary key (column with unique values) of this table. item_id is a foreign key (reference column) to the Items table. buyer_id and seller_id are foreign keys to the Users table. &nbsp; Table: Items +---------------+---------+ | Column Name | Type | +---------------+---------+ | item_id | int | | item_brand | varchar | +---------------+---------+ item_id is the primary key (column with unique values) of this table. &nbsp; Write a solution&nbsp;to find for each user, the join date and the number of orders they made as a buyer in 2019. Return the result table in any order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Users table: +---------+------------+----------------+ | user_id | join_date | favorite_brand | +---------+------------+----------------+ | 1 | 2018-01-01 | Lenovo | | 2 | 2018-02-09 | Samsung | | 3 | 2018-01-19 | LG | | 4 | 2018-05-21 | HP | +---------+------------+----------------+ Orders table: +----------+------------+---------+----------+-----------+ | order_id | order_date | item_id | buyer_id | seller_id | +----------+------------+---------+----------+-----------+ | 1 | 2019-08-01 | 4 | 1 | 2 | | 2 | 2018-08-02 | 2 | 1 | 3 | | 3 | 2019-08-03 | 3 | 2 | 3 | | 4 | 2018-08-04 | 1 | 4 | 2 | | 5 | 2018-08-04 | 1 | 3 | 4 | | 6 | 2019-08-05 | 2 | 2 | 4 | +----------+------------+---------+----------+-----------+ Items table: +---------+------------+ | item_id | item_brand | +---------+------------+ | 1 | Samsung | | 2 | Lenovo | | 3 | LG | | 4 | HP | +---------+------------+ Output: +-----------+------------+----------------+ | buyer_id | join_date | orders_in_2019 | +-----------+------------+----------------+ | 1 | 2018-01-01 | 1 | | 2 | 2018-02-09 | 2 | | 3 | 2018-01-19 | 0 | | 4 | 2018-05-21 | 0 | +-----------+------------+----------------+"
    },
    {
      "number": 1160,
      "title": "Find Words That Can Be Formed by Characters",
      "titleSlug": "find-words-that-can-be-formed-by-characters",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Counting"
      ],
      "description": "You are given an array of strings words and a string chars. A string is good if it can be formed by characters from chars (each character can only be used once for each word in words). Return the sum of lengths of all good strings in words. &nbsp; Example 1: Input: words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot; Output: 6 Explanation: The strings that can be formed are &quot;cat&quot; and &quot;hat&quot; so the answer is 3 + 3 = 6. Example 2: Input: words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot; Output: 10 Explanation: The strings that can be formed are &quot;hello&quot; and &quot;world&quot; so the answer is 5 + 5 = 10. &nbsp; Constraints: 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length, chars.length &lt;= 100 words[i] and chars consist of lowercase English letters."
    },
    {
      "number": 1161,
      "title": "Maximum Level Sum of a Binary Tree",
      "titleSlug": "maximum-level-sum-of-a-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on. Return the smallest level x such that the sum of all the values of nodes at level x is maximal. &nbsp; Example 1: Input: root = [1,7,0,7,-8,null,null] Output: 2 Explanation: Level 1 sum = 1. Level 2 sum = 7 + 0 = 7. Level 3 sum = 7 + -8 = -1. So we return the level with the maximum sum which is level 2. Example 2: Input: root = [989,null,10250,98693,-89388,null,null,null,-32127] Output: 2 &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. -105 &lt;= Node.val &lt;= 105"
    },
    {
      "number": 1162,
      "title": "As Far from Land as Possible",
      "titleSlug": "as-far-from-land-as-possible",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "Given an n x n grid&nbsp;containing only values 0 and 1, where&nbsp;0 represents water&nbsp;and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance.&nbsp;If no land or water exists in the grid, return -1. The distance used in this problem is the Manhattan distance:&nbsp;the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|. &nbsp; Example 1: Input: grid = [[1,0,1],[0,0,0],[1,0,1]] Output: 2 Explanation: The cell (1, 1) is as far as possible from all the land with distance 2. Example 2: Input: grid = [[1,0,0],[0,0,0],[0,0,0]] Output: 4 Explanation: The cell (2, 2) is as far as possible from all the land with distance 4. &nbsp; Constraints: n == grid.length n == grid[i].length 1 &lt;= n&nbsp;&lt;= 100 grid[i][j]&nbsp;is 0 or 1"
    },
    {
      "number": 1163,
      "title": "Last Substring in Lexicographical Order",
      "titleSlug": "last-substring-in-lexicographical-order",
      "difficulty": "Hard",
      "tags": [
        "Two Pointers",
        "String"
      ],
      "description": "Given a string s, return the last substring of s in lexicographical order. &nbsp; Example 1: Input: s = &quot;abab&quot; Output: &quot;bab&quot; Explanation: The substrings are [&quot;a&quot;, &quot;ab&quot;, &quot;aba&quot;, &quot;abab&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bab&quot;]. The lexicographically maximum substring is &quot;bab&quot;. Example 2: Input: s = &quot;leetcode&quot; Output: &quot;tcode&quot; &nbsp; Constraints: 1 &lt;= s.length &lt;= 4 * 105 s contains only lowercase English letters."
    },
    {
      "number": 1164,
      "title": "Product Price at a Given Date",
      "titleSlug": "product-price-at-a-given-date",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Products +---------------+---------+ | Column Name | Type | +---------------+---------+ | product_id | int | | new_price | int | | change_date | date | +---------------+---------+ (product_id, change_date) is the primary key (combination of columns with unique values) of this table. Each row of this table indicates that the price of some product was changed to a new price at some date. &nbsp; Write a solution to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10. Return the result table in any order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Products table: +------------+-----------+-------------+ | product_id | new_price | change_date | +------------+-----------+-------------+ | 1 | 20 | 2019-08-14 | | 2 | 50 | 2019-08-14 | | 1 | 30 | 2019-08-15 | | 1 | 35 | 2019-08-16 | | 2 | 65 | 2019-08-17 | | 3 | 20 | 2019-08-18 | +------------+-----------+-------------+ Output: +------------+-------+ | product_id | price | +------------+-------+ | 2 | 50 | | 1 | 35 | | 3 | 10 | +------------+-------+"
    },
    {
      "number": 1169,
      "title": "Invalid Transactions",
      "titleSlug": "invalid-transactions",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Sorting"
      ],
      "description": "A transaction is possibly invalid if: the amount exceeds $1000, or; if it occurs within (and including) 60 minutes of another transaction with the same name in a different city. You are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction. Return a list of transactions that are possibly invalid. You may return the answer in any order. &nbsp; Example 1: Input: transactions = [&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;] Output: [&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;] Explanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too. Example 2: Input: transactions = [&quot;alice,20,800,mtv&quot;,&quot;alice,50,1200,mtv&quot;] Output: [&quot;alice,50,1200,mtv&quot;] Example 3: Input: transactions = [&quot;alice,20,800,mtv&quot;,&quot;bob,50,1200,mtv&quot;] Output: [&quot;bob,50,1200,mtv&quot;] &nbsp; Constraints: transactions.length &lt;= 1000 Each transactions[i] takes the form &quot;{name},{time},{amount},{city}&quot; Each {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10. Each {time} consist of digits, and represent an integer between 0 and 1000. Each {amount} consist of digits, and represent an integer between 0 and 2000."
    },
    {
      "number": 1170,
      "title": "Compare Strings by Frequency of the Smallest Character",
      "titleSlug": "compare-strings-by-frequency-of-the-smallest-character",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Binary Search",
        "Sorting"
      ],
      "description": "Let the function f(s) be the frequency of the lexicographically smallest character in a non-empty string s. For example, if s = &quot;dcce&quot; then f(s) = 2 because the lexicographically smallest character is &#39;c&#39;, which has a frequency of 2. You are given an array of strings words and another array of query strings queries. For each query queries[i], count the number of words in words such that f(queries[i]) &lt; f(W) for each W in words. Return an integer array answer, where each answer[i] is the answer to the ith query. &nbsp; Example 1: Input: queries = [&quot;cbd&quot;], words = [&quot;zaaaz&quot;] Output: [1] Explanation: On the first query we have f(&quot;cbd&quot;) = 1, f(&quot;zaaaz&quot;) = 3 so f(&quot;cbd&quot;) &lt; f(&quot;zaaaz&quot;). Example 2: Input: queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;] Output: [1,2] Explanation: On the first query only f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;). On the second query both f(&quot;aaa&quot;) and f(&quot;aaaa&quot;) are both &gt; f(&quot;cc&quot;). &nbsp; Constraints: 1 &lt;= queries.length &lt;= 2000 1 &lt;= words.length &lt;= 2000 1 &lt;= queries[i].length, words[i].length &lt;= 10 queries[i][j], words[i][j] consist of lowercase English letters."
    },
    {
      "number": 1171,
      "title": "Remove Zero Sum Consecutive Nodes from Linked List",
      "titleSlug": "remove-zero-sum-consecutive-nodes-from-linked-list",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Linked List"
      ],
      "description": "Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences. After doing so, return the head of the final linked list.&nbsp; You may return any such answer. &nbsp; (Note that in the examples below, all sequences are serializations of ListNode objects.) Example 1: Input: head = [1,2,-3,3,1] Output: [3,1] Note: The answer [1,2,1] would also be accepted. Example 2: Input: head = [1,2,3,-3,4] Output: [1,2,4] Example 3: Input: head = [1,2,3,-3,-2] Output: [1] &nbsp; Constraints: The given linked list will contain between 1 and 1000 nodes. Each node in the linked list has -1000 &lt;= node.val &lt;= 1000."
    },
    {
      "number": 1172,
      "title": "Dinner Plate Stacks",
      "titleSlug": "dinner-plate-stacks",
      "difficulty": "Hard",
      "tags": [
        "Hash Table",
        "Stack",
        "Design",
        "Heap (Priority Queue)"
      ],
      "description": "You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity. Implement the DinnerPlates class: DinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks capacity. void push(int val) Pushes the given integer val into the leftmost stack with a size less than capacity. int pop() Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all the stacks are empty. int popAtStack(int index) Returns the value at the top of the stack with the given index index and removes it from that stack or returns -1 if the stack with that given index is empty. &nbsp; Example 1: Input [&quot;DinnerPlates&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;popAtStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;popAtStack&quot;, &quot;popAtStack&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;] [[2], [1], [2], [3], [4], [5], [0], [20], [21], [0], [2], [], [], [], [], []] Output [null, null, null, null, null, null, 2, null, null, 20, 21, 5, 4, 3, 1, -1] Explanation: DinnerPlates D = DinnerPlates(2); // Initialize with capacity = 2 D.push(1); D.push(2); D.push(3); D.push(4); D.push(5); // The stacks are now: 2 4 1 3 5    D.popAtStack(0); // Returns 2. The stacks are now: 4 1 3 5    D.push(20); // The stacks are now: 20 4 1 3 5    D.push(21); // The stacks are now: 20 4 21 1 3 5    D.popAtStack(0); // Returns 20. The stacks are now: 4 21 1 3 5    D.popAtStack(2); // Returns 21. The stacks are now: 4 1 3 5    D.pop() // Returns 5. The stacks are now: 4 1 3   D.pop() // Returns 4. The stacks are now: 1 3   D.pop() // Returns 3. The stacks are now: 1  D.pop() // Returns 1. There are no stacks. D.pop() // Returns -1. There are still no stacks. &nbsp; Constraints: 1 &lt;= capacity &lt;= 2 * 104 1 &lt;= val &lt;= 2 * 104 0 &lt;= index &lt;= 105 At most 2 * 105 calls will be made to push, pop, and popAtStack."
    },
    {
      "number": 1174,
      "title": "Immediate Food Delivery II",
      "titleSlug": "immediate-food-delivery-ii",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Delivery +-----------------------------+---------+ | Column Name | Type | +-----------------------------+---------+ | delivery_id | int | | customer_id | int | | order_date | date | | customer_pref_delivery_date | date | +-----------------------------+---------+ delivery_id is the column of unique values of this table. The table holds information about food delivery to customers that make orders at some date and specify a preferred delivery date (on the same order date or after it). &nbsp; If the customer&#39;s preferred delivery date is the same as the order date, then the order is called immediate; otherwise, it is called scheduled. The first order of a customer is the order with the earliest order date that the customer made. It is guaranteed that a customer has precisely one first order. Write a solution to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Delivery table: +-------------+-------------+------------+-----------------------------+ | delivery_id | customer_id | order_date | customer_pref_delivery_date | +-------------+-------------+------------+-----------------------------+ | 1 | 1 | 2019-08-01 | 2019-08-02 | | 2 | 2 | 2019-08-02 | 2019-08-02 | | 3 | 1 | 2019-08-11 | 2019-08-12 | | 4 | 3 | 2019-08-24 | 2019-08-24 | | 5 | 3 | 2019-08-21 | 2019-08-22 | | 6 | 2 | 2019-08-11 | 2019-08-13 | | 7 | 4 | 2019-08-09 | 2019-08-09 | +-------------+-------------+------------+-----------------------------+ Output: +----------------------+ | immediate_percentage | +----------------------+ | 50.00 | +----------------------+ Explanation: The customer id 1 has a first order with delivery id 1 and it is scheduled. The customer id 2 has a first order with delivery id 2 and it is immediate. The customer id 3 has a first order with delivery id 5 and it is scheduled. The customer id 4 has a first order with delivery id 7 and it is immediate. Hence, half the customers have immediate first orders."
    },
    {
      "number": 1175,
      "title": "Prime Arrangements",
      "titleSlug": "prime-arrangements",
      "difficulty": "Easy",
      "tags": [
        "Math"
      ],
      "description": "Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.) (Recall that an integer&nbsp;is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers&nbsp;both smaller than it.) Since the answer may be large, return the answer modulo 10^9 + 7. &nbsp; Example 1: Input: n = 5 Output: 12 Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1. Example 2: Input: n = 100 Output: 682289015 &nbsp; Constraints: 1 &lt;= n &lt;= 100"
    },
    {
      "number": 1177,
      "title": "Can Make Palindrome from Substring",
      "titleSlug": "can-make-palindrome-from-substring",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Bit Manipulation",
        "Prefix Sum"
      ],
      "description": "You are given a string s and array queries where queries[i] = [lefti, righti, ki]. We may rearrange the substring s[lefti...righti] for each query and then choose up to ki of them to replace with any lowercase English letter. If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false. Return a boolean array answer where answer[i] is the result of the ith query queries[i]. Note that each letter is counted individually for replacement, so if, for example s[lefti...righti] = &quot;aaa&quot;, and ki = 2, we can only replace two of the letters. Also, note that no query modifies the initial string s. &nbsp; Example : Input: s = &quot;abcda&quot;, queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]] Output: [true,false,false,true,true] Explanation: queries[0]: substring = &quot;d&quot;, is palidrome. queries[1]: substring = &quot;bc&quot;, is not palidrome. queries[2]: substring = &quot;abcd&quot;, is not palidrome after replacing only 1 character. queries[3]: substring = &quot;abcd&quot;, could be changed to &quot;abba&quot; which is palidrome. Also this can be changed to &quot;baab&quot; first rearrange it &quot;bacd&quot; then replace &quot;cd&quot; with &quot;ab&quot;. queries[4]: substring = &quot;abcda&quot;, could be changed to &quot;abcba&quot; which is palidrome. Example 2: Input: s = &quot;lyb&quot;, queries = [[0,1,0],[2,2,1]] Output: [false,true] &nbsp; Constraints: 1 &lt;= s.length, queries.length &lt;= 105 0 &lt;= lefti &lt;= righti &lt; s.length 0 &lt;= ki &lt;= s.length s consists of lowercase English letters."
    },
    {
      "number": 1178,
      "title": "Number of Valid Words for Each Puzzle",
      "titleSlug": "number-of-valid-words-for-each-puzzle",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Bit Manipulation",
        "Trie"
      ],
      "description": "With respect to a given puzzle string, a word is valid if both the following conditions are satisfied: word contains the first letter of puzzle. For each letter in word, that letter is in puzzle. For example, if the puzzle is &quot;abcdefg&quot;, then valid words are &quot;faced&quot;, &quot;cabbage&quot;, and &quot;baggage&quot;, while invalid words are &quot;beefed&quot; (does not include &#39;a&#39;) and &quot;based&quot; (includes &#39;s&#39; which is not in the puzzle). Return an array answer, where answer[i] is the number of words in the given word list words that is valid with respect to the puzzle puzzles[i]. &nbsp; Example 1: Input: words = [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], puzzles = [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;] Output: [1,1,3,2,4,0] Explanation: 1 valid word for &quot;aboveyz&quot; : &quot;aaaa&quot; 1 valid word for &quot;abrodyz&quot; : &quot;aaaa&quot; 3 valid words for &quot;abslute&quot; : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot; 2 valid words for &quot;absoryz&quot; : &quot;aaaa&quot;, &quot;asas&quot; 4 valid words for &quot;actresz&quot; : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot; There are no valid words for &quot;gaswxyz&quot; cause none of the words in the list contains letter &#39;g&#39;. Example 2: Input: words = [&quot;apple&quot;,&quot;pleas&quot;,&quot;please&quot;], puzzles = [&quot;aelwxyz&quot;,&quot;aelpxyz&quot;,&quot;aelpsxy&quot;,&quot;saelpxy&quot;,&quot;xaelpsy&quot;] Output: [0,1,3,2,0] &nbsp; Constraints: 1 &lt;= words.length &lt;= 105 4 &lt;= words[i].length &lt;= 50 1 &lt;= puzzles.length &lt;= 104 puzzles[i].length == 7 words[i] and puzzles[i] consist of lowercase English letters. Each puzzles[i] does not contain repeated characters."
    },
    {
      "number": 1179,
      "title": "Reformat Department Table",
      "titleSlug": "reformat-department-table",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Department +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | revenue | int | | month | varchar | +-------------+---------+ In SQL,(id, month) is the primary key of this table. The table has information about the revenue of each department per month. The month has values in [&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;]. &nbsp; Reformat the table such that there is a department id column and a revenue column for each month. Return the result table in any order. The result format is in the following example. &nbsp; Example 1: Input: Department table: +------+---------+-------+ | id | revenue | month | +------+---------+-------+ | 1 | 8000 | Jan | | 2 | 9000 | Jan | | 3 | 10000 | Feb | | 1 | 7000 | Feb | | 1 | 6000 | Mar | +------+---------+-------+ Output: +------+-------------+-------------+-------------+-----+-------------+ | id | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue | +------+-------------+-------------+-------------+-----+-------------+ | 1 | 8000 | 7000 | 6000 | ... | null | | 2 | 9000 | null | null | ... | null | | 3 | null | 10000 | null | ... | null | +------+-------------+-------------+-------------+-----+-------------+ Explanation: The revenue from Apr to Dec is null. Note that the result table has 13 columns (1 for the department id + 12 for the months)."
    },
    {
      "number": 1184,
      "title": "Distance Between Bus Stops",
      "titleSlug": "distance-between-bus-stops",
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "description": "A bus&nbsp;has n stops numbered from 0 to n - 1 that form&nbsp;a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number&nbsp;i and (i + 1) % n. The bus goes along both directions&nbsp;i.e. clockwise and counterclockwise. Return the shortest distance between the given&nbsp;start&nbsp;and destination&nbsp;stops. &nbsp; Example 1: Input: distance = [1,2,3,4], start = 0, destination = 1 Output: 1 Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1. &nbsp; Example 2: Input: distance = [1,2,3,4], start = 0, destination = 2 Output: 3 Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3. &nbsp; Example 3: Input: distance = [1,2,3,4], start = 0, destination = 3 Output: 4 Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4. &nbsp; Constraints: 1 &lt;= n&nbsp;&lt;= 10^4 distance.length == n 0 &lt;= start, destination &lt; n 0 &lt;= distance[i] &lt;= 10^4"
    },
    {
      "number": 1185,
      "title": "Day of the Week",
      "titleSlug": "day-of-the-week",
      "difficulty": "Easy",
      "tags": [
        "Math"
      ],
      "description": "Given a date, return the corresponding day of the week for that date. The input is given as three integers representing the day, month and year respectively. Return the answer as one of the following values&nbsp;{&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;}. &nbsp; Example 1: Input: day = 31, month = 8, year = 2019 Output: &quot;Saturday&quot; Example 2: Input: day = 18, month = 7, year = 1999 Output: &quot;Sunday&quot; Example 3: Input: day = 15, month = 8, year = 1993 Output: &quot;Sunday&quot; &nbsp; Constraints: The given dates are valid dates between the years 1971 and 2100."
    },
    {
      "number": 1186,
      "title": "Maximum Subarray Sum with One Deletion",
      "titleSlug": "maximum-subarray-sum-with-one-deletion",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "Given an array of integers, return the maximum sum for a non-empty&nbsp;subarray (contiguous elements) with at most one element deletion.&nbsp;In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the&nbsp;sum of the remaining elements is maximum possible. Note that the subarray needs to be non-empty after deleting one element. &nbsp; Example 1: Input: arr = [1,-2,0,3] Output: 4 Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value. Example 2: Input: arr = [1,-2,-2,3] Output: 3 Explanation: We just choose [3] and it&#39;s the maximum sum. Example 3: Input: arr = [-1,-1,-1,-1] Output: -1 Explanation:&nbsp;The final subarray needs to be non-empty. You can&#39;t choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 105 -104 &lt;= arr[i] &lt;= 104"
    },
    {
      "number": 1187,
      "title": "Make Array Strictly Increasing",
      "titleSlug": "make-array-strictly-increasing",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Binary Search",
        "Dynamic Programming",
        "Sorting"
      ],
      "description": "Given two integer arrays&nbsp;arr1 and arr2, return the minimum number of operations (possibly zero) needed&nbsp;to make arr1 strictly increasing. In one operation, you can choose two indices&nbsp;0 &lt;=&nbsp;i &lt; arr1.length&nbsp;and&nbsp;0 &lt;= j &lt; arr2.length&nbsp;and do the assignment&nbsp;arr1[i] = arr2[j]. If there is no way to make&nbsp;arr1&nbsp;strictly increasing,&nbsp;return&nbsp;-1. &nbsp; Example 1: Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4] Output: 1 Explanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7]. Example 2: Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1] Output: 2 Explanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7]. Example 3: Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3] Output: -1 Explanation: You can&#39;t make arr1 strictly increasing. &nbsp; Constraints: 1 &lt;= arr1.length, arr2.length &lt;= 2000 0 &lt;= arr1[i], arr2[i] &lt;= 10^9 &nbsp;"
    },
    {
      "number": 1189,
      "title": "Maximum Number of Balloons",
      "titleSlug": "maximum-number-of-balloons",
      "difficulty": "Easy",
      "tags": [
        "Hash Table",
        "String",
        "Counting"
      ],
      "description": "Given a string text, you want to use the characters of text to form as many instances of the word &quot;balloon&quot; as possible. You can use each character in text at most once. Return the maximum number of instances that can be formed. &nbsp; Example 1: Input: text = &quot;nlaebolko&quot; Output: 1 Example 2: Input: text = &quot;loonbalxballpoon&quot; Output: 2 Example 3: Input: text = &quot;leetcode&quot; Output: 0 &nbsp; Constraints: 1 &lt;= text.length &lt;= 104 text consists of lower case English letters only. &nbsp; Note: This question is the same as 2287: Rearrange Characters to Make Target String."
    },
    {
      "number": 1190,
      "title": "Reverse Substrings Between Each Pair of Parentheses",
      "titleSlug": "reverse-substrings-between-each-pair-of-parentheses",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Stack"
      ],
      "description": "You are given a string s that consists of lower case English letters and brackets. Reverse the strings in each pair of matching parentheses, starting from the innermost one. Your result should not contain any brackets. &nbsp; Example 1: Input: s = &quot;(abcd)&quot; Output: &quot;dcba&quot; Example 2: Input: s = &quot;(u(love)i)&quot; Output: &quot;iloveu&quot; Explanation: The substring &quot;love&quot; is reversed first, then the whole string is reversed. Example 3: Input: s = &quot;(ed(et(oc))el)&quot; Output: &quot;leetcode&quot; Explanation: First, we reverse the substring &quot;oc&quot;, then &quot;etco&quot;, and finally, the whole string. &nbsp; Constraints: 1 &lt;= s.length &lt;= 2000 s only contains lower case English characters and parentheses. It is guaranteed that all parentheses are balanced."
    },
    {
      "number": 1191,
      "title": "K-Concatenation Maximum Sum",
      "titleSlug": "k-concatenation-maximum-sum",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "Given an integer array arr and an integer k, modify the array by repeating it k times. For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2]. Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0. As the answer can be very large, return the answer modulo 109 + 7. &nbsp; Example 1: Input: arr = [1,2], k = 3 Output: 9 Example 2: Input: arr = [1,-2,1], k = 5 Output: 2 Example 3: Input: arr = [-1,-2], k = 7 Output: 0 &nbsp; Constraints: 1 &lt;= arr.length &lt;= 105 1 &lt;= k &lt;= 105 -104 &lt;= arr[i] &lt;= 104"
    },
    {
      "number": 1192,
      "title": "Critical Connections in a Network",
      "titleSlug": "critical-connections-in-a-network",
      "difficulty": "Hard",
      "tags": [
        "Depth-First Search",
        "Graph",
        "Biconnected Component"
      ],
      "description": "There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network. A critical connection is a connection that, if removed, will make some servers unable to reach some other server. Return all critical connections in the network in any order. &nbsp; Example 1: Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]] Output: [[1,3]] Explanation: [[3,1]] is also accepted. Example 2: Input: n = 2, connections = [[0,1]] Output: [[0,1]] &nbsp; Constraints: 2 &lt;= n &lt;= 105 n - 1 &lt;= connections.length &lt;= 105 0 &lt;= ai, bi &lt;= n - 1 ai != bi There are no repeated connections."
    },
    {
      "number": 1193,
      "title": "Monthly Transactions I",
      "titleSlug": "monthly-transactions-i",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Transactions +---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | country | varchar | | state | enum | | amount | int | | trans_date | date | +---------------+---------+ id is the primary key of this table. The table has information about incoming transactions. The state column is an enum of type [&quot;approved&quot;, &quot;declined&quot;]. &nbsp; Write an SQL query to find for each month and country, the number of transactions and their total amount, the number of approved transactions and their total amount. Return the result table in any order. The query result format is in the following example. &nbsp; Example 1: Input: Transactions table: +------+---------+----------+--------+------------+ | id | country | state | amount | trans_date | +------+---------+----------+--------+------------+ | 121 | US | approved | 1000 | 2018-12-18 | | 122 | US | declined | 2000 | 2018-12-19 | | 123 | US | approved | 2000 | 2019-01-01 | | 124 | DE | approved | 2000 | 2019-01-07 | +------+---------+----------+--------+------------+ Output: +----------+---------+-------------+----------------+--------------------+-----------------------+ | month | country | trans_count | approved_count | trans_total_amount | approved_total_amount | +----------+---------+-------------+----------------+--------------------+-----------------------+ | 2018-12 | US | 2 | 1 | 3000 | 1000 | | 2019-01 | US | 1 | 1 | 2000 | 2000 | | 2019-01 | DE | 1 | 1 | 2000 | 2000 | +----------+---------+-------------+----------------+--------------------+-----------------------+"
    },
    {
      "number": 1195,
      "title": "Fizz Buzz Multithreaded",
      "titleSlug": "fizz-buzz-multithreaded",
      "difficulty": "Medium",
      "tags": [
        "Concurrency"
      ],
      "description": "You have the four functions: printFizz that prints the word &quot;fizz&quot; to the console, printBuzz that prints the word &quot;buzz&quot; to the console, printFizzBuzz that prints the word &quot;fizzbuzz&quot; to the console, and printNumber that prints a given integer to the console. You are given an instance of the class FizzBuzz that has four functions: fizz, buzz, fizzbuzz and number. The same instance of FizzBuzz will be passed to four different threads: Thread A: calls fizz() that should output the word &quot;fizz&quot;. Thread B: calls buzz() that should output the word &quot;buzz&quot;. Thread C: calls fizzbuzz() that should output the word &quot;fizzbuzz&quot;. Thread D: calls number() that should only output the integers. Modify the given class to output the series [1, 2, &quot;fizz&quot;, 4, &quot;buzz&quot;, ...] where the ith token (1-indexed) of the series is: &quot;fizzbuzz&quot; if i is divisible by 3 and 5, &quot;fizz&quot; if i is divisible by 3 and not 5, &quot;buzz&quot; if i is divisible by 5 and not 3, or i if i is not divisible by 3 or 5. Implement the FizzBuzz class: FizzBuzz(int n) Initializes the object with the number n that represents the length of the sequence that should be printed. void fizz(printFizz) Calls printFizz to output &quot;fizz&quot;. void buzz(printBuzz) Calls printBuzz to output &quot;buzz&quot;. void fizzbuzz(printFizzBuzz) Calls printFizzBuzz to output &quot;fizzbuzz&quot;. void number(printNumber) Calls printnumber to output the numbers. &nbsp; Example 1: Input: n = 15 Output: [1,2,\"fizz\",4,\"buzz\",\"fizz\",7,8,\"fizz\",\"buzz\",11,\"fizz\",13,14,\"fizzbuzz\"] Example 2: Input: n = 5 Output: [1,2,\"fizz\",4,\"buzz\"] &nbsp; Constraints: 1 &lt;= n &lt;= 50"
    },
    {
      "number": 1200,
      "title": "Minimum Absolute Difference",
      "titleSlug": "minimum-absolute-difference",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Sorting"
      ],
      "description": "Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows a, b are from arr a &lt; b b - a equals to the minimum absolute difference of any two elements in arr &nbsp; Example 1: Input: arr = [4,2,1,3] Output: [[1,2],[2,3],[3,4]] Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order. Example 2: Input: arr = [1,3,6,10,15] Output: [[1,3]] Example 3: Input: arr = [3,8,-10,23,19,-4,-14,27] Output: [[-14,-10],[19,23],[23,27]] &nbsp; Constraints: 2 &lt;= arr.length &lt;= 105 -106 &lt;= arr[i] &lt;= 106"
    },
    {
      "number": 1201,
      "title": "Ugly Number III",
      "titleSlug": "ugly-number-iii",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Binary Search",
        "Combinatorics",
        "Number Theory"
      ],
      "description": "An ugly number is a positive integer that is divisible by a, b, or c. Given four integers n, a, b, and c, return the nth ugly number. &nbsp; Example 1: Input: n = 3, a = 2, b = 3, c = 5 Output: 4 Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4. Example 2: Input: n = 4, a = 2, b = 3, c = 4 Output: 6 Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6. Example 3: Input: n = 5, a = 2, b = 11, c = 13 Output: 10 Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10. &nbsp; Constraints: 1 &lt;= n, a, b, c &lt;= 109 1 &lt;= a * b * c &lt;= 1018 It is guaranteed that the result will be in range [1, 2 * 109]."
    },
    {
      "number": 1202,
      "title": "Smallest String With Swaps",
      "titleSlug": "smallest-string-with-swaps",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Sorting"
      ],
      "description": "You are given a string s, and an array of pairs of indices in the string&nbsp;pairs&nbsp;where&nbsp;pairs[i] =&nbsp;[a, b]&nbsp;indicates 2 indices(0-indexed) of the string. You can&nbsp;swap the characters at any pair of indices in the given&nbsp;pairs&nbsp;any number of times. Return the&nbsp;lexicographically smallest string that s&nbsp;can be changed to after using the swaps. &nbsp; Example 1: Input: s = &quot;dcab&quot;, pairs = [[0,3],[1,2]] Output: &quot;bacd&quot; Explaination: Swap s[0] and s[3], s = &quot;bcad&quot; Swap s[1] and s[2], s = &quot;bacd&quot; Example 2: Input: s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]] Output: &quot;abcd&quot; Explaination: Swap s[0] and s[3], s = &quot;bcad&quot; Swap s[0] and s[2], s = &quot;acbd&quot; Swap s[1] and s[2], s = &quot;abcd&quot; Example 3: Input: s = &quot;cba&quot;, pairs = [[0,1],[1,2]] Output: &quot;abc&quot; Explaination: Swap s[0] and s[1], s = &quot;bca&quot; Swap s[1] and s[2], s = &quot;bac&quot; Swap s[0] and s[1], s = &quot;abc&quot; &nbsp; Constraints: 1 &lt;= s.length &lt;= 10^5 0 &lt;= pairs.length &lt;= 10^5 0 &lt;= pairs[i][0], pairs[i][1] &lt;&nbsp;s.length s&nbsp;only contains lower case English letters."
    },
    {
      "number": 1203,
      "title": "Sort Items by Groups Respecting Dependencies",
      "titleSlug": "sort-items-by-groups-respecting-dependencies",
      "difficulty": "Hard",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Graph",
        "Topological Sort"
      ],
      "description": "There are&nbsp;n&nbsp;items each&nbsp;belonging to zero or one of&nbsp;m&nbsp;groups where group[i]&nbsp;is the group that the i-th item belongs to and it&#39;s equal to -1&nbsp;if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it. Return a sorted list of the items such that: The items that belong to the same group are next to each other in the sorted list. There are some&nbsp;relations&nbsp;between these items where&nbsp;beforeItems[i]&nbsp;is a list containing all the items that should come before the&nbsp;i-th item in the sorted array (to the left of the&nbsp;i-th item). Return any solution if there is more than one solution and return an empty list&nbsp;if there is no solution. &nbsp; Example 1: Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]] Output: [6,3,4,1,5,2,0,7] Example 2: Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]] Output: [] Explanation:&nbsp;This is the same as example 1 except that 4 needs to be before 6 in the sorted list. &nbsp; Constraints: 1 &lt;= m &lt;= n &lt;= 3 * 104 group.length == beforeItems.length == n -1 &lt;= group[i] &lt;= m - 1 0 &lt;= beforeItems[i].length &lt;= n - 1 0 &lt;= beforeItems[i][j] &lt;= n - 1 i != beforeItems[i][j] beforeItems[i]&nbsp;does not contain&nbsp;duplicates elements."
    },
    {
      "number": 1204,
      "title": "Last Person to Fit in the Bus",
      "titleSlug": "last-person-to-fit-in-the-bus",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Queue +-------------+---------+ | Column Name | Type | +-------------+---------+ | person_id | int | | person_name | varchar | | weight | int | | turn | int | +-------------+---------+ person_id column contains unique values. This table has the information about all people waiting for a bus. The person_id and turn columns will contain all numbers from 1 to n, where n is the number of rows in the table. turn determines the order of which the people will board the bus, where turn=1 denotes the first person to board and turn=n denotes the last person to board. weight is the weight of the person in kilograms. &nbsp; There is a queue of people waiting to board a bus. However, the bus has a weight limit of 1000 kilograms, so there may be some people who cannot board. Write a solution to find the person_name of the last person that can fit on the bus without exceeding the weight limit. The test cases are generated such that the first person does not exceed the weight limit. Note that only one person can board the bus at any given turn. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Queue table: +-----------+-------------+--------+------+ | person_id | person_name | weight | turn | +-----------+-------------+--------+------+ | 5 | Alice | 250 | 1 | | 4 | Bob | 175 | 5 | | 3 | Alex | 350 | 2 | | 6 | John Cena | 400 | 3 | | 1 | Winston | 500 | 6 | | 2 | Marie | 200 | 4 | +-----------+-------------+--------+------+ Output: +-------------+ | person_name | +-------------+ | John Cena | +-------------+ Explanation: The folowing table is ordered by the turn for simplicity. +------+----+-----------+--------+--------------+ | Turn | ID | Name | Weight | Total Weight | +------+----+-----------+--------+--------------+ | 1 | 5 | Alice | 250 | 250 | | 2 | 3 | Alex | 350 | 600 | | 3 | 6 | John Cena | 400 | 1000 | (last person to board) | 4 | 2 | Marie | 200 | 1200 | (cannot board) | 5 | 4 | Bob | 175 | ___ | | 6 | 1 | Winston | 500 | ___ | +------+----+-----------+--------+--------------+"
    },
    {
      "number": 1206,
      "title": "Design Skiplist",
      "titleSlug": "design-skiplist",
      "difficulty": "Hard",
      "tags": [
        "Linked List",
        "Design"
      ],
      "description": "Design a Skiplist without using any built-in libraries. A skiplist is a data structure that takes O(log(n)) time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists. For example, we have a Skiplist containing [30,40,50,60,70,90] and we want to add 80 and 45 into it. The Skiplist works this way: Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than O(n). It can be proven that the average time complexity for each operation is O(log(n)) and space complexity is O(n). See more about Skiplist: https://en.wikipedia.org/wiki/Skip_list Implement the Skiplist class: Skiplist() Initializes the object of the skiplist. bool search(int target) Returns true if the integer target exists in the Skiplist or false otherwise. void add(int num) Inserts the value num into the SkipList. bool erase(int num) Removes the value num from the Skiplist and returns true. If num does not exist in the Skiplist, do nothing and return false. If there exist multiple num values, removing any one of them is fine. Note that duplicates may exist in the Skiplist, your code needs to handle this situation. &nbsp; Example 1: Input [&quot;Skiplist&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;search&quot;, &quot;add&quot;, &quot;search&quot;, &quot;erase&quot;, &quot;erase&quot;, &quot;search&quot;] [[], [1], [2], [3], [0], [4], [1], [0], [1], [1]] Output [null, null, null, null, false, null, true, false, true, false] Explanation Skiplist skiplist = new Skiplist(); skiplist.add(1); skiplist.add(2); skiplist.add(3); skiplist.search(0); // return False skiplist.add(4); skiplist.search(1); // return True skiplist.erase(0); // return False, 0 is not in skiplist. skiplist.erase(1); // return True skiplist.search(1); // return False, 1 has already been erased. &nbsp; Constraints: 0 &lt;= num, target &lt;= 2 * 104 At most 5 * 104 calls will be made to search, add, and erase."
    },
    {
      "number": 1207,
      "title": "Unique Number of Occurrences",
      "titleSlug": "unique-number-of-occurrences",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table"
      ],
      "description": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise. &nbsp; Example 1: Input: arr = [1,2,2,1,1,3] Output: true Explanation:&nbsp;The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences. Example 2: Input: arr = [1,2] Output: false Example 3: Input: arr = [-3,0,1,-3,1,1,1,-3,10,0] Output: true &nbsp; Constraints: 1 &lt;= arr.length &lt;= 1000 -1000 &lt;= arr[i] &lt;= 1000"
    },
    {
      "number": 1208,
      "title": "Get Equal Substrings Within Budget",
      "titleSlug": "get-equal-substrings-within-budget",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Binary Search",
        "Sliding Window",
        "Prefix Sum"
      ],
      "description": "You are given two strings s and t of the same length and an integer maxCost. You want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters). Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0. &nbsp; Example 1: Input: s = &quot;abcd&quot;, t = &quot;bcdf&quot;, maxCost = 3 Output: 3 Explanation: &quot;abc&quot; of s can change to &quot;bcd&quot;. That costs 3, so the maximum length is 3. Example 2: Input: s = &quot;abcd&quot;, t = &quot;cdef&quot;, maxCost = 3 Output: 1 Explanation: Each character in s costs 2 to change to character in t, so the maximum length is 1. Example 3: Input: s = &quot;abcd&quot;, t = &quot;acde&quot;, maxCost = 0 Output: 1 Explanation: You cannot make any change, so the maximum length is 1. &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 t.length == s.length 0 &lt;= maxCost &lt;= 106 s and t consist of only lowercase English letters."
    },
    {
      "number": 1209,
      "title": "Remove All Adjacent Duplicates in String II",
      "titleSlug": "remove-all-adjacent-duplicates-in-string-ii",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Stack"
      ],
      "description": "You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together. We repeatedly make k duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique. &nbsp; Example 1: Input: s = &quot;abcd&quot;, k = 2 Output: &quot;abcd&quot; Explanation: There&#39;s nothing to delete. Example 2: Input: s = &quot;deeedbbcccbdaa&quot;, k = 3 Output: &quot;aa&quot; Explanation: First delete &quot;eee&quot; and &quot;ccc&quot;, get &quot;ddbbbdaa&quot; Then delete &quot;bbb&quot;, get &quot;dddaa&quot; Finally delete &quot;ddd&quot;, get &quot;aa&quot; Example 3: Input: s = &quot;pbbcggttciiippooaais&quot;, k = 2 Output: &quot;ps&quot; &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 2 &lt;= k &lt;= 104 s only contains lowercase English letters."
    },
    {
      "number": 1210,
      "title": "Minimum Moves to Reach Target with Rotations",
      "titleSlug": "minimum-moves-to-reach-target-with-rotations",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "In an&nbsp;n*n&nbsp;grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at&nbsp;(n-1, n-2)&nbsp;and&nbsp;(n-1, n-1). In one move the snake can: Move one cell to the right&nbsp;if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is. Move down one cell&nbsp;if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is. Rotate clockwise if it&#39;s in a horizontal position and the two cells under it are both empty. In that case the snake moves from&nbsp;(r, c)&nbsp;and&nbsp;(r, c+1)&nbsp;to&nbsp;(r, c)&nbsp;and&nbsp;(r+1, c). Rotate counterclockwise&nbsp;if it&#39;s in a vertical position and the two cells to its right are both empty. In that case the snake moves from&nbsp;(r, c)&nbsp;and&nbsp;(r+1, c)&nbsp;to&nbsp;(r, c)&nbsp;and&nbsp;(r, c+1). Return the minimum number of moves to reach the target. If there is no way to reach the target, return&nbsp;-1. &nbsp; Example 1: Input: grid = [[0,0,0,0,0,1], [1,1,0,0,1,0], &nbsp; [0,0,0,0,1,1], &nbsp; [0,0,1,0,1,0], &nbsp; [0,1,1,0,0,0], &nbsp; [0,1,1,0,0,0]] Output: 11 Explanation: One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]. Example 2: Input: grid = [[0,0,1,1,1,1], &nbsp; [0,0,0,0,1,1], &nbsp; [1,1,0,0,0,1], &nbsp; [1,1,1,0,0,1], &nbsp; [1,1,1,0,0,1], &nbsp; [1,1,1,0,0,0]] Output: 9 &nbsp; Constraints: 2 &lt;= n &lt;= 100 0 &lt;= grid[i][j] &lt;= 1 It is guaranteed that the snake starts at empty cells."
    },
    {
      "number": 1211,
      "title": "Queries Quality and Percentage",
      "titleSlug": "queries-quality-and-percentage",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Queries +-------------+---------+ | Column Name | Type | +-------------+---------+ | query_name | varchar | | result | varchar | | position | int | | rating | int | +-------------+---------+ This table may have duplicate rows. This table contains information collected from some queries on a database. The position column has a value from 1 to 500. The rating column has a value from 1 to 5. Query with rating less than 3 is a poor query. &nbsp; We define query quality as: The average of the ratio between query rating and its position. We also define poor query percentage as: The percentage of all queries with rating less than 3. Write a solution to find each query_name, the quality and poor_query_percentage. Both quality and poor_query_percentage should be rounded to 2 decimal places. Return the result table in any order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Queries table: +------------+-------------------+----------+--------+ | query_name | result | position | rating | +------------+-------------------+----------+--------+ | Dog | Golden Retriever | 1 | 5 | | Dog | German Shepherd | 2 | 5 | | Dog | Mule | 200 | 1 | | Cat | Shirazi | 5 | 2 | | Cat | Siamese | 3 | 3 | | Cat | Sphynx | 7 | 4 | +------------+-------------------+----------+--------+ Output: +------------+---------+-----------------------+ | query_name | quality | poor_query_percentage | +------------+---------+-----------------------+ | Dog | 2.50 | 33.33 | | Cat | 0.66 | 33.33 | +------------+---------+-----------------------+ Explanation: Dog queries quality is ((5 / 1) + (5 / 2) + (1 / 200)) / 3 = 2.50 Dog queries poor_ query_percentage is (1 / 3) * 100 = 33.33 Cat queries quality equals ((2 / 5) + (3 / 3) + (4 / 7)) / 3 = 0.66 Cat queries poor_ query_percentage is (1 / 3) * 100 = 33.33"
    },
    {
      "number": 1217,
      "title": "Minimum Cost to Move Chips to The Same Position",
      "titleSlug": "minimum-cost-to-move-chips-to-the-same-position",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math",
        "Greedy"
      ],
      "description": "We have n chips, where the position of the ith chip is position[i]. We need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to: position[i] + 2 or position[i] - 2 with cost = 0. position[i] + 1 or position[i] - 1 with cost = 1. Return the minimum cost needed to move all the chips to the same position. &nbsp; Example 1: Input: position = [1,2,3] Output: 1 Explanation: First step: Move the chip at position 3 to position 1 with cost = 0. Second step: Move the chip at position 2 to position 1 with cost = 1. Total cost is 1. Example 2: Input: position = [2,2,2,3,3] Output: 2 Explanation: We can move the two chips at position 3 to position 2. Each move has cost = 1. The total cost = 2. Example 3: Input: position = [1,1000000000] Output: 1 &nbsp; Constraints: 1 &lt;= position.length &lt;= 100 1 &lt;= position[i] &lt;= 10^9"
    },
    {
      "number": 1218,
      "title": "Longest Arithmetic Subsequence of Given Difference",
      "titleSlug": "longest-arithmetic-subsequence-of-given-difference",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Dynamic Programming"
      ],
      "description": "Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference. A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements. &nbsp; Example 1: Input: arr = [1,2,3,4], difference = 1 Output: 4 Explanation: The longest arithmetic subsequence is [1,2,3,4]. Example 2: Input: arr = [1,3,5,7], difference = 1 Output: 1 Explanation: The longest arithmetic subsequence is any single element. Example 3: Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2 Output: 4 Explanation: The longest arithmetic subsequence is [7,5,3,1]. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 105 -104 &lt;= arr[i], difference &lt;= 104"
    },
    {
      "number": 1219,
      "title": "Path with Maximum Gold",
      "titleSlug": "path-with-maximum-gold",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Backtracking",
        "Matrix"
      ],
      "description": "In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty. Return the maximum amount of gold you can collect under the conditions: Every time you are located in a cell you will collect all the gold in that cell. From your position, you can walk one step to the left, right, up, or down. You can&#39;t visit the same cell more than once. Never visit a cell with 0 gold. You can start and stop collecting gold from any position in the grid that has some gold. &nbsp; Example 1: Input: grid = [[0,6,0],[5,8,7],[0,9,0]] Output: 24 Explanation: [[0,6,0], [5,8,7], [0,9,0]] Path to get the maximum gold, 9 -&gt; 8 -&gt; 7. Example 2: Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]] Output: 28 Explanation: [[1,0,7], [2,0,6], [3,4,5], [0,3,0], [9,0,20]] Path to get the maximum gold, 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7. &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 15 0 &lt;= grid[i][j] &lt;= 100 There are at most 25 cells containing gold."
    },
    {
      "number": 1220,
      "title": "Count Vowels Permutation",
      "titleSlug": "count-vowels-permutation",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "Given an integer n, your task is to count how many strings of length n can be formed under the following rules: Each character is a lower case vowel&nbsp;(&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;) Each vowel&nbsp;&#39;a&#39; may only be followed by an &#39;e&#39;. Each vowel&nbsp;&#39;e&#39; may only be followed by an &#39;a&#39;&nbsp;or an &#39;i&#39;. Each vowel&nbsp;&#39;i&#39; may not be followed by another &#39;i&#39;. Each vowel&nbsp;&#39;o&#39; may only be followed by an &#39;i&#39; or a&nbsp;&#39;u&#39;. Each vowel&nbsp;&#39;u&#39; may only be followed by an &#39;a&#39;. Since the answer&nbsp;may be too large,&nbsp;return it modulo&nbsp;10^9 + 7. &nbsp; Example 1: Input: n = 1 Output: 5 Explanation: All possible strings are: &quot;a&quot;, &quot;e&quot;, &quot;i&quot; , &quot;o&quot; and &quot;u&quot;. Example 2: Input: n = 2 Output: 10 Explanation: All possible strings are: &quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; and &quot;ua&quot;. Example 3:&nbsp; Input: n = 5 Output: 68 &nbsp; Constraints: 1 &lt;= n &lt;= 2 * 10^4"
    },
    {
      "number": 1221,
      "title": "Split a String in Balanced Strings",
      "titleSlug": "split-a-string-in-balanced-strings",
      "difficulty": "Easy",
      "tags": [
        "String",
        "Greedy",
        "Counting"
      ],
      "description": "Balanced strings are those that have an equal quantity of &#39;L&#39; and &#39;R&#39; characters. Given a balanced string s, split it into some number of substrings such that: Each substring is balanced. Return the maximum number of balanced strings you can obtain. &nbsp; Example 1: Input: s = &quot;RLRRLLRLRL&quot; Output: 4 Explanation: s can be split into &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, each substring contains same number of &#39;L&#39; and &#39;R&#39;. Example 2: Input: s = &quot;RLRRRLLRLL&quot; Output: 2 Explanation: s can be split into &quot;RL&quot;, &quot;RRRLLRLL&quot;, each substring contains same number of &#39;L&#39; and &#39;R&#39;. Note that s cannot be split into &quot;RL&quot;, &quot;RR&quot;, &quot;RL&quot;, &quot;LR&quot;, &quot;LL&quot;, because the 2nd and 5th substrings are not balanced. Example 3: Input: s = &quot;LLLLRRRR&quot; Output: 1 Explanation: s can be split into &quot;LLLLRRRR&quot;. &nbsp; Constraints: 2 &lt;= s.length &lt;= 1000 s[i] is either &#39;L&#39; or &#39;R&#39;. s is a balanced string."
    },
    {
      "number": 1222,
      "title": "Queens That Can Attack the King",
      "titleSlug": "queens-that-can-attack-the-king",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Matrix",
        "Simulation"
      ],
      "description": "On a 0-indexed 8 x 8 chessboard, there can be multiple black queens and one white king. You are given a 2D integer array queens where queens[i] = [xQueeni, yQueeni] represents the position of the ith black queen on the chessboard. You are also given an integer array king of length 2 where king = [xKing, yKing] represents the position of the white king. Return the coordinates of the black queens that can directly attack the king. You may return the answer in any order. &nbsp; Example 1: Input: queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0] Output: [[0,1],[1,0],[3,3]] Explanation: The diagram above shows the three queens that can directly attack the king and the three queens that cannot attack the king (i.e., marked with red dashes). Example 2: Input: queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3] Output: [[2,2],[3,4],[4,4]] Explanation: The diagram above shows the three queens that can directly attack the king and the three queens that cannot attack the king (i.e., marked with red dashes). &nbsp; Constraints: 1 &lt;= queens.length &lt; 64 queens[i].length == king.length == 2 0 &lt;= xQueeni, yQueeni, xKing, yKing &lt; 8 All the given positions are unique."
    },
    {
      "number": 1223,
      "title": "Dice Roll Simulation",
      "titleSlug": "dice-roll-simulation",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] (1-indexed) consecutive times. Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls. Since the answer may be too large, return it modulo 109 + 7. Two sequences are considered different if at least one element differs from each other. &nbsp; Example 1: Input: n = 2, rollMax = [1,1,2,2,2,3] Output: 34 Explanation: There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34. Example 2: Input: n = 2, rollMax = [1,1,1,1,1,1] Output: 30 Example 3: Input: n = 3, rollMax = [1,1,1,2,2,3] Output: 181 &nbsp; Constraints: 1 &lt;= n &lt;= 5000 rollMax.length == 6 1 &lt;= rollMax[i] &lt;= 15"
    },
    {
      "number": 1224,
      "title": "Maximum Equal Frequency",
      "titleSlug": "maximum-equal-frequency",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table"
      ],
      "description": "Given an array nums of positive integers, return the longest possible length of an array prefix of nums, such that it is possible to remove exactly one element from this prefix so that every number that has appeared in it will have the same number of occurrences. If after removing one element there are no remaining elements, it&#39;s still considered that every appeared number has the same number of ocurrences (0). &nbsp; Example 1: Input: nums = [2,2,1,1,5,3,3,5] Output: 7 Explanation: For the subarray [2,2,1,1,5,3,3] of length 7, if we remove nums[4] = 5, we will get [2,2,1,1,3,3], so that each number will appear exactly twice. Example 2: Input: nums = [1,1,1,2,2,2,3,3,3,4,4,4,5] Output: 13 &nbsp; Constraints: 2 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105"
    },
    {
      "number": 1226,
      "title": "The Dining Philosophers",
      "titleSlug": "the-dining-philosophers",
      "difficulty": "Medium",
      "tags": [
        "Concurrency"
      ],
      "description": "Five silent philosophers&nbsp;sit at a round table with bowls of spaghetti. Forks are placed between each pair of adjacent philosophers. Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right forks. Each fork can be held by only one philosopher and so a philosopher can use the fork only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both forks so that the forks become available to others. A philosopher can take the fork on their right or the one on their left as they become available, but cannot start eating before getting both forks. Eating is not limited by the remaining amounts of spaghetti or stomach space; an infinite supply and an infinite demand are assumed. Design a discipline of behaviour (a concurrent algorithm) such that no philosopher will starve;&nbsp;i.e., each can forever continue to alternate between eating and thinking, assuming that no philosopher can know when others may want to eat or think. The problem statement and the image above are taken from wikipedia.org &nbsp; The philosophers&#39; ids are numbered from 0 to 4 in a clockwise order. Implement the function&nbsp;void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) where: philosopher&nbsp;is the id of the philosopher who wants to eat. pickLeftFork&nbsp;and&nbsp;pickRightFork&nbsp;are functions you can call to pick the corresponding forks of that philosopher. eat&nbsp;is a function you can call to let the philosopher eat once he has picked&nbsp;both forks. putLeftFork&nbsp;and&nbsp;putRightFork&nbsp;are functions you can call to put down the corresponding forks of that philosopher. The philosophers are assumed to be thinking as long as they are not asking to eat (the function is not being called with their number). Five threads, each representing a philosopher, will&nbsp;simultaneously use one object of your class to simulate the process. The function may be called for the same philosopher more than once, even before the last call ends. &nbsp; Example 1: Input: n = 1 Output: [[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]] Explanation: n is the number of times each philosopher will call the function. The output array describes the calls you made to the functions controlling the forks and the eat function, its format is: output[i] = [a, b, c] (three integers) - a is the id of a philosopher. - b specifies the fork: {1 : left, 2 : right}. - c specifies the operation: {1 : pick, 2 : put, 3 : eat}. &nbsp; Constraints: 1 &lt;= n &lt;= 60"
    },
    {
      "number": 1227,
      "title": "Airplane Seat Assignment Probability",
      "titleSlug": "airplane-seat-assignment-probability",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Dynamic Programming",
        "Brainteaser",
        "Probability and Statistics"
      ],
      "description": "n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will: Take their own seat if it is still available, and Pick other seats randomly when they find their seat occupied Return the probability that the nth person gets his own seat. &nbsp; Example 1: Input: n = 1 Output: 1.00000 Explanation: The first person can only get the first seat. Example 2: Input: n = 2 Output: 0.50000 Explanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat). &nbsp; Constraints: 1 &lt;= n &lt;= 105"
    },
    {
      "number": 1232,
      "title": "Check If It Is a Straight Line",
      "titleSlug": "check-if-it-is-a-straight-line",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math",
        "Geometry"
      ],
      "description": "You are given an array&nbsp;coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points&nbsp;make a straight line in the XY plane. &nbsp; &nbsp; Example 1: Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]] Output: true Example 2: Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]] Output: false &nbsp; Constraints: 2 &lt;=&nbsp;coordinates.length &lt;= 1000 coordinates[i].length == 2 -10^4 &lt;=&nbsp;coordinates[i][0],&nbsp;coordinates[i][1] &lt;= 10^4 coordinates&nbsp;contains no duplicate point."
    },
    {
      "number": 1233,
      "title": "Remove Sub-Folders from the Filesystem",
      "titleSlug": "remove-sub-folders-from-the-filesystem",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "String",
        "Depth-First Search",
        "Trie"
      ],
      "description": "Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order. If a folder[i] is located within another folder[j], it is called a sub-folder of it. A sub-folder of folder[j] must start with folder[j], followed by a &quot;/&quot;. For example, &quot;/a/b&quot; is a sub-folder of &quot;/a&quot;, but &quot;/b&quot; is not a sub-folder of &quot;/a/b/c&quot;. The format of a path is one or more concatenated strings of the form: &#39;/&#39; followed by one or more lowercase English letters. For example, &quot;/leetcode&quot; and &quot;/leetcode/problems&quot; are valid paths while an empty string and &quot;/&quot; are not. &nbsp; Example 1: Input: folder = [&quot;/a&quot;,&quot;/a/b&quot;,&quot;/c/d&quot;,&quot;/c/d/e&quot;,&quot;/c/f&quot;] Output: [&quot;/a&quot;,&quot;/c/d&quot;,&quot;/c/f&quot;] Explanation: Folders &quot;/a/b&quot; is a subfolder of &quot;/a&quot; and &quot;/c/d/e&quot; is inside of folder &quot;/c/d&quot; in our filesystem. Example 2: Input: folder = [&quot;/a&quot;,&quot;/a/b/c&quot;,&quot;/a/b/d&quot;] Output: [&quot;/a&quot;] Explanation: Folders &quot;/a/b/c&quot; and &quot;/a/b/d&quot; will be removed because they are subfolders of &quot;/a&quot;. Example 3: Input: folder = [&quot;/a/b/c&quot;,&quot;/a/b/ca&quot;,&quot;/a/b/d&quot;] Output: [&quot;/a/b/c&quot;,&quot;/a/b/ca&quot;,&quot;/a/b/d&quot;] &nbsp; Constraints: 1 &lt;= folder.length &lt;= 4 * 104 2 &lt;= folder[i].length &lt;= 100 folder[i] contains only lowercase letters and &#39;/&#39;. folder[i] always starts with the character &#39;/&#39;. Each folder name is unique."
    },
    {
      "number": 1234,
      "title": "Replace the Substring for Balanced String",
      "titleSlug": "replace-the-substring-for-balanced-string",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Sliding Window"
      ],
      "description": "You are given a string s of length n containing only four kinds of characters: &#39;Q&#39;, &#39;W&#39;, &#39;E&#39;, and &#39;R&#39;. A string is said to be balanced if each of its characters appears n / 4 times where n is the length of the string. Return the minimum length of the substring that can be replaced with any other string of the same length to make s balanced. If s is already balanced, return 0. &nbsp; Example 1: Input: s = &quot;QWER&quot; Output: 0 Explanation: s is already balanced. Example 2: Input: s = &quot;QQWE&quot; Output: 1 Explanation: We need to replace a &#39;Q&#39; to &#39;R&#39;, so that &quot;RQWE&quot; (or &quot;QRWE&quot;) is balanced. Example 3: Input: s = &quot;QQQW&quot; Output: 2 Explanation: We can replace the first &quot;QQ&quot; to &quot;ER&quot;. &nbsp; Constraints: n == s.length 4 &lt;= n &lt;= 105 n is a multiple of 4. s contains only &#39;Q&#39;, &#39;W&#39;, &#39;E&#39;, and &#39;R&#39;."
    },
    {
      "number": 1235,
      "title": "Maximum Profit in Job Scheduling",
      "titleSlug": "maximum-profit-in-job-scheduling",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Binary Search",
        "Dynamic Programming",
        "Sorting"
      ],
      "description": "We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i]. You&#39;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range. If you choose a job that ends at time X you will be able to start another job that starts at time X. &nbsp; Example 1: Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70] Output: 120 Explanation: The subset chosen is the first and fourth job. Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70. Example 2: Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60] Output: 150 Explanation: The subset chosen is the first, fourth and fifth job. Profit obtained 150 = 20 + 70 + 60. Example 3: Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4] Output: 6 &nbsp; Constraints: 1 &lt;= startTime.length == endTime.length == profit.length &lt;= 5 * 104 1 &lt;= startTime[i] &lt; endTime[i] &lt;= 109 1 &lt;= profit[i] &lt;= 104"
    },
    {
      "number": 1237,
      "title": "Find Positive Integer Solution for a Given Equation",
      "titleSlug": "find-positive-integer-solution-for-a-given-equation",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Two Pointers",
        "Binary Search",
        "Interactive"
      ],
      "description": "Given a callable function f(x, y) with a hidden formula and a value z, reverse engineer the formula and return all positive integer pairs x and y where f(x,y) == z. You may return the pairs in any order. While the exact formula is hidden, the function is monotonically increasing, i.e.: f(x, y) &lt; f(x + 1, y) f(x, y) &lt; f(x, y + 1) The function interface is defined like this: interface CustomFunction { public: // Returns some positive integer f(x, y) for two positive integers x and y based on a formula. int f(int x, int y); }; We will judge your solution as follows: The judge has a list of 9 hidden implementations of CustomFunction, along with a way to generate an answer key of all valid pairs for a specific z. The judge will receive two inputs: a function_id (to determine which implementation to test your code with), and the target z. The judge will call your findSolution and compare your results with the answer key. If your results match the answer key, your solution will be Accepted. &nbsp; Example 1: Input: function_id = 1, z = 5 Output: [[1,4],[2,3],[3,2],[4,1]] Explanation: The hidden formula for function_id = 1 is f(x, y) = x + y. The following positive integer values of x and y make f(x, y) equal to 5: x=1, y=4 -&gt; f(1, 4) = 1 + 4 = 5. x=2, y=3 -&gt; f(2, 3) = 2 + 3 = 5. x=3, y=2 -&gt; f(3, 2) = 3 + 2 = 5. x=4, y=1 -&gt; f(4, 1) = 4 + 1 = 5. Example 2: Input: function_id = 2, z = 5 Output: [[1,5],[5,1]] Explanation: The hidden formula for function_id = 2 is f(x, y) = x * y. The following positive integer values of x and y make f(x, y) equal to 5: x=1, y=5 -&gt; f(1, 5) = 1 * 5 = 5. x=5, y=1 -&gt; f(5, 1) = 5 * 1 = 5. &nbsp; Constraints: 1 &lt;= function_id &lt;= 9 1 &lt;= z &lt;= 100 It is guaranteed that the solutions of f(x, y) == z will be in the range 1 &lt;= x, y &lt;= 1000. It is also guaranteed that f(x, y) will fit in 32 bit signed integer if 1 &lt;= x, y &lt;= 1000."
    },
    {
      "number": 1238,
      "title": "Circular Permutation in Binary Representation",
      "titleSlug": "circular-permutation-in-binary-representation",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Backtracking",
        "Bit Manipulation"
      ],
      "description": "Given 2 integers n and start. Your task is return any permutation p&nbsp;of (0,1,2.....,2^n -1) such that : p[0] = start p[i] and p[i+1]&nbsp;differ by only one bit in their binary representation. p[0] and p[2^n -1]&nbsp;must also differ by only one bit in their binary representation. &nbsp; Example 1: Input: n = 2, start = 3 Output: [3,2,0,1] Explanation: The binary representation of the permutation is (11,10,00,01). All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2] Example 2: Input: n = 3, start = 2 Output: [2,6,7,5,4,0,1,3] Explanation: The binary representation of the permutation is (010,110,111,101,100,000,001,011). &nbsp; Constraints: 1 &lt;= n &lt;= 16 0 &lt;= start&nbsp;&lt;&nbsp;2 ^ n"
    },
    {
      "number": 1239,
      "title": "Maximum Length of a Concatenated String with Unique Characters",
      "titleSlug": "maximum-length-of-a-concatenated-string-with-unique-characters",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "String",
        "Backtracking",
        "Bit Manipulation"
      ],
      "description": "You are given an array of strings arr. A string s is formed by the concatenation of a subsequence of arr that has unique characters. Return the maximum possible length of s. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. &nbsp; Example 1: Input: arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;] Output: 4 Explanation: All the valid concatenations are: - &quot;&quot; - &quot;un&quot; - &quot;iq&quot; - &quot;ue&quot; - &quot;uniq&quot; (&quot;un&quot; + &quot;iq&quot;) - &quot;ique&quot; (&quot;iq&quot; + &quot;ue&quot;) Maximum length is 4. Example 2: Input: arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;] Output: 6 Explanation: Possible longest valid concatenations are &quot;chaers&quot; (&quot;cha&quot; + &quot;ers&quot;) and &quot;acters&quot; (&quot;act&quot; + &quot;ers&quot;). Example 3: Input: arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;] Output: 26 Explanation: The only string in arr has all 26 characters. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 16 1 &lt;= arr[i].length &lt;= 26 arr[i] contains only lowercase English letters."
    },
    {
      "number": 1240,
      "title": "Tiling a Rectangle with the Fewest Squares",
      "titleSlug": "tiling-a-rectangle-with-the-fewest-squares",
      "difficulty": "Hard",
      "tags": [
        "Backtracking"
      ],
      "description": "Given a rectangle of size n x m, return the minimum number of integer-sided squares that tile the rectangle. &nbsp; Example 1: Input: n = 2, m = 3 Output: 3 Explanation: 3 squares are necessary to cover the rectangle. 2 (squares of 1x1) 1 (square of 2x2) Example 2: Input: n = 5, m = 8 Output: 5 Example 3: Input: n = 11, m = 13 Output: 6 &nbsp; Constraints: 1 &lt;= n, m &lt;= 13"
    },
    {
      "number": 1247,
      "title": "Minimum Swaps to Make Strings Equal",
      "titleSlug": "minimum-swaps-to-make-strings-equal",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "String",
        "Greedy"
      ],
      "description": "You are given two strings s1 and s2 of equal length consisting of letters &quot;x&quot; and &quot;y&quot; only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j]. Return the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so. &nbsp; Example 1: Input: s1 = &quot;xx&quot;, s2 = &quot;yy&quot; Output: 1 Explanation: Swap s1[0] and s2[1], s1 = &quot;yx&quot;, s2 = &quot;yx&quot;. Example 2: Input: s1 = &quot;xy&quot;, s2 = &quot;yx&quot; Output: 2 Explanation: Swap s1[0] and s2[0], s1 = &quot;yy&quot;, s2 = &quot;xx&quot;. Swap s1[0] and s2[1], s1 = &quot;xy&quot;, s2 = &quot;xy&quot;. Note that you cannot swap s1[0] and s1[1] to make s1 equal to &quot;yx&quot;, cause we can only swap chars in different strings. Example 3: Input: s1 = &quot;xx&quot;, s2 = &quot;xy&quot; Output: -1 &nbsp; Constraints: 1 &lt;= s1.length, s2.length &lt;= 1000 s1.length == s2.length s1, s2 only contain &#39;x&#39; or &#39;y&#39;."
    },
    {
      "number": 1248,
      "title": "Count Number of Nice Subarrays",
      "titleSlug": "count-number-of-nice-subarrays",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Math",
        "Sliding Window",
        "Prefix Sum"
      ],
      "description": "Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it. Return the number of nice sub-arrays. &nbsp; Example 1: Input: nums = [1,1,2,1,1], k = 3 Output: 2 Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1]. Example 2: Input: nums = [2,4,6], k = 1 Output: 0 Explanation: There are no odd numbers in the array. Example 3: Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2 Output: 16 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 50000 1 &lt;= nums[i] &lt;= 10^5 1 &lt;= k &lt;= nums.length"
    },
    {
      "number": 1249,
      "title": "Minimum Remove to Make Valid Parentheses",
      "titleSlug": "minimum-remove-to-make-valid-parentheses",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Stack"
      ],
      "description": "Given a string s of &#39;(&#39; , &#39;)&#39; and lowercase English characters. Your task is to remove the minimum number of parentheses ( &#39;(&#39; or &#39;)&#39;, in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if: It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. &nbsp; Example 1: Input: s = &quot;lee(t(c)o)de)&quot; Output: &quot;lee(t(c)o)de&quot; Explanation: &quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; would also be accepted. Example 2: Input: s = &quot;a)b(c)d&quot; Output: &quot;ab(c)d&quot; Example 3: Input: s = &quot;))((&quot; Output: &quot;&quot; Explanation: An empty string is also valid. &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s[i] is either&nbsp;&#39;(&#39; , &#39;)&#39;, or lowercase English letter."
    },
    {
      "number": 1250,
      "title": "Check If It Is a Good Array",
      "titleSlug": "check-if-it-is-a-good-array",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Number Theory"
      ],
      "description": "Given an array nums of&nbsp;positive integers. Your task is to select some subset of nums, multiply each element by an integer and add all these numbers.&nbsp;The array is said to be&nbsp;good&nbsp;if you can obtain a sum of&nbsp;1&nbsp;from the array by any possible subset and multiplicand. Return&nbsp;True&nbsp;if the array is good&nbsp;otherwise&nbsp;return&nbsp;False. &nbsp; Example 1: Input: nums = [12,5,7,23] Output: true Explanation: Pick numbers 5 and 7. 5*3 + 7*(-2) = 1 Example 2: Input: nums = [29,6,10] Output: true Explanation: Pick numbers 29, 6 and 10. 29*1 + 6*(-3) + 10*(-1) = 1 Example 3: Input: nums = [3,6] Output: false &nbsp; Constraints: 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^9"
    },
    {
      "number": 1251,
      "title": "Average Selling Price",
      "titleSlug": "average-selling-price",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Prices +---------------+---------+ | Column Name | Type | +---------------+---------+ | product_id | int | | start_date | date | | end_date | date | | price | int | +---------------+---------+ (product_id, start_date, end_date) is the primary key (combination of columns with unique values) for this table. Each row of this table indicates the price of the product_id in the period from start_date to end_date. For each product_id there will be no two overlapping periods. That means there will be no two intersecting periods for the same product_id. &nbsp; Table: UnitsSold +---------------+---------+ | Column Name | Type | +---------------+---------+ | product_id | int | | purchase_date | date | | units | int | +---------------+---------+ This table may contain duplicate rows. Each row of this table indicates the date, units, and product_id of each product sold. &nbsp; Write a solution to find the average selling price for each product. average_price should be rounded to 2 decimal places. If a product does not have any sold units, its average selling price is assumed to be 0. Return the result table in any order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Prices table: +------------+------------+------------+--------+ | product_id | start_date | end_date | price | +------------+------------+------------+--------+ | 1 | 2019-02-17 | 2019-02-28 | 5 | | 1 | 2019-03-01 | 2019-03-22 | 20 | | 2 | 2019-02-01 | 2019-02-20 | 15 | | 2 | 2019-02-21 | 2019-03-31 | 30 | +------------+------------+------------+--------+ UnitsSold table: +------------+---------------+-------+ | product_id | purchase_date | units | +------------+---------------+-------+ | 1 | 2019-02-25 | 100 | | 1 | 2019-03-01 | 15 | | 2 | 2019-02-10 | 200 | | 2 | 2019-03-22 | 30 | +------------+---------------+-------+ Output: +------------+---------------+ | product_id | average_price | +------------+---------------+ | 1 | 6.96 | | 2 | 16.96 | +------------+---------------+ Explanation: Average selling price = Total Price of Product / Number of products sold. Average selling price for product 1 = ((100 * 5) + (15 * 20)) / 115 = 6.96 Average selling price for product 2 = ((200 * 15) + (30 * 30)) / 230 = 16.96"
    },
    {
      "number": 1252,
      "title": "Cells with Odd Values in a Matrix",
      "titleSlug": "cells-with-odd-values-in-a-matrix",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math",
        "Simulation"
      ],
      "description": "There is an m x n matrix that is initialized to all 0&#39;s. There is also a 2D array indices where each indices[i] = [ri, ci] represents a 0-indexed location to perform some increment operations on the matrix. For each location indices[i], do both of the following: Increment all the cells on row ri. Increment all the cells on column ci. Given m, n, and indices, return the number of odd-valued cells in the matrix after applying the increment to all locations in indices. &nbsp; Example 1: Input: m = 2, n = 3, indices = [[0,1],[1,1]] Output: 6 Explanation: Initial matrix = [[0,0,0],[0,0,0]]. After applying first increment it becomes [[1,2,1],[0,1,0]]. The final matrix is [[1,3,1],[1,3,1]], which contains 6 odd numbers. Example 2: Input: m = 2, n = 2, indices = [[1,1],[0,0]] Output: 0 Explanation: Final matrix = [[2,2],[2,2]]. There are no odd numbers in the final matrix. &nbsp; Constraints: 1 &lt;= m, n &lt;= 50 1 &lt;= indices.length &lt;= 100 0 &lt;= ri &lt; m 0 &lt;= ci &lt; n &nbsp; Follow up: Could you solve this in O(n + m + indices.length) time with only O(n + m) extra space?"
    },
    {
      "number": 1253,
      "title": "Reconstruct a 2-Row Binary Matrix",
      "titleSlug": "reconstruct-a-2-row-binary-matrix",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Greedy",
        "Matrix"
      ],
      "description": "Given the following details of a matrix with n columns and 2 rows : The matrix is a binary matrix, which means each element in the matrix can be 0 or 1. The sum of elements of the 0-th(upper) row is given as upper. The sum of elements of the 1-st(lower) row is given as lower. The sum of elements in the i-th column(0-indexed) is colsum[i], where colsum is given as an integer array with length n. Your task is to reconstruct the matrix with upper, lower and colsum. Return it as a 2-D integer array. If there are more than one valid solution, any of them will be accepted. If no valid solution exists, return an empty 2-D array. &nbsp; Example 1: Input: upper = 2, lower = 1, colsum = [1,1,1] Output: [[1,1,0],[0,0,1]] Explanation: [[1,0,1],[0,1,0]], and [[0,1,1],[1,0,0]] are also correct answers. Example 2: Input: upper = 2, lower = 3, colsum = [2,2,1,1] Output: [] Example 3: Input: upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1] Output: [[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]] &nbsp; Constraints: 1 &lt;= colsum.length &lt;= 10^5 0 &lt;= upper, lower &lt;= colsum.length 0 &lt;= colsum[i] &lt;= 2"
    },
    {
      "number": 1254,
      "title": "Number of Closed Islands",
      "titleSlug": "number-of-closed-islands",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Matrix"
      ],
      "description": "Given a 2D&nbsp;grid consists of 0s (land)&nbsp;and 1s (water).&nbsp; An island is a maximal 4-directionally connected group of 0s and a closed island&nbsp;is an island totally&nbsp;(all left, top, right, bottom) surrounded by 1s. Return the number of closed islands. &nbsp; Example 1: Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] Output: 2 Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s). Example 2: Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] Output: 1 Example 3: Input: grid = [[1,1,1,1,1,1,1], &nbsp; [1,0,0,0,0,0,1], &nbsp; [1,0,1,1,1,0,1], &nbsp; [1,0,1,0,1,0,1], &nbsp; [1,0,1,1,1,0,1], &nbsp; [1,0,0,0,0,0,1], [1,1,1,1,1,1,1]] Output: 2 &nbsp; Constraints: 1 &lt;= grid.length, grid[0].length &lt;= 100 0 &lt;= grid[i][j] &lt;=1"
    },
    {
      "number": 1255,
      "title": "Maximum Score Words Formed by Letters",
      "titleSlug": "maximum-score-words-formed-by-letters",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "String",
        "Dynamic Programming",
        "Backtracking",
        "Bit Manipulation",
        "Bitmask"
      ],
      "description": "Given a list of words, list of&nbsp; single&nbsp;letters (might be repeating)&nbsp;and score&nbsp;of every character. Return the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two&nbsp;or more times). It is not necessary to use all characters in letters and each letter can only be used once. Score of letters&nbsp;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ... ,&#39;z&#39; is given by&nbsp;score[0], score[1], ... , score[25] respectively. &nbsp; Example 1: Input: words = [&quot;dog&quot;,&quot;cat&quot;,&quot;dad&quot;,&quot;good&quot;], letters = [&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;d&quot;,&quot;g&quot;,&quot;o&quot;,&quot;o&quot;], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0] Output: 23 Explanation: Score a=1, c=9, d=5, g=3, o=2 Given letters, we can form the words &quot;dad&quot; (5+1+5) and &quot;good&quot; (3+2+2+5) with a score of 23. Words &quot;dad&quot; and &quot;dog&quot; only get a score of 21. Example 2: Input: words = [&quot;xxxz&quot;,&quot;ax&quot;,&quot;bx&quot;,&quot;cx&quot;], letters = [&quot;z&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;x&quot;,&quot;x&quot;,&quot;x&quot;], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10] Output: 27 Explanation: Score a=4, b=4, c=4, x=5, z=10 Given letters, we can form the words &quot;ax&quot; (4+5), &quot;bx&quot; (4+5) and &quot;cx&quot; (4+5) with a score of 27. Word &quot;xxxz&quot; only get a score of 25. Example 3: Input: words = [&quot;leetcode&quot;], letters = [&quot;l&quot;,&quot;e&quot;,&quot;t&quot;,&quot;c&quot;,&quot;o&quot;,&quot;d&quot;], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0] Output: 0 Explanation: Letter &quot;e&quot; can only be used once. &nbsp; Constraints: 1 &lt;= words.length &lt;= 14 1 &lt;= words[i].length &lt;= 15 1 &lt;= letters.length &lt;= 100 letters[i].length == 1 score.length ==&nbsp;26 0 &lt;= score[i] &lt;= 10 words[i], letters[i]&nbsp;contains only lower case English letters."
    },
    {
      "number": 1260,
      "title": "Shift 2D Grid",
      "titleSlug": "shift-2d-grid",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Matrix",
        "Simulation"
      ],
      "description": "Given a 2D grid of size m x n&nbsp;and an integer k. You need to shift the grid&nbsp;k times. In one shift operation: Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m&nbsp;- 1][n - 1] moves to grid[0][0]. Return the 2D grid after applying shift operation k times. &nbsp; Example 1: Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Example 2: Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Example 3: Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] &nbsp; Constraints: m ==&nbsp;grid.length n ==&nbsp;grid[i].length 1 &lt;= m &lt;= 50 1 &lt;= n &lt;= 50 -1000 &lt;= grid[i][j] &lt;= 1000 0 &lt;= k &lt;= 100"
    },
    {
      "number": 1261,
      "title": "Find Elements in a Contaminated Binary Tree",
      "titleSlug": "find-elements-in-a-contaminated-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Design",
        "Binary Tree"
      ],
      "description": "Given a binary tree with the following rules: root.val == 0 For any treeNode: If treeNode.val has a value x and treeNode.left != null, then treeNode.left.val == 2 * x + 1 If treeNode.val has a value x and treeNode.right != null, then treeNode.right.val == 2 * x + 2 Now the binary tree is contaminated, which means all treeNode.val have been changed to -1. Implement the FindElements class: FindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it. bool find(int target) Returns true if the target value exists in the recovered binary tree. &nbsp; Example 1: Input [&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;] [[[-1,null,-1]],[1],[2]] Output [null,false,true] Explanation FindElements findElements = new FindElements([-1,null,-1]); findElements.find(1); // return False findElements.find(2); // return True Example 2: Input [&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;] [[[-1,-1,-1,-1,-1]],[1],[3],[5]] Output [null,true,true,false] Explanation FindElements findElements = new FindElements([-1,-1,-1,-1,-1]); findElements.find(1); // return True findElements.find(3); // return True findElements.find(5); // return False Example 3: Input [&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;] [[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]] Output [null,true,false,false,true] Explanation FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]); findElements.find(2); // return True findElements.find(3); // return False findElements.find(4); // return False findElements.find(5); // return True &nbsp; Constraints: TreeNode.val == -1 The height of the binary tree is less than or equal to 20 The total number of nodes is between [1, 104] Total calls of find() is between [1, 104] 0 &lt;= target &lt;= 106"
    },
    {
      "number": 1262,
      "title": "Greatest Sum Divisible by Three",
      "titleSlug": "greatest-sum-divisible-by-three",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Greedy",
        "Sorting"
      ],
      "description": "Given an integer array nums, return the maximum possible sum of elements of the array such that it is divisible by three. &nbsp; Example 1: Input: nums = [3,6,5,1,8] Output: 18 Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3). Example 2: Input: nums = [4] Output: 0 Explanation: Since 4 is not divisible by 3, do not pick any number. Example 3: Input: nums = [1,2,3,4,4] Output: 12 Explanation: Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3). &nbsp; Constraints: 1 &lt;= nums.length &lt;= 4 * 104 1 &lt;= nums[i] &lt;= 104"
    },
    {
      "number": 1263,
      "title": "Minimum Moves to Move a Box to Their Target Location",
      "titleSlug": "minimum-moves-to-move-a-box-to-their-target-location",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Breadth-First Search",
        "Heap (Priority Queue)",
        "Matrix"
      ],
      "description": "A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations. The game is represented by an m x n grid of characters grid where each element is a wall, floor, or box. Your task is to move the box &#39;B&#39; to the target position &#39;T&#39; under the following rules: The character &#39;S&#39; represents the player. The player can move up, down, left, right in grid if it is a floor (empty cell). The character &#39;.&#39; represents the floor which means a free cell to walk. The character&nbsp;&#39;#&#39;&nbsp;represents the wall which means an obstacle (impossible to walk there). There is only one box &#39;B&#39; and one target cell &#39;T&#39; in the grid. The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push. The player cannot walk through the box. Return the minimum number of pushes to move the box to the target. If there is no way to reach the target, return -1. &nbsp; Example 1: Input: grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;T&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]] Output: 3 Explanation: We return only the number of times the box is pushed. Example 2: Input: grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;T&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]] Output: -1 Example 3: Input: grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;T&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]] Output: 5 Explanation: push the box down, left, left, up and up. &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 20 grid contains only characters &#39;.&#39;, &#39;#&#39;, &#39;S&#39;, &#39;T&#39;, or &#39;B&#39;. There is only one character &#39;S&#39;, &#39;B&#39;, and &#39;T&#39; in the grid."
    },
    {
      "number": 1266,
      "title": "Minimum Time Visiting All Points",
      "titleSlug": "minimum-time-visiting-all-points",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math",
        "Geometry"
      ],
      "description": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points. You can move according to these rules: In 1 second, you can either: move vertically by one&nbsp;unit, move horizontally by one unit, or move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second). You have to visit the points in the same order as they appear in the array. You are allowed to pass through points that appear later in the order, but these do not count as visits. &nbsp; Example 1: Input: points = [[1,1],[3,4],[-1,0]] Output: 7 Explanation: One optimal path is [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0] Time from [1,1] to [3,4] = 3 seconds Time from [3,4] to [-1,0] = 4 seconds Total time = 7 seconds Example 2: Input: points = [[3,2],[-2,2]] Output: 5 &nbsp; Constraints: points.length == n 1 &lt;= n&nbsp;&lt;= 100 points[i].length == 2 -1000&nbsp;&lt;= points[i][0], points[i][1]&nbsp;&lt;= 1000"
    },
    {
      "number": 1267,
      "title": "Count Servers that Communicate",
      "titleSlug": "count-servers-that-communicate",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Matrix",
        "Counting"
      ],
      "description": "You are given a map of a server center, represented as a m * n integer matrix&nbsp;grid, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column. Return the number of servers&nbsp;that communicate with any other server. &nbsp; Example 1: Input: grid = [[1,0],[0,1]] Output: 0 Explanation:&nbsp;No servers can communicate with others. Example 2: Input: grid = [[1,0],[1,1]] Output: 3 Explanation:&nbsp;All three servers can communicate with at least one other server. Example 3: Input: grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]] Output: 4 Explanation:&nbsp;The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can&#39;t communicate with any other server. &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m &lt;= 250 1 &lt;= n &lt;= 250 grid[i][j] == 0 or 1"
    },
    {
      "number": 1268,
      "title": "Search Suggestions System",
      "titleSlug": "search-suggestions-system",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "String",
        "Binary Search",
        "Trie",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "You are given an array of strings products and a string searchWord. Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products. Return a list of lists of the suggested products after each character of searchWord is typed. &nbsp; Example 1: Input: products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot; Output: [[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;]] Explanation: products sorted lexicographically = [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;]. After typing m and mo all products match and we show user [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;]. After typing mou, mous and mouse the system suggests [&quot;mouse&quot;,&quot;mousepad&quot;]. Example 2: Input: products = [&quot;havana&quot;], searchWord = &quot;havana&quot; Output: [[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;]] Explanation: The only word &quot;havana&quot; will be always suggested while typing the search word. &nbsp; Constraints: 1 &lt;= products.length &lt;= 1000 1 &lt;= products[i].length &lt;= 3000 1 &lt;= sum(products[i].length) &lt;= 2 * 104 All the strings of products are unique. products[i] consists of lowercase English letters. 1 &lt;= searchWord.length &lt;= 1000 searchWord consists of lowercase English letters."
    },
    {
      "number": 1269,
      "title": "Number of Ways to Stay in the Same Place After Some Steps",
      "titleSlug": "number-of-ways-to-stay-in-the-same-place-after-some-steps",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time). Given two integers steps and arrLen, return the number of ways such that your pointer is still at index 0 after exactly steps steps. Since the answer may be too large, return it modulo 109 + 7. &nbsp; Example 1: Input: steps = 3, arrLen = 2 Output: 4 Explanation: There are 4 differents ways to stay at index 0 after 3 steps. Right, Left, Stay Stay, Right, Left Right, Stay, Left Stay, Stay, Stay Example 2: Input: steps = 2, arrLen = 4 Output: 2 Explanation: There are 2 differents ways to stay at index 0 after 2 steps Right, Left Stay, Stay Example 3: Input: steps = 4, arrLen = 2 Output: 8 &nbsp; Constraints: 1 &lt;= steps &lt;= 500 1 &lt;= arrLen &lt;= 106"
    },
    {
      "number": 1275,
      "title": "Find Winner on a Tic Tac Toe Game",
      "titleSlug": "find-winner-on-a-tic-tac-toe-game",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Matrix",
        "Simulation"
      ],
      "description": "Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are: Players take turns placing characters into empty squares &#39; &#39;. The first player A always places &#39;X&#39; characters, while the second player B always places &#39;O&#39; characters. &#39;X&#39; and &#39;O&#39; characters are always placed into empty squares, never on filled ones. The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal. The game also ends if all squares are non-empty. No more moves can be played if the game is over. Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B). In case the game ends in a draw return &quot;Draw&quot;. If there are still movements to play return &quot;Pending&quot;. You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first. &nbsp; Example 1: Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]] Output: &quot;A&quot; Explanation: A wins, they always play first. Example 2: Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]] Output: &quot;B&quot; Explanation: B wins. Example 3: Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]] Output: &quot;Draw&quot; Explanation: The game ends in a draw since there are no moves to make. &nbsp; Constraints: 1 &lt;= moves.length &lt;= 9 moves[i].length == 2 0 &lt;= rowi, coli &lt;= 2 There are no repeated elements on moves. moves follow the rules of tic tac toe."
    },
    {
      "number": 1276,
      "title": "Number of Burgers with No Waste of Ingredients",
      "titleSlug": "number-of-burgers-with-no-waste-of-ingredients",
      "difficulty": "Medium",
      "tags": [
        "Math"
      ],
      "description": "Given two integers tomatoSlices and cheeseSlices. The ingredients of different burgers are as follows: Jumbo Burger: 4 tomato slices and 1 cheese slice. Small Burger: 2 Tomato slices and 1 cheese slice. Return [total_jumbo, total_small] so that the number of remaining tomatoSlices equal to 0 and the number of remaining cheeseSlices equal to 0. If it is not possible to make the remaining tomatoSlices and cheeseSlices equal to 0 return []. &nbsp; Example 1: Input: tomatoSlices = 16, cheeseSlices = 7 Output: [1,6] Explantion: To make one jumbo burger and 6 small burgers we need 4*1 + 2*6 = 16 tomato and 1 + 6 = 7 cheese. There will be no remaining ingredients. Example 2: Input: tomatoSlices = 17, cheeseSlices = 4 Output: [] Explantion: There will be no way to use all ingredients to make small and jumbo burgers. Example 3: Input: tomatoSlices = 4, cheeseSlices = 17 Output: [] Explantion: Making 1 jumbo burger there will be 16 cheese remaining and making 2 small burgers there will be 15 cheese remaining. &nbsp; Constraints: 0 &lt;= tomatoSlices, cheeseSlices &lt;= 107"
    },
    {
      "number": 1277,
      "title": "Count Square Submatrices with All Ones",
      "titleSlug": "count-square-submatrices-with-all-ones",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Matrix"
      ],
      "description": "Given a m * n matrix of ones and zeros, return how many square submatrices have all ones. &nbsp; Example 1: Input: matrix = [ &nbsp; [0,1,1,1], &nbsp; [1,1,1,1], &nbsp; [0,1,1,1] ] Output: 15 Explanation: There are 10 squares of side 1. There are 4 squares of side 2. There is 1 square of side 3. Total number of squares = 10 + 4 + 1 = 15. Example 2: Input: matrix = [ [1,0,1], [1,1,0], [1,1,0] ] Output: 7 Explanation: There are 6 squares of side 1. There is 1 square of side 2. Total number of squares = 6 + 1 = 7. &nbsp; Constraints: 1 &lt;= arr.length&nbsp;&lt;= 300 1 &lt;= arr[0].length&nbsp;&lt;= 300 0 &lt;= arr[i][j] &lt;= 1"
    },
    {
      "number": 1278,
      "title": "Palindrome Partitioning III",
      "titleSlug": "palindrome-partitioning-iii",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "You are given a string s containing lowercase letters and an integer k. You need to : First, change some characters of s to other lowercase English letters. Then divide s into k non-empty disjoint substrings such that each substring is a palindrome. Return the minimal number of characters that you need to change to divide the string. &nbsp; Example 1: Input: s = &quot;abc&quot;, k = 2 Output: 1 Explanation:&nbsp;You can split the string into &quot;ab&quot; and &quot;c&quot;, and change 1 character in &quot;ab&quot; to make it palindrome. Example 2: Input: s = &quot;aabbc&quot;, k = 3 Output: 0 Explanation:&nbsp;You can split the string into &quot;aa&quot;, &quot;bb&quot; and &quot;c&quot;, all of them are palindrome. Example 3: Input: s = &quot;leetcode&quot;, k = 8 Output: 0 &nbsp; Constraints: 1 &lt;= k &lt;= s.length &lt;= 100. s only contains lowercase English letters."
    },
    {
      "number": 1280,
      "title": "Students and Examinations",
      "titleSlug": "students-and-examinations",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Students +---------------+---------+ | Column Name | Type | +---------------+---------+ | student_id | int | | student_name | varchar | +---------------+---------+ student_id is the primary key (column with unique values) for this table. Each row of this table contains the ID and the name of one student in the school. &nbsp; Table: Subjects +--------------+---------+ | Column Name | Type | +--------------+---------+ | subject_name | varchar | +--------------+---------+ subject_name is the primary key (column with unique values) for this table. Each row of this table contains the name of one subject in the school. &nbsp; Table: Examinations +--------------+---------+ | Column Name | Type | +--------------+---------+ | student_id | int | | subject_name | varchar | +--------------+---------+ There is no primary key (column with unique values) for this table. It may contain duplicates. Each student from the Students table takes every course from the Subjects table. Each row of this table indicates that a student with ID student_id attended the exam of subject_name. &nbsp; Write a solution to find the number of times each student attended each exam. Return the result table ordered by student_id and subject_name. The result format is in the following example. &nbsp; Example 1: Input: Students table: +------------+--------------+ | student_id | student_name | +------------+--------------+ | 1 | Alice | | 2 | Bob | | 13 | John | | 6 | Alex | +------------+--------------+ Subjects table: +--------------+ | subject_name | +--------------+ | Math | | Physics | | Programming | +--------------+ Examinations table: +------------+--------------+ | student_id | subject_name | +------------+--------------+ | 1 | Math | | 1 | Physics | | 1 | Programming | | 2 | Programming | | 1 | Physics | | 1 | Math | | 13 | Math | | 13 | Programming | | 13 | Physics | | 2 | Math | | 1 | Math | +------------+--------------+ Output: +------------+--------------+--------------+----------------+ | student_id | student_name | subject_name | attended_exams | +------------+--------------+--------------+----------------+ | 1 | Alice | Math | 3 | | 1 | Alice | Physics | 2 | | 1 | Alice | Programming | 1 | | 2 | Bob | Math | 1 | | 2 | Bob | Physics | 0 | | 2 | Bob | Programming | 1 | | 6 | Alex | Math | 0 | | 6 | Alex | Physics | 0 | | 6 | Alex | Programming | 0 | | 13 | John | Math | 1 | | 13 | John | Physics | 1 | | 13 | John | Programming | 1 | +------------+--------------+--------------+----------------+ Explanation: The result table should contain all students and all subjects. Alice attended the Math exam 3 times, the Physics exam 2 times, and the Programming exam 1 time. Bob attended the Math exam 1 time, the Programming exam 1 time, and did not attend the Physics exam. Alex did not attend any exams. John attended the Math exam 1 time, the Physics exam 1 time, and the Programming exam 1 time."
    },
    {
      "number": 1281,
      "title": "Subtract the Product and Sum of Digits of an Integer",
      "titleSlug": "subtract-the-product-and-sum-of-digits-of-an-integer",
      "difficulty": "Easy",
      "tags": [
        "Math"
      ],
      "description": "Given an integer number n, return the difference between the product of its digits and the sum of its digits. &nbsp; Example 1: Input: n = 234 Output: 15 Explanation: Product of digits = 2 * 3 * 4 = 24 Sum of digits = 2 + 3 + 4 = 9 Result = 24 - 9 = 15 Example 2: Input: n = 4421 Output: 21 Explanation: Product of digits = 4 * 4 * 2 * 1 = 32 Sum of digits = 4 + 4 + 2 + 1 = 11 Result = 32 - 11 = 21 &nbsp; Constraints: 1 &lt;= n &lt;= 10^5"
    },
    {
      "number": 1282,
      "title": "Group the People Given the Group Size They Belong To",
      "titleSlug": "group-the-people-given-the-group-size-they-belong-to",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Greedy"
      ],
      "description": "There are n people&nbsp;that are split into some unknown number of groups. Each person is labeled with a&nbsp;unique ID&nbsp;from&nbsp;0&nbsp;to&nbsp;n - 1. You are given an integer array&nbsp;groupSizes, where groupSizes[i]&nbsp;is the size of the group that person&nbsp;i&nbsp;is in. For example, if&nbsp;groupSizes[1] = 3, then&nbsp;person&nbsp;1&nbsp;must be in a&nbsp;group of size&nbsp;3. Return&nbsp;a list of groups&nbsp;such that&nbsp;each person&nbsp;i&nbsp;is in a group of size&nbsp;groupSizes[i]. Each person should&nbsp;appear in&nbsp;exactly one group,&nbsp;and every person must be in a group. If there are&nbsp;multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input. &nbsp; Example 1: Input: groupSizes = [3,3,3,3,3,1,3] Output: [[5],[0,1,2],[3,4,6]] Explanation: The first group is [5]. The size is 1, and groupSizes[5] = 1. The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3. The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3. Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]]. Example 2: Input: groupSizes = [2,1,3,3,3,2] Output: [[1],[0,5],[2,3,4]] &nbsp; Constraints: groupSizes.length == n 1 &lt;= n&nbsp;&lt;= 500 1 &lt;=&nbsp;groupSizes[i] &lt;= n"
    },
    {
      "number": 1283,
      "title": "Find the Smallest Divisor Given a Threshold",
      "titleSlug": "find-the-smallest-divisor-given-a-threshold",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search"
      ],
      "description": "Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division&#39;s result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold. Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). The test cases are generated so&nbsp;that there will be an answer. &nbsp; Example 1: Input: nums = [1,2,5,9], threshold = 6 Output: 5 Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). Example 2: Input: nums = [44,22,33,11,1], threshold = 5 Output: 44 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 5 * 104 1 &lt;= nums[i] &lt;= 106 nums.length &lt;= threshold &lt;= 106"
    },
    {
      "number": 1284,
      "title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix",
      "titleSlug": "minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Bit Manipulation",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "Given a m x n binary matrix mat. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighbors if they share one edge. Return the minimum number of steps required to convert mat to a zero matrix or -1 if you cannot. A binary matrix is a matrix with all cells equal to 0 or 1 only. A zero matrix is a matrix with all cells equal to 0. &nbsp; Example 1: Input: mat = [[0,0],[0,1]] Output: 3 Explanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown. Example 2: Input: mat = [[0]] Output: 0 Explanation: Given matrix is a zero matrix. We do not need to change it. Example 3: Input: mat = [[1,0,0],[1,0,0]] Output: -1 Explanation: Given matrix cannot be a zero matrix. &nbsp; Constraints: m == mat.length n == mat[i].length 1 &lt;= m, n &lt;= 3 mat[i][j] is either 0 or 1."
    },
    {
      "number": 1286,
      "title": "Iterator for Combination",
      "titleSlug": "iterator-for-combination",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Backtracking",
        "Design",
        "Iterator"
      ],
      "description": "Design the CombinationIterator class: CombinationIterator(string characters, int combinationLength) Initializes the object with a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments. next() Returns the next combination of length combinationLength in lexicographical order. hasNext() Returns true if and only if there exists a next combination. &nbsp; Example 1: Input [&quot;CombinationIterator&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;] [[&quot;abc&quot;, 2], [], [], [], [], [], []] Output [null, &quot;ab&quot;, true, &quot;ac&quot;, true, &quot;bc&quot;, false] Explanation CombinationIterator itr = new CombinationIterator(&quot;abc&quot;, 2); itr.next(); // return &quot;ab&quot; itr.hasNext(); // return True itr.next(); // return &quot;ac&quot; itr.hasNext(); // return True itr.next(); // return &quot;bc&quot; itr.hasNext(); // return False &nbsp; Constraints: 1 &lt;= combinationLength &lt;= characters.length &lt;= 15 All the characters of characters are unique. At most 104 calls will be made to next and hasNext. It is guaranteed that all calls of the function next are valid."
    },
    {
      "number": 1287,
      "title": "Element Appearing More Than 25% In Sorted Array",
      "titleSlug": "element-appearing-more-than-25-in-sorted-array",
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "description": "Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer. &nbsp; Example 1: Input: arr = [1,2,2,6,6,6,6,7,10] Output: 6 Example 2: Input: arr = [1,1] Output: 1 &nbsp; Constraints: 1 &lt;= arr.length &lt;= 104 0 &lt;= arr[i] &lt;= 105"
    },
    {
      "number": 1288,
      "title": "Remove Covered Intervals",
      "titleSlug": "remove-covered-intervals",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Sorting"
      ],
      "description": "Given an array intervals where intervals[i] = [li, ri] represent the interval [li, ri), remove all intervals that are covered by another interval in the list. The interval [a, b) is covered by the interval [c, d) if and only if c &lt;= a and b &lt;= d. Return the number of remaining intervals. &nbsp; Example 1: Input: intervals = [[1,4],[3,6],[2,8]] Output: 2 Explanation: Interval [3,6] is covered by [2,8], therefore it is removed. Example 2: Input: intervals = [[1,4],[2,3]] Output: 1 &nbsp; Constraints: 1 &lt;= intervals.length &lt;= 1000 intervals[i].length == 2 0 &lt;= li &lt; ri &lt;= 105 All the given intervals are unique."
    },
    {
      "number": 1289,
      "title": "Minimum Falling Path Sum II",
      "titleSlug": "minimum-falling-path-sum-ii",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Matrix"
      ],
      "description": "Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts. A falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column. &nbsp; Example 1: Input: grid = [[1,2,3],[4,5,6],[7,8,9]] Output: 13 Explanation: The possible falling paths are: [1,5,9], [1,5,7], [1,6,7], [1,6,8], [2,4,8], [2,4,9], [2,6,7], [2,6,8], [3,4,8], [3,4,9], [3,5,7], [3,5,9] The falling path with the smallest sum is&nbsp;[1,5,7], so the answer is&nbsp;13. Example 2: Input: grid = [[7]] Output: 7 &nbsp; Constraints: n == grid.length == grid[i].length 1 &lt;= n &lt;= 200 -99 &lt;= grid[i][j] &lt;= 99"
    },
    {
      "number": 1290,
      "title": "Convert Binary Number in a Linked List to Integer",
      "titleSlug": "convert-binary-number-in-a-linked-list-to-integer",
      "difficulty": "Easy",
      "tags": [
        "Linked List",
        "Math"
      ],
      "description": "Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number. Return the decimal value of the number in the linked list. The most significant bit is at the head of the linked list. &nbsp; Example 1: Input: head = [1,0,1] Output: 5 Explanation: (101) in base 2 = (5) in base 10 Example 2: Input: head = [0] Output: 0 &nbsp; Constraints: The Linked List is not empty. Number of nodes will not exceed 30. Each node&#39;s value is either 0 or 1."
    },
    {
      "number": 1291,
      "title": "Sequential Digits",
      "titleSlug": "sequential-digits",
      "difficulty": "Medium",
      "tags": [
        "Enumeration"
      ],
      "description": "An&nbsp;integer has sequential digits if and only if each digit in the number is one more than the previous digit. Return a sorted list of all the integers&nbsp;in the range [low, high]&nbsp;inclusive that have sequential digits. &nbsp; Example 1: Input: low = 100, high = 300 Output: [123,234] Example 2: Input: low = 1000, high = 13000 Output: [1234,2345,3456,4567,5678,6789,12345] &nbsp; Constraints: 10 &lt;= low &lt;= high &lt;= 10^9"
    },
    {
      "number": 1292,
      "title": "Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
      "titleSlug": "maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search",
        "Matrix",
        "Prefix Sum"
      ],
      "description": "Given a m x n matrix mat and an integer threshold, return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square. &nbsp; Example 1: Input: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4 Output: 2 Explanation: The maximum side length of square with sum less than 4 is 2 as shown. Example 2: Input: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1 Output: 0 &nbsp; Constraints: m == mat.length n == mat[i].length 1 &lt;= m, n &lt;= 300 0 &lt;= mat[i][j] &lt;= 104 0 &lt;= threshold &lt;= 105"
    },
    {
      "number": 1293,
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Breadth-First Search",
        "Matrix"
      ],
      "description": "You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from and to an empty cell in one step. Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1) given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1. &nbsp; Example 1: Input: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1 Output: 6 Explanation: The shortest path without eliminating any obstacle is 10. The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; (3,2) -&gt; (4,2). Example 2: Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1 Output: -1 Explanation: We need to eliminate at least two obstacles to find such a walk. &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 40 1 &lt;= k &lt;= m * n grid[i][j] is either 0 or 1. grid[0][0] == grid[m - 1][n - 1] == 0"
    },
    {
      "number": 1295,
      "title": "Find Numbers with Even Number of Digits",
      "titleSlug": "find-numbers-with-even-number-of-digits",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math"
      ],
      "description": "Given an array nums of integers, return how many of them contain an even number of digits. &nbsp; Example 1: Input: nums = [12,345,2,6,7896] Output: 2 Explanation: 12 contains 2 digits (even number of digits).&nbsp; 345 contains 3 digits (odd number of digits).&nbsp; 2 contains 1 digit (odd number of digits).&nbsp; 6 contains 1 digit (odd number of digits).&nbsp; 7896 contains 4 digits (even number of digits).&nbsp; Therefore only 12 and 7896 contain an even number of digits. Example 2: Input: nums = [555,901,482,1771] Output: 1 Explanation: Only 1771 contains an even number of digits. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 105"
    },
    {
      "number": 1296,
      "title": "Divide Array in Sets of K Consecutive Numbers",
      "titleSlug": "divide-array-in-sets-of-k-consecutive-numbers",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Greedy",
        "Sorting"
      ],
      "description": "Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers. Return true if it is possible. Otherwise, return false. &nbsp; Example 1: Input: nums = [1,2,3,3,4,4,5,6], k = 4 Output: true Explanation: Array can be divided into [1,2,3,4] and [3,4,5,6]. Example 2: Input: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3 Output: true Explanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11]. Example 3: Input: nums = [1,2,3,4], k = 3 Output: false Explanation: Each array should be divided in subarrays of size 3. &nbsp; Constraints: 1 &lt;= k &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 109 &nbsp; Note: This question is the same as&nbsp;846:&nbsp;https://leetcode.com/problems/hand-of-straights/"
    },
    {
      "number": 1297,
      "title": "Maximum Number of Occurrences of a Substring",
      "titleSlug": "maximum-number-of-occurrences-of-a-substring",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Sliding Window"
      ],
      "description": "Given a string s, return the maximum number of occurrences of any substring under the following rules: The number of unique characters in the substring must be less than or equal to maxLetters. The substring size must be between minSize and maxSize inclusive. &nbsp; Example 1: Input: s = &quot;aababcaab&quot;, maxLetters = 2, minSize = 3, maxSize = 4 Output: 2 Explanation: Substring &quot;aab&quot; has 2 occurrences in the original string. It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize). Example 2: Input: s = &quot;aaaa&quot;, maxLetters = 1, minSize = 3, maxSize = 3 Output: 2 Explanation: Substring &quot;aaa&quot; occur 2 times in the string. It can overlap. &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 1 &lt;= maxLetters &lt;= 26 1 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length) s consists of only lowercase English letters."
    },
    {
      "number": 1298,
      "title": "Maximum Candies You Can Get from Boxes",
      "titleSlug": "maximum-candies-you-can-get-from-boxes",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Breadth-First Search",
        "Graph"
      ],
      "description": "You have n boxes labeled from 0 to n - 1. You are given four arrays: status, candies, keys, and containedBoxes where: status[i] is 1 if the ith box is open and 0 if the ith box is closed, candies[i] is the number of candies in the ith box, keys[i] is a list of the labels of the boxes you can open after opening the ith box. containedBoxes[i] is a list of the boxes you found inside the ith box. You are given an integer array initialBoxes that contains the labels of the boxes you initially have. You can take all the candies in any open box and you can use the keys in it to open new boxes and you also can use the boxes you find in it. Return the maximum number of candies you can get following the rules above. &nbsp; Example 1: Input: status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0] Output: 16 Explanation: You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2. Box 1 is closed and you do not have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2. In box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed. Total number of candies collected = 7 + 4 + 5 = 16 candy. Example 2: Input: status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0] Output: 6 Explanation: You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys. The total number of candies will be 6. &nbsp; Constraints: n == status.length == candies.length == keys.length == containedBoxes.length 1 &lt;= n &lt;= 1000 status[i] is either 0 or 1. 1 &lt;= candies[i] &lt;= 1000 0 &lt;= keys[i].length &lt;= n 0 &lt;= keys[i][j] &lt; n All values of keys[i] are unique. 0 &lt;= containedBoxes[i].length &lt;= n 0 &lt;= containedBoxes[i][j] &lt; n All values of containedBoxes[i] are unique. Each box is contained in one box at most. 0 &lt;= initialBoxes.length &lt;= n 0 &lt;= initialBoxes[i] &lt; n"
    },
    {
      "number": 1299,
      "title": "Replace Elements with Greatest Element on Right Side",
      "titleSlug": "replace-elements-with-greatest-element-on-right-side",
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "description": "Given an array arr,&nbsp;replace every element in that array with the greatest element among the elements to its&nbsp;right, and replace the last element with -1. After doing so, return the array. &nbsp; Example 1: Input: arr = [17,18,5,4,6,1] Output: [18,6,6,6,1,-1] Explanation: - index 0 --&gt; the greatest element to the right of index 0 is index 1 (18). - index 1 --&gt; the greatest element to the right of index 1 is index 4 (6). - index 2 --&gt; the greatest element to the right of index 2 is index 4 (6). - index 3 --&gt; the greatest element to the right of index 3 is index 4 (6). - index 4 --&gt; the greatest element to the right of index 4 is index 5 (1). - index 5 --&gt; there are no elements to the right of index 5, so we put -1. Example 2: Input: arr = [400] Output: [-1] Explanation: There are no elements to the right of index 0. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 104 1 &lt;= arr[i] &lt;= 105"
    },
    {
      "number": 1300,
      "title": "Sum of Mutated Array Closest to Target",
      "titleSlug": "sum-of-mutated-array-closest-to-target",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search",
        "Sorting"
      ],
      "description": "Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target. In case of a tie, return the minimum such integer. Notice that the answer is not neccesarilly a number from arr. &nbsp; Example 1: Input: arr = [4,9,3], target = 10 Output: 3 Explanation: When using 3 arr converts to [3, 3, 3] which sums 9 and that&#39;s the optimal answer. Example 2: Input: arr = [2,3,5], target = 10 Output: 5 Example 3: Input: arr = [60864,25176,27249,21296,20204], target = 56803 Output: 11361 &nbsp; Constraints: 1 &lt;= arr.length &lt;= 104 1 &lt;= arr[i], target &lt;= 105"
    },
    {
      "number": 1301,
      "title": "Number of Paths with Max Score",
      "titleSlug": "number-of-paths-with-max-score",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Matrix"
      ],
      "description": "You are given a square board&nbsp;of characters. You can move on the board starting at the bottom right square marked with the character&nbsp;&#39;S&#39;. You need&nbsp;to reach the top left square marked with the character &#39;E&#39;. The rest of the squares are labeled either with a numeric character&nbsp;1, 2, ..., 9 or with an obstacle &#39;X&#39;. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there. Return a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, taken modulo 10^9 + 7. In case there is no path, return&nbsp;[0, 0]. &nbsp; Example 1: Input: board = [\"E23\",\"2X2\",\"12S\"] Output: [7,1] Example 2: Input: board = [\"E12\",\"1X1\",\"21S\"] Output: [4,2] Example 3: Input: board = [\"E11\",\"XXX\",\"11S\"] Output: [0,0] &nbsp; Constraints: 2 &lt;= board.length == board[i].length &lt;= 100"
    },
    {
      "number": 1302,
      "title": "Deepest Leaves Sum",
      "titleSlug": "deepest-leaves-sum",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return the sum of values of its deepest leaves. &nbsp; Example 1: Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8] Output: 15 Example 2: Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5] Output: 19 &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. 1 &lt;= Node.val &lt;= 100"
    },
    {
      "number": 1304,
      "title": "Find N Unique Integers Sum up to Zero",
      "titleSlug": "find-n-unique-integers-sum-up-to-zero",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Math"
      ],
      "description": "Given an integer n, return any array containing n unique integers such that they add up to 0. &nbsp; Example 1: Input: n = 5 Output: [-7,-1,1,3,4] Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4]. Example 2: Input: n = 3 Output: [-1,0,1] Example 3: Input: n = 1 Output: [0] &nbsp; Constraints: 1 &lt;= n &lt;= 1000"
    },
    {
      "number": 1305,
      "title": "All Elements in Two Binary Search Trees",
      "titleSlug": "all-elements-in-two-binary-search-trees",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Search Tree",
        "Sorting",
        "Binary Tree"
      ],
      "description": "Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order. &nbsp; Example 1: Input: root1 = [2,1,4], root2 = [1,0,3] Output: [0,1,1,2,3,4] Example 2: Input: root1 = [1,null,8], root2 = [8,1] Output: [1,1,8,8] &nbsp; Constraints: The number of nodes in each tree is in the range [0, 5000]. -105 &lt;= Node.val &lt;= 105"
    },
    {
      "number": 1306,
      "title": "Jump Game III",
      "titleSlug": "jump-game-iii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Depth-First Search",
        "Breadth-First Search"
      ],
      "description": "Given an array of non-negative integers arr, you are initially positioned at start&nbsp;index of the array. When you are at index i, you can jump&nbsp;to i + arr[i] or i - arr[i], check if you can reach&nbsp;any index with value 0. Notice that you can not jump outside of the array at any time. &nbsp; Example 1: Input: arr = [4,2,3,0,3,1,2], start = 5 Output: true Explanation: All possible ways to reach at index 3 with value 0 are: index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3 Example 2: Input: arr = [4,2,3,0,3,1,2], start = 0 Output: true Explanation: One possible way to reach at index 3 with value 0 is: index 0 -&gt; index 4 -&gt; index 1 -&gt; index 3 Example 3: Input: arr = [3,0,2,1,2], start = 2 Output: false Explanation: There is no way to reach at index 1 with value 0. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 5 * 104 0 &lt;= arr[i] &lt;&nbsp;arr.length 0 &lt;= start &lt; arr.length"
    },
    {
      "number": 1307,
      "title": "Verbal Arithmetic Puzzle",
      "titleSlug": "verbal-arithmetic-puzzle",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "String",
        "Backtracking"
      ],
      "description": "Given an equation, represented by words on the left side and the result on the right side. You need to check if the equation is solvable under the following rules: Each character is decoded as one digit (0 - 9). No two characters can map to the same digit. Each words[i] and result are decoded as one number without leading zeros. Sum of numbers on the left side (words) will equal to the number on the right side (result). Return true if the equation is solvable, otherwise return false. &nbsp; Example 1: Input: words = [&quot;SEND&quot;,&quot;MORE&quot;], result = &quot;MONEY&quot; Output: true Explanation: Map &#39;S&#39;-&gt; 9, &#39;E&#39;-&gt;5, &#39;N&#39;-&gt;6, &#39;D&#39;-&gt;7, &#39;M&#39;-&gt;1, &#39;O&#39;-&gt;0, &#39;R&#39;-&gt;8, &#39;Y&#39;-&gt;&#39;2&#39; Such that: &quot;SEND&quot; + &quot;MORE&quot; = &quot;MONEY&quot; , 9567 + 1085 = 10652 Example 2: Input: words = [&quot;SIX&quot;,&quot;SEVEN&quot;,&quot;SEVEN&quot;], result = &quot;TWENTY&quot; Output: true Explanation: Map &#39;S&#39;-&gt; 6, &#39;I&#39;-&gt;5, &#39;X&#39;-&gt;0, &#39;E&#39;-&gt;8, &#39;V&#39;-&gt;7, &#39;N&#39;-&gt;2, &#39;T&#39;-&gt;1, &#39;W&#39;-&gt;&#39;3&#39;, &#39;Y&#39;-&gt;4 Such that: &quot;SIX&quot; + &quot;SEVEN&quot; + &quot;SEVEN&quot; = &quot;TWENTY&quot; , 650 + 68782 + 68782 = 138214 Example 3: Input: words = [&quot;LEET&quot;,&quot;CODE&quot;], result = &quot;POINT&quot; Output: false Explanation: There is no possible mapping to satisfy the equation, so we return false. Note that two different characters cannot map to the same digit. &nbsp; Constraints: 2 &lt;= words.length &lt;= 5 1 &lt;= words[i].length, result.length &lt;= 7 words[i], result contain only uppercase English letters. The number of different characters used in the expression is at most 10."
    },
    {
      "number": 1309,
      "title": "Decrypt String from Alphabet to Integer Mapping",
      "titleSlug": "decrypt-string-from-alphabet-to-integer-mapping",
      "difficulty": "Easy",
      "tags": [
        "String"
      ],
      "description": "You are given a string s formed by digits and &#39;#&#39;. We want to map s to English lowercase characters as follows: Characters (&#39;a&#39; to &#39;i&#39;) are represented by (&#39;1&#39; to &#39;9&#39;) respectively. Characters (&#39;j&#39; to &#39;z&#39;) are represented by (&#39;10#&#39; to &#39;26#&#39;) respectively. Return the string formed after mapping. The test cases are generated so that a unique mapping will always exist. &nbsp; Example 1: Input: s = &quot;10#11#12&quot; Output: &quot;jkab&quot; Explanation: &quot;j&quot; -&gt; &quot;10#&quot; , &quot;k&quot; -&gt; &quot;11#&quot; , &quot;a&quot; -&gt; &quot;1&quot; , &quot;b&quot; -&gt; &quot;2&quot;. Example 2: Input: s = &quot;1326#&quot; Output: &quot;acz&quot; &nbsp; Constraints: 1 &lt;= s.length &lt;= 1000 s consists of digits and the &#39;#&#39; letter. s will be a valid string such that mapping is always possible."
    },
    {
      "number": 1310,
      "title": "XOR Queries of a Subarray",
      "titleSlug": "xor-queries-of-a-subarray",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Bit Manipulation",
        "Prefix Sum"
      ],
      "description": "You are given an array arr of positive integers. You are also given the array queries where queries[i] = [lefti, righti]. For each query i compute the XOR of elements from lefti to righti (that is, arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti] ). Return an array answer where answer[i] is the answer to the ith query. &nbsp; Example 1: Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] Output: [2,7,14,8] Explanation: The binary representation of the elements in the array are: 1 = 0001 3 = 0011 4 = 0100 8 = 1000 The XOR values for queries are: [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 Example 2: Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]] Output: [8,0,4,4] &nbsp; Constraints: 1 &lt;= arr.length, queries.length &lt;= 3 * 104 1 &lt;= arr[i] &lt;= 109 queries[i].length == 2 0 &lt;= lefti &lt;= righti &lt; arr.length"
    },
    {
      "number": 1311,
      "title": "Get Watched Videos by Your Friends",
      "titleSlug": "get-watched-videos-by-your-friends",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Breadth-First Search",
        "Graph",
        "Sorting"
      ],
      "description": "There are n people, each person has a unique id between 0 and n-1. Given the arrays watchedVideos and friends, where watchedVideos[i] and friends[i] contain the list of watched videos and the list of friends respectively for the person with id = i. Level 1 of videos are all watched videos by your&nbsp;friends, level 2 of videos are all watched videos by the friends of your&nbsp;friends and so on. In general, the level k of videos are all&nbsp;watched videos by people&nbsp;with the shortest path exactly equal&nbsp;to&nbsp;k with you. Given your&nbsp;id and the level of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest.&nbsp; &nbsp; Example 1: Input: watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1 Output: [&quot;B&quot;,&quot;C&quot;] Explanation: You have id = 0 (green color in the figure) and your friends are (yellow color in the figure): Person with id = 1 -&gt; watchedVideos = [&quot;C&quot;]&nbsp; Person with id = 2 -&gt; watchedVideos = [&quot;B&quot;,&quot;C&quot;]&nbsp; The frequencies of watchedVideos by your friends are:&nbsp; B -&gt; 1&nbsp; C -&gt; 2 Example 2: Input: watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2 Output: [&quot;D&quot;] Explanation: You have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure). &nbsp; Constraints: n == watchedVideos.length ==&nbsp;friends.length 2 &lt;= n&nbsp;&lt;= 100 1 &lt;=&nbsp;watchedVideos[i].length &lt;= 100 1 &lt;=&nbsp;watchedVideos[i][j].length &lt;= 8 0 &lt;= friends[i].length &lt; n 0 &lt;= friends[i][j]&nbsp;&lt; n 0 &lt;= id &lt; n 1 &lt;= level &lt; n if&nbsp;friends[i] contains j, then friends[j] contains i"
    },
    {
      "number": 1312,
      "title": "Minimum Insertion Steps to Make a String Palindrome",
      "titleSlug": "minimum-insertion-steps-to-make-a-string-palindrome",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "Given a string s. In one step you can insert any character at any index of the string. Return the minimum number of steps to make s&nbsp;palindrome. A&nbsp;Palindrome String&nbsp;is one that reads the same backward as well as forward. &nbsp; Example 1: Input: s = &quot;zzazz&quot; Output: 0 Explanation: The string &quot;zzazz&quot; is already palindrome we do not need any insertions. Example 2: Input: s = &quot;mbadm&quot; Output: 2 Explanation: String can be &quot;mbdadbm&quot; or &quot;mdbabdm&quot;. Example 3: Input: s = &quot;leetcode&quot; Output: 5 Explanation: Inserting 5 characters the string becomes &quot;leetcodocteel&quot;. &nbsp; Constraints: 1 &lt;= s.length &lt;= 500 s consists of lowercase English letters."
    },
    {
      "number": 1313,
      "title": "Decompress Run-Length Encoded List",
      "titleSlug": "decompress-run-length-encoded-list",
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "description": "We are given a list nums of integers representing a list compressed with run-length encoding. Consider each adjacent pair&nbsp;of elements [freq, val] = [nums[2*i], nums[2*i+1]]&nbsp;(with i &gt;= 0).&nbsp; For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list. Return the decompressed list. &nbsp; Example 1: Input: nums = [1,2,3,4] Output: [2,4,4,4] Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2]. The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4]. At the end the concatenation [2] + [4,4,4] is [2,4,4,4]. Example 2: Input: nums = [1,1,2,3] Output: [1,3,3] &nbsp; Constraints: 2 &lt;= nums.length &lt;= 100 nums.length % 2 == 0 1 &lt;= nums[i] &lt;= 100"
    },
    {
      "number": 1314,
      "title": "Matrix Block Sum",
      "titleSlug": "matrix-block-sum",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Matrix",
        "Prefix Sum"
      ],
      "description": "Given a m x n matrix mat and an integer k, return a matrix answer where each answer[i][j] is the sum of all elements mat[r][c] for: i - k &lt;= r &lt;= i + k, j - k &lt;= c &lt;= j + k, and (r, c) is a valid position in the matrix. &nbsp; Example 1: Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[12,21,16],[27,45,33],[24,39,28]] Example 2: Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2 Output: [[45,45,45],[45,45,45],[45,45,45]] &nbsp; Constraints: m ==&nbsp;mat.length n ==&nbsp;mat[i].length 1 &lt;= m, n, k &lt;= 100 1 &lt;= mat[i][j] &lt;= 100"
    },
    {
      "number": 1315,
      "title": "Sum of Nodes with Even-Valued Grandparent",
      "titleSlug": "sum-of-nodes-with-even-valued-grandparent",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0. A grandparent of a node is the parent of its parent if it exists. &nbsp; Example 1: Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5] Output: 18 Explanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents. Example 2: Input: root = [1] Output: 0 &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. 1 &lt;= Node.val &lt;= 100"
    },
    {
      "number": 1316,
      "title": "Distinct Echo Substrings",
      "titleSlug": "distinct-echo-substrings",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Trie",
        "Rolling Hash",
        "Hash Function"
      ],
      "description": "Return the number of distinct non-empty substrings of text&nbsp;that can be written as the concatenation of some string with itself (i.e. it can be written as a + a&nbsp;where a is some string). &nbsp; Example 1: Input: text = &quot;abcabcabc&quot; Output: 3 Explanation: The 3 substrings are &quot;abcabc&quot;, &quot;bcabca&quot; and &quot;cabcab&quot;. Example 2: Input: text = &quot;leetcodeleetcode&quot; Output: 2 Explanation: The 2 substrings are &quot;ee&quot; and &quot;leetcodeleetcode&quot;. &nbsp; Constraints: 1 &lt;= text.length &lt;= 2000 text&nbsp;has only lowercase English letters."
    },
    {
      "number": 1317,
      "title": "Convert Integer to the Sum of Two No-Zero Integers",
      "titleSlug": "convert-integer-to-the-sum-of-two-no-zero-integers",
      "difficulty": "Easy",
      "tags": [
        "Math"
      ],
      "description": "No-Zero integer is a positive integer that does not contain any 0 in its decimal representation. Given an integer n, return a list of two integers [a, b] where: a and b are No-Zero integers. a + b = n The test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them. &nbsp; Example 1: Input: n = 2 Output: [1,1] Explanation: Let a = 1 and b = 1. Both a and b are no-zero integers, and a + b = 2 = n. Example 2: Input: n = 11 Output: [2,9] Explanation: Let a = 2 and b = 9. Both a and b are no-zero integers, and a + b = 11 = n. Note that there are other valid answers as [8, 3] that can be accepted. &nbsp; Constraints: 2 &lt;= n &lt;= 104"
    },
    {
      "number": 1318,
      "title": "Minimum Flips to Make a OR b Equal to c",
      "titleSlug": "minimum-flips-to-make-a-or-b-equal-to-c",
      "difficulty": "Medium",
      "tags": [
        "Bit Manipulation"
      ],
      "description": "Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make (&nbsp;a OR b == c&nbsp;). (bitwise OR operation). Flip operation&nbsp;consists of change&nbsp;any&nbsp;single bit 1 to 0 or change the bit 0 to 1&nbsp;in their binary representation. &nbsp; Example 1: Input: a = 2, b = 6, c = 5 Output: 3 Explanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c) Example 2: Input: a = 4, b = 2, c = 7 Output: 1 Example 3: Input: a = 1, b = 2, c = 3 Output: 0 &nbsp; Constraints: 1 &lt;= a &lt;= 10^9 1 &lt;= b&nbsp;&lt;= 10^9 1 &lt;= c&nbsp;&lt;= 10^9"
    },
    {
      "number": 1319,
      "title": "Number of Operations to Make Network Connected",
      "titleSlug": "number-of-operations-to-make-network-connected",
      "difficulty": "Medium",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Graph"
      ],
      "description": "There are n computers numbered from 0 to n - 1 connected by ethernet cables connections forming a network where connections[i] = [ai, bi] represents a connection between computers ai and bi. Any computer can reach any other computer directly or indirectly through the network. You are given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected. Return the minimum number of times you need to do this in order to make all the computers connected. If it is not possible, return -1. &nbsp; Example 1: Input: n = 4, connections = [[0,1],[0,2],[1,2]] Output: 1 Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3. Example 2: Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]] Output: 2 Example 3: Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]] Output: -1 Explanation: There are not enough cables. &nbsp; Constraints: 1 &lt;= n &lt;= 105 1 &lt;= connections.length &lt;= min(n * (n - 1) / 2, 105) connections[i].length == 2 0 &lt;= ai, bi &lt; n ai != bi There are no repeated connections. No two computers are connected by more than one cable."
    },
    {
      "number": 1320,
      "title": "Minimum Distance to Type a Word Using Two Fingers",
      "titleSlug": "minimum-distance-to-type-a-word-using-two-fingers",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "You have a keyboard layout as shown above in the X-Y plane, where each English uppercase letter is located at some coordinate. For example, the letter &#39;A&#39; is located at coordinate (0, 0), the letter &#39;B&#39; is located at coordinate (0, 1), the letter &#39;P&#39; is located at coordinate (2, 3) and the letter &#39;Z&#39; is located at coordinate (4, 1). Given the string word, return the minimum total distance to type such string using only two fingers. The distance between coordinates (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2|. Note that the initial positions of your two fingers are considered free so do not count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters. &nbsp; Example 1: Input: word = &quot;CAKE&quot; Output: 3 Explanation: Using two fingers, one optimal way to type &quot;CAKE&quot; is: Finger 1 on letter &#39;C&#39; -&gt; cost = 0 Finger 1 on letter &#39;A&#39; -&gt; cost = Distance from letter &#39;C&#39; to letter &#39;A&#39; = 2 Finger 2 on letter &#39;K&#39; -&gt; cost = 0 Finger 2 on letter &#39;E&#39; -&gt; cost = Distance from letter &#39;K&#39; to letter &#39;E&#39; = 1 Total distance = 3 Example 2: Input: word = &quot;HAPPY&quot; Output: 6 Explanation: Using two fingers, one optimal way to type &quot;HAPPY&quot; is: Finger 1 on letter &#39;H&#39; -&gt; cost = 0 Finger 1 on letter &#39;A&#39; -&gt; cost = Distance from letter &#39;H&#39; to letter &#39;A&#39; = 2 Finger 2 on letter &#39;P&#39; -&gt; cost = 0 Finger 2 on letter &#39;P&#39; -&gt; cost = Distance from letter &#39;P&#39; to letter &#39;P&#39; = 0 Finger 1 on letter &#39;Y&#39; -&gt; cost = Distance from letter &#39;A&#39; to letter &#39;Y&#39; = 4 Total distance = 6 &nbsp; Constraints: 2 &lt;= word.length &lt;= 300 word consists of uppercase English letters."
    },
    {
      "number": 1321,
      "title": "Restaurant Growth",
      "titleSlug": "restaurant-growth",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Customer +---------------+---------+ | Column Name | Type | +---------------+---------+ | customer_id | int | | name | varchar | | visited_on | date | | amount | int | +---------------+---------+ In SQL,(customer_id, visited_on) is the primary key for this table. This table contains data about customer transactions in a restaurant. visited_on is the date on which the customer with ID (customer_id) has visited the restaurant. amount is the total paid by a customer. &nbsp; You are the restaurant owner and you want to analyze a possible expansion (there will be at least one customer every day). Compute the moving average of how much the customer paid in a seven days window (i.e., current day + 6 days before). average_amount should be rounded to two decimal places. Return the result table ordered by visited_on in ascending order. The result format is in the following example. &nbsp; Example 1: Input: Customer table: +-------------+--------------+--------------+-------------+ | customer_id | name | visited_on | amount | +-------------+--------------+--------------+-------------+ | 1 | Jhon | 2019-01-01 | 100 | | 2 | Daniel | 2019-01-02 | 110 | | 3 | Jade | 2019-01-03 | 120 | | 4 | Khaled | 2019-01-04 | 130 | | 5 | Winston | 2019-01-05 | 110 | | 6 | Elvis | 2019-01-06 | 140 | | 7 | Anna | 2019-01-07 | 150 | | 8 | Maria | 2019-01-08 | 80 | | 9 | Jaze | 2019-01-09 | 110 | | 1 | Jhon | 2019-01-10 | 130 | | 3 | Jade | 2019-01-10 | 150 | +-------------+--------------+--------------+-------------+ Output: +--------------+--------------+----------------+ | visited_on | amount | average_amount | +--------------+--------------+----------------+ | 2019-01-07 | 860 | 122.86 | | 2019-01-08 | 840 | 120 | | 2019-01-09 | 840 | 120 | | 2019-01-10 | 1000 | 142.86 | +--------------+--------------+----------------+ Explanation: 1st moving average from 2019-01-01 to 2019-01-07 has an average_amount of (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.86 2nd moving average from 2019-01-02 to 2019-01-08 has an average_amount of (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 120 3rd moving average from 2019-01-03 to 2019-01-09 has an average_amount of (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 120 4th moving average from 2019-01-04 to 2019-01-10 has an average_amount of (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86"
    },
    {
      "number": 1323,
      "title": "Maximum 69 Number",
      "titleSlug": "maximum-69-number",
      "difficulty": "Easy",
      "tags": [
        "Math",
        "Greedy"
      ],
      "description": "You are given a positive integer num consisting only of digits 6 and 9. Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6). &nbsp; Example 1: Input: num = 9669 Output: 9969 Explanation: Changing the first digit results in 6669. Changing the second digit results in 9969. Changing the third digit results in 9699. Changing the fourth digit results in 9666. The maximum number is 9969. Example 2: Input: num = 9996 Output: 9999 Explanation: Changing the last digit 6 to 9 results in the maximum number. Example 3: Input: num = 9999 Output: 9999 Explanation: It is better not to apply any change. &nbsp; Constraints: 1 &lt;= num &lt;= 104 num&nbsp;consists of only 6 and 9 digits."
    },
    {
      "number": 1324,
      "title": "Print Words Vertically",
      "titleSlug": "print-words-vertically",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "String",
        "Simulation"
      ],
      "description": "Given a string s.&nbsp;Return&nbsp;all the words vertically in the same order in which they appear in s. Words are returned as a list of strings, complete with&nbsp;spaces when is necessary. (Trailing spaces are not allowed). Each word would be put on only one column and that in one column there will be only one word. &nbsp; Example 1: Input: s = &quot;HOW ARE YOU&quot; Output: [&quot;HAY&quot;,&quot;ORO&quot;,&quot;WEU&quot;] Explanation: Each word is printed vertically. &quot;HAY&quot; &nbsp;&quot;ORO&quot; &nbsp;&quot;WEU&quot; Example 2: Input: s = &quot;TO BE OR NOT TO BE&quot; Output: [&quot;TBONTB&quot;,&quot;OEROOE&quot;,&quot; T&quot;] Explanation: Trailing spaces is not allowed. &quot;TBONTB&quot; &quot;OEROOE&quot; &quot; T&quot; Example 3: Input: s = &quot;CONTEST IS COMING&quot; Output: [&quot;CIC&quot;,&quot;OSO&quot;,&quot;N M&quot;,&quot;T I&quot;,&quot;E N&quot;,&quot;S G&quot;,&quot;T&quot;] &nbsp; Constraints: 1 &lt;= s.length &lt;= 200 s&nbsp;contains only upper case English letters. It&#39;s guaranteed that there is only one&nbsp;space between 2 words."
    },
    {
      "number": 1325,
      "title": "Delete Leaves With a Given Value",
      "titleSlug": "delete-leaves-with-a-given-value",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given a binary tree root and an integer target, delete all the leaf nodes with value target. Note that once you delete a leaf node with value target, if its parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you cannot). &nbsp; Example 1: Input: root = [1,2,3,2,null,2,4], target = 2 Output: [1,null,3,null,4] Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left). After removing, new nodes become leaf nodes with value (target = 2) (Picture in center). Example 2: Input: root = [1,3,3,3,2], target = 3 Output: [1,3,null,null,2] Example 3: Input: root = [1,2,null,2,null,2], target = 2 Output: [1] Explanation: Leaf nodes in green with value (target = 2) are removed at each step. &nbsp; Constraints: The number of nodes in the tree is in the range [1, 3000]. 1 &lt;= Node.val, target &lt;= 1000"
    },
    {
      "number": 1326,
      "title": "Minimum Number of Taps to Open to Water a Garden",
      "titleSlug": "minimum-number-of-taps-to-open-to-water-a-garden",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Greedy"
      ],
      "description": "There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e., the&nbsp;length of the garden is n). There are n + 1 taps located at points [0, 1, ..., n] in the garden. Given an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open. Return the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1. &nbsp; Example 1: Input: n = 5, ranges = [3,4,1,1,0,0] Output: 1 Explanation: The tap at point 0 can cover the interval [-3,3] The tap at point 1 can cover the interval [-3,5] The tap at point 2 can cover the interval [1,3] The tap at point 3 can cover the interval [2,4] The tap at point 4 can cover the interval [4,4] The tap at point 5 can cover the interval [5,5] Opening Only the second tap will water the whole garden [0,5] Example 2: Input: n = 3, ranges = [0,0,0,0] Output: -1 Explanation: Even if you activate all the four taps you cannot water the whole garden. &nbsp; Constraints: 1 &lt;= n &lt;= 104 ranges.length == n + 1 0 &lt;= ranges[i] &lt;= 100"
    },
    {
      "number": 1327,
      "title": "List the Products Ordered in a Period",
      "titleSlug": "list-the-products-ordered-in-a-period",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Products +------------------+---------+ | Column Name | Type | +------------------+---------+ | product_id | int | | product_name | varchar | | product_category | varchar | +------------------+---------+ product_id is the primary key (column with unique values) for this table. This table contains data about the company&#39;s products. &nbsp; Table: Orders +---------------+---------+ | Column Name | Type | +---------------+---------+ | product_id | int | | order_date | date | | unit | int | +---------------+---------+ This table may have duplicate rows. product_id is a foreign key (reference column) to the Products table. unit is the number of products ordered in order_date. &nbsp; Write a solution to get the names of products that have at least 100 units ordered in February 2020 and their amount. Return the result table in any order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Products table: +-------------+-----------------------+------------------+ | product_id | product_name | product_category | +-------------+-----------------------+------------------+ | 1 | Leetcode Solutions | Book | | 2 | Jewels of Stringology | Book | | 3 | HP | Laptop | | 4 | Lenovo | Laptop | | 5 | Leetcode Kit | T-shirt | +-------------+-----------------------+------------------+ Orders table: +--------------+--------------+----------+ | product_id | order_date | unit | +--------------+--------------+----------+ | 1 | 2020-02-05 | 60 | | 1 | 2020-02-10 | 70 | | 2 | 2020-01-18 | 30 | | 2 | 2020-02-11 | 80 | | 3 | 2020-02-17 | 2 | | 3 | 2020-02-24 | 3 | | 4 | 2020-03-01 | 20 | | 4 | 2020-03-04 | 30 | | 4 | 2020-03-04 | 60 | | 5 | 2020-02-25 | 50 | | 5 | 2020-02-27 | 50 | | 5 | 2020-03-01 | 50 | +--------------+--------------+----------+ Output: +--------------------+---------+ | product_name | unit | +--------------------+---------+ | Leetcode Solutions | 130 | | Leetcode Kit | 100 | +--------------------+---------+ Explanation: Products with product_id = 1 is ordered in February a total of (60 + 70) = 130. Products with product_id = 2 is ordered in February a total of 80. Products with product_id = 3 is ordered in February a total of (2 + 3) = 5. Products with product_id = 4 was not ordered in February 2020. Products with product_id = 5 is ordered in February a total of (50 + 50) = 100."
    },
    {
      "number": 1328,
      "title": "Break a Palindrome",
      "titleSlug": "break-a-palindrome",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Greedy"
      ],
      "description": "Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible. Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string. A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. For example, &quot;abcc&quot; is lexicographically smaller than &quot;abcd&quot; because the first position they differ is at the fourth character, and &#39;c&#39; is smaller than &#39;d&#39;. &nbsp; Example 1: Input: palindrome = &quot;abccba&quot; Output: &quot;aaccba&quot; Explanation: There are many ways to make &quot;abccba&quot; not a palindrome, such as &quot;zbccba&quot;, &quot;aaccba&quot;, and &quot;abacba&quot;. Of all the ways, &quot;aaccba&quot; is the lexicographically smallest. Example 2: Input: palindrome = &quot;a&quot; Output: &quot;&quot; Explanation: There is no way to replace a single character to make &quot;a&quot; not a palindrome, so return an empty string. &nbsp; Constraints: 1 &lt;= palindrome.length &lt;= 1000 palindrome consists of only lowercase English letters."
    },
    {
      "number": 1329,
      "title": "Sort the Matrix Diagonally",
      "titleSlug": "sort-the-matrix-diagonally",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Sorting",
        "Matrix"
      ],
      "description": "A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix&#39;s end. For example, the matrix diagonal starting from mat[2][0], where mat is a 6 x 3 matrix, includes cells mat[2][0], mat[3][1], and mat[4][2]. Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix. &nbsp; Example 1: Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]] Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]] Example 2: Input: mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]] Output: [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]] &nbsp; Constraints: m == mat.length n == mat[i].length 1 &lt;= m, n &lt;= 100 1 &lt;= mat[i][j] &lt;= 100"
    },
    {
      "number": 1330,
      "title": "Reverse Subarray To Maximize Array Value",
      "titleSlug": "reverse-subarray-to-maximize-array-value",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Greedy"
      ],
      "description": "You are given an integer array nums. The value of this array is defined as the sum of |nums[i] - nums[i + 1]| for all 0 &lt;= i &lt; nums.length - 1. You are allowed to select any subarray of the given array and reverse it. You can perform this operation only once. Find maximum possible value of the final array. &nbsp; Example 1: Input: nums = [2,3,1,5,4] Output: 10 Explanation: By reversing the subarray [3,1,5] the array becomes [2,5,1,3,4] whose value is 10. Example 2: Input: nums = [2,4,9,24,2,1,10] Output: 68 &nbsp; Constraints: 2 &lt;= nums.length &lt;= 3 * 104 -105 &lt;= nums[i] &lt;= 105 The answer is guaranteed to fit in a 32-bit integer."
    },
    {
      "number": 1331,
      "title": "Rank Transform of an Array",
      "titleSlug": "rank-transform-of-an-array",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Sorting"
      ],
      "description": "Given an array of integers&nbsp;arr, replace each element with its rank. The rank represents how large the element is. The rank has the following rules: Rank is an integer starting from 1. The larger the element, the larger the rank. If two elements are equal, their rank must be the same. Rank should be as small as possible. &nbsp; Example 1: Input: arr = [40,10,20,30] Output: [4,1,2,3] Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest. Example 2: Input: arr = [100,100,100] Output: [1,1,1] Explanation: Same elements share the same rank. Example 3: Input: arr = [37,12,28,9,100,56,80,5,12] Output: [5,3,4,2,8,6,7,1,3] &nbsp; Constraints: 0 &lt;= arr.length &lt;= 105 -109&nbsp;&lt;= arr[i] &lt;= 109"
    },
    {
      "number": 1332,
      "title": "Remove Palindromic Subsequences",
      "titleSlug": "remove-palindromic-subsequences",
      "difficulty": "Easy",
      "tags": [
        "Two Pointers",
        "String"
      ],
      "description": "You are given a string s consisting only of letters &#39;a&#39; and &#39;b&#39;. In a single step you can remove one palindromic subsequence from s. Return the minimum number of steps to make the given string empty. A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous. A string is called palindrome if is one that reads the same backward as well as forward. &nbsp; Example 1: Input: s = &quot;ababa&quot; Output: 1 Explanation: s is already a palindrome, so its entirety can be removed in a single step. Example 2: Input: s = &quot;abb&quot; Output: 2 Explanation: &quot;abb&quot; -&gt; &quot;bb&quot; -&gt; &quot;&quot;. Remove palindromic subsequence &quot;a&quot; then &quot;bb&quot;. Example 3: Input: s = &quot;baabb&quot; Output: 2 Explanation: &quot;baabb&quot; -&gt; &quot;b&quot; -&gt; &quot;&quot;. Remove palindromic subsequence &quot;baab&quot; then &quot;b&quot;. &nbsp; Constraints: 1 &lt;= s.length &lt;= 1000 s[i] is either &#39;a&#39; or &#39;b&#39;."
    },
    {
      "number": 1333,
      "title": "Filter Restaurants by Vegan-Friendly, Price and Distance",
      "titleSlug": "filter-restaurants-by-vegan-friendly-price-and-distance",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Sorting"
      ],
      "description": "Given the array restaurants where &nbsp;restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters. The veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true)&nbsp;or false&nbsp;(meaning you can include any restaurant). In addition, you have the filters&nbsp;maxPrice and maxDistance&nbsp;which&nbsp;are the maximum value for price and distance of restaurants you should consider respectively. Return the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false. &nbsp; Example 1: Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10 Output: [3,1,5] Explanation: The restaurants are: Restaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10] Restaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5] Restaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4] Restaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3] Restaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] After filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest). Example 2: Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10 Output: [4,3,2,1,5] Explanation: The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered. Example 3: Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3 Output: [4,5] &nbsp; Constraints: 1 &lt;=&nbsp;restaurants.length &lt;= 10^4 restaurants[i].length == 5 1 &lt;=&nbsp;idi, ratingi, pricei, distancei &lt;= 10^5 1 &lt;=&nbsp;maxPrice,&nbsp;maxDistance &lt;= 10^5 veganFriendlyi and&nbsp;veganFriendly&nbsp;are&nbsp;0 or 1. All idi are distinct."
    },
    {
      "number": 1334,
      "title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
      "titleSlug": "find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance",
      "difficulty": "Medium",
      "tags": [
        "Dynamic Programming",
        "Graph",
        "Shortest Path"
      ],
      "description": "There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold. Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number. Notice that the distance of a path connecting cities i and j is equal to the sum of the edges&#39; weights along that path. &nbsp; Example 1: Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4 Output: 3 Explanation: The figure above describes the graph.&nbsp; The neighboring cities at a distanceThreshold = 4 for each city are: City 0 -&gt; [City 1, City 2]&nbsp; City 1 -&gt; [City 0, City 2, City 3]&nbsp; City 2 -&gt; [City 0, City 1, City 3]&nbsp; City 3 -&gt; [City 1, City 2]&nbsp; Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number. Example 2: Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2 Output: 0 Explanation: The figure above describes the graph.&nbsp; The neighboring cities at a distanceThreshold = 2 for each city are: City 0 -&gt; [City 1]&nbsp; City 1 -&gt; [City 0, City 4]&nbsp; City 2 -&gt; [City 3, City 4]&nbsp; City 3 -&gt; [City 2, City 4] City 4 -&gt; [City 1, City 2, City 3]&nbsp; The city 0 has 1 neighboring city at a distanceThreshold = 2. &nbsp; Constraints: 2 &lt;= n &lt;= 100 1 &lt;= edges.length &lt;= n * (n - 1) / 2 edges[i].length == 3 0 &lt;= fromi &lt; toi &lt; n 1 &lt;= weighti,&nbsp;distanceThreshold &lt;= 10^4 All pairs (fromi, toi) are distinct."
    },
    {
      "number": 1335,
      "title": "Minimum Difficulty of a Job Schedule",
      "titleSlug": "minimum-difficulty-of-a-job-schedule",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, you have to finish all the jobs j where 0 &lt;= j &lt; i). You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done on that day. You are given an integer array jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i]. Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1. &nbsp; Example 1: Input: jobDifficulty = [6,5,4,3,2,1], d = 2 Output: 7 Explanation: First day you can finish the first 5 jobs, total difficulty = 6. Second day you can finish the last job, total difficulty = 1. The difficulty of the schedule = 6 + 1 = 7 Example 2: Input: jobDifficulty = [9,9,9], d = 4 Output: -1 Explanation: If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs. Example 3: Input: jobDifficulty = [1,1,1], d = 3 Output: 3 Explanation: The schedule is one job per day. total difficulty will be 3. &nbsp; Constraints: 1 &lt;= jobDifficulty.length &lt;= 300 0 &lt;= jobDifficulty[i] &lt;= 1000 1 &lt;= d &lt;= 10"
    },
    {
      "number": 1337,
      "title": "The K Weakest Rows in a Matrix",
      "titleSlug": "the-k-weakest-rows-in-a-matrix",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Binary Search",
        "Sorting",
        "Heap (Priority Queue)",
        "Matrix"
      ],
      "description": "You are given an m x n binary matrix mat of 1&#39;s (representing soldiers) and 0&#39;s (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1&#39;s will appear to the left of all the 0&#39;s in each row. A row i is weaker than a row j if one of the following is true: The number of soldiers in row i is less than the number of soldiers in row j. Both rows have the same number of soldiers and i &lt; j. Return the indices of the k weakest rows in the matrix ordered from weakest to strongest. &nbsp; Example 1: Input: mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3 Output: [2,0,3] Explanation: The number of soldiers in each row is: - Row 0: 2 - Row 1: 4 - Row 2: 1 - Row 3: 2 - Row 4: 5 The rows ordered from weakest to strongest are [2,0,3,1,4]. Example 2: Input: mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2 Output: [0,2] Explanation: The number of soldiers in each row is: - Row 0: 1 - Row 1: 4 - Row 2: 1 - Row 3: 1 The rows ordered from weakest to strongest are [0,2,3,1]. &nbsp; Constraints: m == mat.length n == mat[i].length 2 &lt;= n, m &lt;= 100 1 &lt;= k &lt;= m matrix[i][j] is either 0 or 1."
    },
    {
      "number": 1338,
      "title": "Reduce Array Size to The Half",
      "titleSlug": "reduce-array-size-to-the-half",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Greedy",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array. Return the minimum size of the set so that at least half of the integers of the array are removed. &nbsp; Example 1: Input: arr = [3,3,3,3,5,5,5,2,2,7] Output: 2 Explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array). Possible sets of size 2 are {3,5},{3,2},{5,2}. Choosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has a size greater than half of the size of the old array. Example 2: Input: arr = [7,7,7,7,7,7] Output: 1 Explanation: The only possible set you can choose is {7}. This will make the new array empty. &nbsp; Constraints: 2 &lt;= arr.length &lt;= 105 arr.length is even. 1 &lt;= arr[i] &lt;= 105"
    },
    {
      "number": 1339,
      "title": "Maximum Product of Splitted Binary Tree",
      "titleSlug": "maximum-product-of-splitted-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized. Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7. Note that you need to maximize the answer before taking the mod and not after taking it. &nbsp; Example 1: Input: root = [1,2,3,4,5,6] Output: 110 Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10) Example 2: Input: root = [1,null,2,3,4,null,null,5,6] Output: 90 Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6) &nbsp; Constraints: The number of nodes in the tree is in the range [2, 5 * 104]. 1 &lt;= Node.val &lt;= 104"
    },
    {
      "number": 1340,
      "title": "Jump Game V",
      "titleSlug": "jump-game-v",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Sorting"
      ],
      "description": "Given an array of&nbsp;integers arr and an integer d. In one step you can jump from index i to index: i + x where:&nbsp;i + x &lt; arr.length and 0 &lt;&nbsp;x &lt;= d. i - x where:&nbsp;i - x &gt;= 0 and 0 &lt;&nbsp;x &lt;= d. In addition, you can only jump from index i to index j&nbsp;if arr[i] &gt; arr[j] and arr[i] &gt; arr[k] for all indices k between i and j (More formally min(i,&nbsp;j) &lt; k &lt; max(i, j)). You can choose any index of the array and start jumping. Return the maximum number of indices&nbsp;you can visit. Notice that you can not jump outside of the array at any time. &nbsp; Example 1: Input: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2 Output: 4 Explanation: You can start at index 10. You can jump 10 --&gt; 8 --&gt; 6 --&gt; 7 as shown. Note that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 &gt; 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 &gt; 9. Similarly You cannot jump from index 3 to index 2 or index 1. Example 2: Input: arr = [3,3,3,3,3], d = 3 Output: 1 Explanation: You can start at any index. You always cannot jump to any index. Example 3: Input: arr = [7,6,5,4,3,2,1], d = 1 Output: 7 Explanation: Start at index 0. You can visit all the indicies. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 1000 1 &lt;= arr[i] &lt;= 105 1 &lt;= d &lt;= arr.length"
    },
    {
      "number": 1341,
      "title": "Movie Rating",
      "titleSlug": "movie-rating",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Movies +---------------+---------+ | Column Name | Type | +---------------+---------+ | movie_id | int | | title | varchar | +---------------+---------+ movie_id is the primary key (column with unique values) for this table. title is the name of the movie. &nbsp; Table: Users +---------------+---------+ | Column Name | Type | +---------------+---------+ | user_id | int | | name | varchar | +---------------+---------+ user_id is the primary key (column with unique values) for this table. The column &#39;name&#39; has unique values. Table: MovieRating +---------------+---------+ | Column Name | Type | +---------------+---------+ | movie_id | int | | user_id | int | | rating | int | | created_at | date | +---------------+---------+ (movie_id, user_id) is the primary key (column with unique values) for this table. This table contains the rating of a movie by a user in their review. created_at is the user&#39;s review date. &nbsp; Write a solution to: Find the name of the user who has rated the greatest number of movies. In case of a tie, return the lexicographically smaller user name. Find the movie name with the highest average rating in February 2020. In case of a tie, return the lexicographically smaller movie name. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Movies table: +-------------+--------------+ | movie_id | title | +-------------+--------------+ | 1 | Avengers | | 2 | Frozen 2 | | 3 | Joker | +-------------+--------------+ Users table: +-------------+--------------+ | user_id | name | +-------------+--------------+ | 1 | Daniel | | 2 | Monica | | 3 | Maria | | 4 | James | +-------------+--------------+ MovieRating table: +-------------+--------------+--------------+-------------+ | movie_id | user_id | rating | created_at | +-------------+--------------+--------------+-------------+ | 1 | 1 | 3 | 2020-01-12 | | 1 | 2 | 4 | 2020-02-11 | | 1 | 3 | 2 | 2020-02-12 | | 1 | 4 | 1 | 2020-01-01 | | 2 | 1 | 5 | 2020-02-17 | | 2 | 2 | 2 | 2020-02-01 | | 2 | 3 | 2 | 2020-03-01 | | 3 | 1 | 3 | 2020-02-22 | | 3 | 2 | 4 | 2020-02-25 | +-------------+--------------+--------------+-------------+ Output: +--------------+ | results | +--------------+ | Daniel | | Frozen 2 | +--------------+ Explanation: Daniel and Monica have rated 3 movies (&quot;Avengers&quot;, &quot;Frozen 2&quot; and &quot;Joker&quot;) but Daniel is smaller lexicographically. Frozen 2 and Joker have a rating average of 3.5 in February but Frozen 2 is smaller lexicographically."
    },
    {
      "number": 1342,
      "title": "Number of Steps to Reduce a Number to Zero",
      "titleSlug": "number-of-steps-to-reduce-a-number-to-zero",
      "difficulty": "Easy",
      "tags": [
        "Math",
        "Bit Manipulation"
      ],
      "description": "Given an integer num, return the number of steps to reduce it to zero. In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it. &nbsp; Example 1: Input: num = 14 Output: 6 Explanation:&nbsp; Step 1) 14 is even; divide by 2 and obtain 7.&nbsp; Step 2) 7 is odd; subtract 1 and obtain 6. Step 3) 6 is even; divide by 2 and obtain 3.&nbsp; Step 4) 3 is odd; subtract 1 and obtain 2.&nbsp; Step 5) 2 is even; divide by 2 and obtain 1.&nbsp; Step 6) 1 is odd; subtract 1 and obtain 0. Example 2: Input: num = 8 Output: 4 Explanation:&nbsp; Step 1) 8 is even; divide by 2 and obtain 4.&nbsp; Step 2) 4 is even; divide by 2 and obtain 2.&nbsp; Step 3) 2 is even; divide by 2 and obtain 1.&nbsp; Step 4) 1 is odd; subtract 1 and obtain 0. Example 3: Input: num = 123 Output: 12 &nbsp; Constraints: 0 &lt;= num &lt;= 106"
    },
    {
      "number": 1343,
      "title": "Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold",
      "titleSlug": "number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Sliding Window"
      ],
      "description": "Given an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold. &nbsp; Example 1: Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4 Output: 3 Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold). Example 2: Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5 Output: 6 Explanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 105 1 &lt;= arr[i] &lt;= 104 1 &lt;= k &lt;= arr.length 0 &lt;= threshold &lt;= 104"
    },
    {
      "number": 1344,
      "title": "Angle Between Hands of a Clock",
      "titleSlug": "angle-between-hands-of-a-clock",
      "difficulty": "Medium",
      "tags": [
        "Math"
      ],
      "description": "Given two numbers, hour and minutes, return the smaller angle (in degrees) formed between the hour and the minute hand. Answers within 10-5 of the actual value will be accepted as correct. &nbsp; Example 1: Input: hour = 12, minutes = 30 Output: 165 Example 2: Input: hour = 3, minutes = 30 Output: 75 Example 3: Input: hour = 3, minutes = 15 Output: 7.5 &nbsp; Constraints: 1 &lt;= hour &lt;= 12 0 &lt;= minutes &lt;= 59"
    },
    {
      "number": 1345,
      "title": "Jump Game IV",
      "titleSlug": "jump-game-iv",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Hash Table",
        "Breadth-First Search"
      ],
      "description": "Given an array of&nbsp;integers arr, you are initially positioned at the first index of the array. In one step you can jump from index i to index: i + 1 where:&nbsp;i + 1 &lt; arr.length. i - 1 where:&nbsp;i - 1 &gt;= 0. j where: arr[i] == arr[j] and i != j. Return the minimum number of steps to reach the last index of the array. Notice that you can not jump outside of the array at any time. &nbsp; Example 1: Input: arr = [100,-23,-23,404,100,23,23,23,3,404] Output: 3 Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array. Example 2: Input: arr = [7] Output: 0 Explanation: Start index is the last index. You do not need to jump. Example 3: Input: arr = [7,6,9,6,9,6,9,7] Output: 1 Explanation: You can jump directly from index 0 to index 7 which is last index of the array. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 5 * 104 -108 &lt;= arr[i] &lt;= 108"
    },
    {
      "number": 1346,
      "title": "Check If N and Its Double Exist",
      "titleSlug": "check-if-n-and-its-double-exist",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Two Pointers",
        "Binary Search",
        "Sorting"
      ],
      "description": "Given an array arr of integers, check if there exist two indices i and j such that : i != j 0 &lt;= i, j &lt; arr.length arr[i] == 2 * arr[j] &nbsp; Example 1: Input: arr = [10,2,5,3] Output: true Explanation: For i = 0 and j = 2, arr[i] == 10 == 2 * 5 == 2 * arr[j] Example 2: Input: arr = [3,1,7,11] Output: false Explanation: There is no i and j that satisfy the conditions. &nbsp; Constraints: 2 &lt;= arr.length &lt;= 500 -103 &lt;= arr[i] &lt;= 103"
    },
    {
      "number": 1347,
      "title": "Minimum Number of Steps to Make Two Strings Anagram",
      "titleSlug": "minimum-number-of-steps-to-make-two-strings-anagram",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Counting"
      ],
      "description": "You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character. Return the minimum number of steps to make t an anagram of s. An Anagram of a string is a string that contains the same characters with a different (or the same) ordering. &nbsp; Example 1: Input: s = &quot;bab&quot;, t = &quot;aba&quot; Output: 1 Explanation: Replace the first &#39;a&#39; in t with b, t = &quot;bba&quot; which is anagram of s. Example 2: Input: s = &quot;leetcode&quot;, t = &quot;practice&quot; Output: 5 Explanation: Replace &#39;p&#39;, &#39;r&#39;, &#39;a&#39;, &#39;i&#39; and &#39;c&#39; from t with proper characters to make t anagram of s. Example 3: Input: s = &quot;anagram&quot;, t = &quot;mangaar&quot; Output: 0 Explanation: &quot;anagram&quot; and &quot;mangaar&quot; are anagrams. &nbsp; Constraints: 1 &lt;= s.length &lt;= 5 * 104 s.length == t.length s and t consist of lowercase English letters only."
    },
    {
      "number": 1348,
      "title": "Tweet Counts Per Frequency",
      "titleSlug": "tweet-counts-per-frequency",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Binary Search",
        "Design",
        "Sorting",
        "Ordered Set"
      ],
      "description": "A social media company is trying to monitor activity on their site by analyzing the number of tweets that occur in select periods of time. These periods can be partitioned into smaller time chunks based on a certain frequency (every minute, hour, or day). For example, the period [10, 10000] (in seconds) would be partitioned into the following time chunks with these frequencies: Every minute (60-second chunks): [10,69], [70,129], [130,189], ..., [9970,10000] Every hour (3600-second chunks): [10,3609], [3610,7209], [7210,10000] Every day (86400-second chunks): [10,10000] Notice that the last chunk may be shorter than the specified frequency&#39;s chunk size and will always end with the end time of the period (10000 in the above example). Design and implement an API to help the company with their analysis. Implement the TweetCounts class: TweetCounts() Initializes the TweetCounts object. void recordTweet(String tweetName, int time) Stores the tweetName at the recorded time (in seconds). List&lt;Integer&gt; getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) Returns a list of integers representing the number of tweets with tweetName in each time chunk for the given period of time [startTime, endTime] (in seconds) and frequency freq. freq is one of &quot;minute&quot;, &quot;hour&quot;, or &quot;day&quot; representing a frequency of every minute, hour, or day respectively. &nbsp; Example: Input [&quot;TweetCounts&quot;,&quot;recordTweet&quot;,&quot;recordTweet&quot;,&quot;recordTweet&quot;,&quot;getTweetCountsPerFrequency&quot;,&quot;getTweetCountsPerFrequency&quot;,&quot;recordTweet&quot;,&quot;getTweetCountsPerFrequency&quot;] [[],[&quot;tweet3&quot;,0],[&quot;tweet3&quot;,60],[&quot;tweet3&quot;,10],[&quot;minute&quot;,&quot;tweet3&quot;,0,59],[&quot;minute&quot;,&quot;tweet3&quot;,0,60],[&quot;tweet3&quot;,120],[&quot;hour&quot;,&quot;tweet3&quot;,0,210]] Output [null,null,null,null,[2],[2,1],null,[4]] Explanation TweetCounts tweetCounts = new TweetCounts(); tweetCounts.recordTweet(&quot;tweet3&quot;, 0); // New tweet &quot;tweet3&quot; at time 0 tweetCounts.recordTweet(&quot;tweet3&quot;, 60); // New tweet &quot;tweet3&quot; at time 60 tweetCounts.recordTweet(&quot;tweet3&quot;, 10); // New tweet &quot;tweet3&quot; at time 10 tweetCounts.getTweetCountsPerFrequency(&quot;minute&quot;, &quot;tweet3&quot;, 0, 59); // return [2]; chunk [0,59] had 2 tweets tweetCounts.getTweetCountsPerFrequency(&quot;minute&quot;, &quot;tweet3&quot;, 0, 60); // return [2,1]; chunk [0,59] had 2 tweets, chunk [60,60] had 1 tweet tweetCounts.recordTweet(&quot;tweet3&quot;, 120); // New tweet &quot;tweet3&quot; at time 120 tweetCounts.getTweetCountsPerFrequency(&quot;hour&quot;, &quot;tweet3&quot;, 0, 210); // return [4]; chunk [0,210] had 4 tweets &nbsp; Constraints: 0 &lt;= time, startTime, endTime &lt;= 109 0 &lt;= endTime - startTime &lt;= 104 There will be at most 104 calls in total to recordTweet and getTweetCountsPerFrequency."
    },
    {
      "number": 1349,
      "title": "Maximum Students Taking Exam",
      "titleSlug": "maximum-students-taking-exam",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Bit Manipulation",
        "Matrix",
        "Bitmask"
      ],
      "description": "Given a m&nbsp;* n&nbsp;matrix seats&nbsp;&nbsp;that represent seats distributions&nbsp;in a classroom.&nbsp;If a seat&nbsp;is&nbsp;broken, it is denoted by &#39;#&#39; character otherwise it is denoted by a &#39;.&#39; character. Students can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting&nbsp;directly in front or behind him. Return the maximum number of students that can take the exam together&nbsp;without any cheating being possible. Students must be placed in seats in good condition. &nbsp; Example 1: Input: seats = [[&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;], &nbsp; [&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;], &nbsp; [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;]] Output: 4 Explanation: Teacher can place 4 students in available seats so they don&#39;t cheat on the exam. Example 2: Input: seats = [[&quot;.&quot;,&quot;#&quot;], &nbsp; [&quot;#&quot;,&quot;#&quot;], &nbsp; [&quot;#&quot;,&quot;.&quot;], &nbsp; [&quot;#&quot;,&quot;#&quot;], &nbsp; [&quot;.&quot;,&quot;#&quot;]] Output: 3 Explanation: Place all students in available seats. Example 3: Input: seats = [[&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;], &nbsp; [&quot;.&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;], &nbsp; [&quot;.&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;,&quot;.&quot;], &nbsp; [&quot;.&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;], &nbsp; [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;]] Output: 10 Explanation: Place students in available seats in column 1, 3 and 5. &nbsp; Constraints: seats&nbsp;contains only characters&nbsp;&#39;.&#39;&nbsp;and&#39;#&#39;. m ==&nbsp;seats.length n ==&nbsp;seats[i].length 1 &lt;= m &lt;= 8 1 &lt;= n &lt;= 8"
    },
    {
      "number": 1351,
      "title": "Count Negative Numbers in a Sorted Matrix",
      "titleSlug": "count-negative-numbers-in-a-sorted-matrix",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Binary Search",
        "Matrix"
      ],
      "description": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid. &nbsp; Example 1: Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]] Output: 8 Explanation: There are 8 negatives number in the matrix. Example 2: Input: grid = [[3,2],[1,0]] Output: 0 &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 100 -100 &lt;= grid[i][j] &lt;= 100 &nbsp; Follow up: Could you find an O(n + m) solution?"
    },
    {
      "number": 1352,
      "title": "Product of the Last K Numbers",
      "titleSlug": "product-of-the-last-k-numbers",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math",
        "Design",
        "Data Stream",
        "Prefix Sum"
      ],
      "description": "Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream. Implement the ProductOfNumbers class: ProductOfNumbers() Initializes the object with an empty stream. void add(int num) Appends the integer num to the stream. int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers. The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing. &nbsp; Example: Input [&quot;ProductOfNumbers&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;add&quot;,&quot;getProduct&quot;] [[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]] Output [null,null,null,null,null,null,20,40,0,null,32] Explanation ProductOfNumbers productOfNumbers = new ProductOfNumbers(); productOfNumbers.add(3); // [3] productOfNumbers.add(0); // [3,0] productOfNumbers.add(2); // [3,0,2] productOfNumbers.add(5); // [3,0,2,5] productOfNumbers.add(4); // [3,0,2,5,4] productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20 productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40 productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0 productOfNumbers.add(8); // [3,0,2,5,4,8] productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 &nbsp; Constraints: 0 &lt;= num &lt;= 100 1 &lt;= k &lt;= 4 * 104 At most 4 * 104 calls will be made to add and getProduct. The product of the stream at any point in time will fit in a 32-bit integer. &nbsp; Follow-up: Can you implement both GetProduct and Add to work in O(1) time complexity instead of O(k) time complexity?"
    },
    {
      "number": 1353,
      "title": "Maximum Number of Events That Can Be Attended",
      "titleSlug": "maximum-number-of-events-that-can-be-attended",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Greedy",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi. You can attend an event i at any day d where startTimei &lt;= d &lt;= endTimei. You can only attend one event at any time d. Return the maximum number of events you can attend. &nbsp; Example 1: Input: events = [[1,2],[2,3],[3,4]] Output: 3 Explanation: You can attend all the three events. One way to attend them all is as shown. Attend the first event on day 1. Attend the second event on day 2. Attend the third event on day 3. Example 2: Input: events= [[1,2],[2,3],[3,4],[1,2]] Output: 4 &nbsp; Constraints: 1 &lt;= events.length &lt;= 105 events[i].length == 2 1 &lt;= startDayi &lt;= endDayi &lt;= 105"
    },
    {
      "number": 1354,
      "title": "Construct Target Array With Multiple Sums",
      "titleSlug": "construct-target-array-with-multiple-sums",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Heap (Priority Queue)"
      ],
      "description": "You are given an array target of n integers. From a starting array arr consisting of n 1&#39;s, you may perform the following procedure : let x be the sum of all elements currently in your array. choose index i, such that 0 &lt;= i &lt; n and set the value of arr at index i to x. You may repeat this procedure as many times as needed. Return true if it is possible to construct the target array from arr, otherwise, return false. &nbsp; Example 1: Input: target = [9,3,5] Output: true Explanation: Start with arr = [1, 1, 1] [1, 1, 1], sum = 3 choose index 1 [1, 3, 1], sum = 5 choose index 2 [1, 3, 5], sum = 9 choose index 0 [9, 3, 5] Done Example 2: Input: target = [1,1,1,2] Output: false Explanation: Impossible to create target array from [1,1,1,1]. Example 3: Input: target = [8,5] Output: true &nbsp; Constraints: n == target.length 1 &lt;= n &lt;= 5 * 104 1 &lt;= target[i] &lt;= 109"
    },
    {
      "number": 1356,
      "title": "Sort Integers by The Number of 1 Bits",
      "titleSlug": "sort-integers-by-the-number-of-1-bits",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Bit Manipulation",
        "Sorting",
        "Counting"
      ],
      "description": "You are given an integer array arr. Sort the integers in the array&nbsp;in ascending order by the number of 1&#39;s&nbsp;in their binary representation and in case of two or more integers have the same number of 1&#39;s you have to sort them in ascending order. Return the array after sorting it. &nbsp; Example 1: Input: arr = [0,1,2,3,4,5,6,7,8] Output: [0,1,2,4,8,3,5,6,7] Explantion: [0] is the only integer with 0 bits. [1,2,4,8] all have 1 bit. [3,5,6] have 2 bits. [7] has 3 bits. The sorted array by bits is [0,1,2,4,8,3,5,6,7] Example 2: Input: arr = [1024,512,256,128,64,32,16,8,4,2,1] Output: [1,2,4,8,16,32,64,128,256,512,1024] Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 500 0 &lt;= arr[i] &lt;= 104"
    },
    {
      "number": 1357,
      "title": "Apply Discount Every n Orders",
      "titleSlug": "apply-discount-every-n-orders",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Design"
      ],
      "description": "There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i]. When a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product). The supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100). Implement the Cashier class: Cashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices. double getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted. &nbsp; Example 1: Input [&quot;Cashier&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;] [[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]] Output [null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0] Explanation Cashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]); cashier.getBill([1,2],[1,2]); // return 500.0. 1st customer, no discount. // bill = 1 * 100 + 2 * 200 = 500. cashier.getBill([3,7],[10,10]); // return 4000.0. 2nd customer, no discount. // bill = 10 * 300 + 10 * 100 = 4000. cashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]); // return 800.0. 3rd customer, 50% discount. // Original bill = 1600 // Actual bill = 1600 * ((100 - 50) / 100) = 800. cashier.getBill([4],[10]); // return 4000.0. 4th customer, no discount. cashier.getBill([7,3],[10,10]); // return 4000.0. 5th customer, no discount. cashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount. // Original bill = 14700, but with // Actual bill = 14700 * ((100 - 50) / 100) = 7350. cashier.getBill([2,3,5],[5,3,2]); // return 2500.0. 7th customer, no discount. &nbsp; Constraints: 1 &lt;= n &lt;= 104 0 &lt;= discount &lt;= 100 1 &lt;= products.length &lt;= 200 prices.length == products.length 1 &lt;= products[i] &lt;= 200 1 &lt;= prices[i] &lt;= 1000 The elements in products are unique. 1 &lt;= product.length &lt;= products.length amount.length == product.length product[j] exists in products. 1 &lt;= amount[j] &lt;= 1000 The elements of product are unique. At most 1000 calls will be made to getBill. Answers within 10-5 of the actual value will be accepted."
    },
    {
      "number": 1358,
      "title": "Number of Substrings Containing All Three Characters",
      "titleSlug": "number-of-substrings-containing-all-three-characters",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Sliding Window"
      ],
      "description": "Given a string s&nbsp;consisting only of characters a, b and c. Return the number of substrings containing at least&nbsp;one occurrence of all these characters a, b and c. &nbsp; Example 1: Input: s = &quot;abcabc&quot; Output: 10 Explanation: The substrings containing&nbsp;at least&nbsp;one occurrence of the characters&nbsp;a,&nbsp;b&nbsp;and&nbsp;c are &quot;abc&quot;, &quot;abca&quot;, &quot;abcab&quot;, &quot;abcabc&quot;, &quot;bca&quot;, &quot;bcab&quot;, &quot;bcabc&quot;, &quot;cab&quot;, &quot;cabc&quot; and &quot;abc&quot; (again). Example 2: Input: s = &quot;aaacb&quot; Output: 3 Explanation: The substrings containing&nbsp;at least&nbsp;one occurrence of the characters&nbsp;a,&nbsp;b&nbsp;and&nbsp;c are &quot;aaacb&quot;, &quot;aacb&quot; and &quot;acb&quot;. Example 3: Input: s = &quot;abc&quot; Output: 1 &nbsp; Constraints: 3 &lt;= s.length &lt;= 5 x 10^4 s&nbsp;only consists of&nbsp;a, b or c&nbsp;characters."
    },
    {
      "number": 1359,
      "title": "Count All Valid Pickup and Delivery Options",
      "titleSlug": "count-all-valid-pickup-and-delivery-options",
      "difficulty": "Hard",
      "tags": [
        "Math",
        "Dynamic Programming",
        "Combinatorics"
      ],
      "description": "Given n orders, each order consists of a pickup and a delivery service. Count all valid pickup/delivery possible sequences such that delivery(i) is always after of&nbsp;pickup(i).&nbsp; Since the answer&nbsp;may be too large,&nbsp;return it modulo&nbsp;10^9 + 7. &nbsp; Example 1: Input: n = 1 Output: 1 Explanation: Unique order (P1, D1), Delivery 1 always is after of Pickup 1. Example 2: Input: n = 2 Output: 6 Explanation: All possible orders: (P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1). This is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2. Example 3: Input: n = 3 Output: 90 &nbsp; Constraints: 1 &lt;= n &lt;= 500"
    },
    {
      "number": 1360,
      "title": "Number of Days Between Two Dates",
      "titleSlug": "number-of-days-between-two-dates",
      "difficulty": "Easy",
      "tags": [
        "Math",
        "String"
      ],
      "description": "Write a program to count the number of days between two dates. The two dates are given as strings, their format is YYYY-MM-DD&nbsp;as shown in the examples. &nbsp; Example 1: Input: date1 = \"2019-06-29\", date2 = \"2019-06-30\" Output: 1 Example 2: Input: date1 = \"2020-01-15\", date2 = \"2019-12-31\" Output: 15 &nbsp; Constraints: The given dates are valid&nbsp;dates between the years 1971 and 2100."
    },
    {
      "number": 1361,
      "title": "Validate Binary Tree Nodes",
      "titleSlug": "validate-binary-tree-nodes",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Graph",
        "Binary Tree"
      ],
      "description": "You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree. If node i has no left child then leftChild[i] will equal -1, similarly for the right child. Note that the nodes have no values and that we only use the node numbers in this problem. &nbsp; Example 1: Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1] Output: true Example 2: Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1] Output: false Example 3: Input: n = 2, leftChild = [1,0], rightChild = [-1,-1] Output: false &nbsp; Constraints: n == leftChild.length == rightChild.length 1 &lt;= n &lt;= 104 -1 &lt;= leftChild[i], rightChild[i] &lt;= n - 1"
    },
    {
      "number": 1362,
      "title": "Closest Divisors",
      "titleSlug": "closest-divisors",
      "difficulty": "Medium",
      "tags": [
        "Math"
      ],
      "description": "Given an integer num, find the closest two integers in absolute difference whose product equals&nbsp;num + 1&nbsp;or num + 2. Return the two integers in any order. &nbsp; Example 1: Input: num = 8 Output: [3,3] Explanation: For num + 1 = 9, the closest divisors are 3 &amp; 3, for num + 2 = 10, the closest divisors are 2 &amp; 5, hence 3 &amp; 3 is chosen. Example 2: Input: num = 123 Output: [5,25] Example 3: Input: num = 999 Output: [40,25] &nbsp; Constraints: 1 &lt;= num &lt;= 10^9"
    },
    {
      "number": 1363,
      "title": "Largest Multiple of Three",
      "titleSlug": "largest-multiple-of-three",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Dynamic Programming",
        "Greedy",
        "Sorting"
      ],
      "description": "Given an array of digits digits, return the largest multiple of three that can be formed by concatenating some of the given digits in any order. If there is no answer return an empty string. Since the answer may not fit in an integer data type, return the answer as a string. Note that the returning answer must not contain unnecessary leading zeros. &nbsp; Example 1: Input: digits = [8,1,9] Output: &quot;981&quot; Example 2: Input: digits = [8,6,7,1,0] Output: &quot;8760&quot; Example 3: Input: digits = [1] Output: &quot;&quot; &nbsp; Constraints: 1 &lt;= digits.length &lt;= 104 0 &lt;= digits[i] &lt;= 9"
    },
    {
      "number": 1365,
      "title": "How Many Numbers Are Smaller Than the Current Number",
      "titleSlug": "how-many-numbers-are-smaller-than-the-current-number",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Sorting",
        "Counting Sort"
      ],
      "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j&#39;s&nbsp;such that&nbsp;j != i and nums[j] &lt; nums[i]. Return the answer in an array. &nbsp; Example 1: Input: nums = [8,1,2,2,3] Output: [4,0,1,1,3] Explanation: For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). For nums[1]=1 does not exist any smaller number than it. For nums[2]=2 there exist one smaller number than it (1). For nums[3]=2 there exist one smaller number than it (1). For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2). Example 2: Input: nums = [6,5,4,8] Output: [2,1,0,3] Example 3: Input: nums = [7,7,7,7] Output: [0,0,0,0] &nbsp; Constraints: 2 &lt;= nums.length &lt;= 500 0 &lt;= nums[i] &lt;= 100"
    },
    {
      "number": 1366,
      "title": "Rank Teams by Votes",
      "titleSlug": "rank-teams-by-votes",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Sorting",
        "Counting"
      ],
      "description": "In a special ranking system, each voter gives a rank from highest to lowest to all teams participating in the competition. The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter. You are given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above. Return a string of all teams sorted by the ranking system. &nbsp; Example 1: Input: votes = [&quot;ABC&quot;,&quot;ACB&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;ACB&quot;] Output: &quot;ACB&quot; Explanation: Team A was ranked first place by 5 voters. No other team was voted as first place, so team A is the first team. Team B was ranked second by 2 voters and ranked third by 3 voters. Team C was ranked second by 3 voters and ranked third by 2 voters. As most of the voters ranked C second, team C is the second team, and team B is the third. Example 2: Input: votes = [&quot;WXYZ&quot;,&quot;XYZW&quot;] Output: &quot;XWYZ&quot; Explanation: X is the winner due to the tie-breaking rule. X has the same votes as W for the first position, but X has one vote in the second position, while W does not have any votes in the second position. Example 3: Input: votes = [&quot;ZMNAGUEDSJYLBOPHRQICWFXTVK&quot;] Output: &quot;ZMNAGUEDSJYLBOPHRQICWFXTVK&quot; Explanation: Only one voter, so their votes are used for the ranking. &nbsp; Constraints: 1 &lt;= votes.length &lt;= 1000 1 &lt;= votes[i].length &lt;= 26 votes[i].length == votes[j].length for 0 &lt;= i, j &lt; votes.length. votes[i][j] is an English uppercase letter. All characters of votes[i] are unique. All the characters that occur in votes[0] also occur in votes[j] where 1 &lt;= j &lt; votes.length."
    },
    {
      "number": 1367,
      "title": "Linked List in Binary Tree",
      "titleSlug": "linked-list-in-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Linked List",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "Given a binary tree root and a&nbsp;linked list with&nbsp;head&nbsp;as the first node.&nbsp; Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree&nbsp;otherwise return False. In this context downward path means a path that starts at some node and goes downwards. &nbsp; Example 1: Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3] Output: true Explanation: Nodes in blue form a subpath in the binary Tree. Example 2: Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3] Output: true Example 3: Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3] Output: false Explanation: There is no path in the binary tree that contains all the elements of the linked list from head. &nbsp; Constraints: The number of nodes in the tree will be in the range [1, 2500]. The number of nodes in the list will be in the range [1, 100]. 1 &lt;= Node.val&nbsp;&lt;= 100&nbsp;for each node in the linked list and binary tree."
    },
    {
      "number": 1368,
      "title": "Minimum Cost to Make at Least One Valid Path in a Grid",
      "titleSlug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Breadth-First Search",
        "Graph",
        "Heap (Priority Queue)",
        "Matrix",
        "Shortest Path"
      ],
      "description": "Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be: 1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1]) 2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1]) 3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j]) 4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j]) Notice that there could be some signs on the cells of the grid that point outside the grid. You will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest. You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only. Return the minimum cost to make the grid have at least one valid path. &nbsp; Example 1: Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]] Output: 3 Explanation: You will start at point (0, 0). The path to (3, 3) is as follows. (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) change the arrow to down with cost = 1 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) change the arrow to down with cost = 1 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) change the arrow to down with cost = 1 --&gt; (3, 3) The total cost = 3. Example 2: Input: grid = [[1,1,3],[3,2,2],[1,1,4]] Output: 0 Explanation: You can follow the path from (0, 0) to (2, 2). Example 3: Input: grid = [[1,2],[4,3]] Output: 1 &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 100 1 &lt;= grid[i][j] &lt;= 4"
    },
    {
      "number": 1370,
      "title": "Increasing Decreasing String",
      "titleSlug": "increasing-decreasing-string",
      "difficulty": "Easy",
      "tags": [
        "Hash Table",
        "String",
        "Counting"
      ],
      "description": "You are given a string s. Reorder the string using the following algorithm: Remove the smallest character from s and append it to the result. Remove the smallest character from s that is greater than the last appended character, and append it to the result. Repeat step 2 until no more characters can be removed. Remove the largest character from s and append it to the result. Remove the largest character from s that is smaller than the last appended character, and append it to the result. Repeat step 5 until no more characters can be removed. Repeat steps 1 through 6 until all characters from s have been removed. If the smallest or largest character appears more than once, you may choose any occurrence to append to the result. Return the resulting string after reordering s using this algorithm. &nbsp; Example 1: Input: s = &quot;aaaabbbbcccc&quot; Output: &quot;abccbaabccba&quot; Explanation: After steps 1, 2 and 3 of the first iteration, result = &quot;abc&quot; After steps 4, 5 and 6 of the first iteration, result = &quot;abccba&quot; First iteration is done. Now s = &quot;aabbcc&quot; and we go back to step 1 After steps 1, 2 and 3 of the second iteration, result = &quot;abccbaabc&quot; After steps 4, 5 and 6 of the second iteration, result = &quot;abccbaabccba&quot; Example 2: Input: s = &quot;rat&quot; Output: &quot;art&quot; Explanation: The word &quot;rat&quot; becomes &quot;art&quot; after re-ordering it with the mentioned algorithm. &nbsp; Constraints: 1 &lt;= s.length &lt;= 500 s consists of only lowercase English letters."
    },
    {
      "number": 1371,
      "title": "Find the Longest Substring Containing Vowels in Even Counts",
      "titleSlug": "find-the-longest-substring-containing-vowels-in-even-counts",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Bit Manipulation",
        "Prefix Sum"
      ],
      "description": "Given the string s, return the size of the longest substring containing each vowel an even number of times. That is, &#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, and &#39;u&#39; must appear an even number of times. &nbsp; Example 1: Input: s = &quot;eleetminicoworoep&quot; Output: 13 Explanation: The longest substring is &quot;leetminicowor&quot; which contains two each of the vowels: e, i and o and zero of the vowels: a and u. Example 2: Input: s = &quot;leetcodeisgreat&quot; Output: 5 Explanation: The longest substring is &quot;leetc&quot; which contains two e&#39;s. Example 3: Input: s = &quot;bcbcbc&quot; Output: 6 Explanation: In this case, the given string &quot;bcbcbc&quot; is the longest because all vowels: a, e, i, o and u appear zero times. &nbsp; Constraints: 1 &lt;= s.length &lt;= 5 x 10^5 s&nbsp;contains only lowercase English letters."
    },
    {
      "number": 1372,
      "title": "Longest ZigZag Path in a Binary Tree",
      "titleSlug": "longest-zigzag-path-in-a-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Dynamic Programming",
        "Tree",
        "Depth-First Search",
        "Binary Tree"
      ],
      "description": "You are given the root of a binary tree. A ZigZag path for a binary tree is defined as follow: Choose any node in the binary tree and a direction (right or left). If the current direction is right, move to the right child of the current node; otherwise, move to the left child. Change the direction from right to left or from left to right. Repeat the second and third steps until you can&#39;t move in the tree. Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0). Return the longest ZigZag path contained in that tree. &nbsp; Example 1: Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1] Output: 3 Explanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right). Example 2: Input: root = [1,1,1,null,1,null,null,1,1,null,1] Output: 4 Explanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right). Example 3: Input: root = [1] Output: 0 &nbsp; Constraints: The number of nodes in the tree is in the range [1, 5 * 104]. 1 &lt;= Node.val &lt;= 100"
    },
    {
      "number": 1373,
      "title": "Maximum Sum BST in Binary Tree",
      "titleSlug": "maximum-sum-bst-in-binary-tree",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming",
        "Tree",
        "Depth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given a binary tree root, return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node&#39;s key. The right subtree of a node contains only nodes with keys greater than the node&#39;s key. Both the left and right subtrees must also be binary search trees. &nbsp; Example 1: Input: root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6] Output: 20 Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3. Example 2: Input: root = [4,3,null,1,2] Output: 2 Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2. Example 3: Input: root = [-4,-2,-5] Output: 0 Explanation: All values are negatives. Return an empty BST. &nbsp; Constraints: The number of nodes in the tree is in the range [1, 4 * 104]. -4 * 104 &lt;= Node.val &lt;= 4 * 104"
    },
    {
      "number": 1374,
      "title": "Generate a String With Characters That Have Odd Counts",
      "titleSlug": "generate-a-string-with-characters-that-have-odd-counts",
      "difficulty": "Easy",
      "tags": [
        "String"
      ],
      "description": "Given an&nbsp;integer n, return a string with n&nbsp;characters such that each character in such string occurs an odd number of times. The returned string must contain only lowercase English letters. If there are multiples valid strings, return any of them. &nbsp; &nbsp; Example 1: Input: n = 4 Output: &quot;pppz&quot; Explanation: &quot;pppz&quot; is a valid string since the character &#39;p&#39; occurs three times and the character &#39;z&#39; occurs once. Note that there are many other valid strings such as &quot;ohhh&quot; and &quot;love&quot;. Example 2: Input: n = 2 Output: &quot;xy&quot; Explanation: &quot;xy&quot; is a valid string since the characters &#39;x&#39; and &#39;y&#39; occur once. Note that there are many other valid strings such as &quot;ag&quot; and &quot;ur&quot;. Example 3: Input: n = 7 Output: &quot;holasss&quot; &nbsp; Constraints: 1 &lt;= n &lt;= 500"
    },
    {
      "number": 1375,
      "title": "Number of Times Binary String Is Prefix-Aligned",
      "titleSlug": "number-of-times-binary-string-is-prefix-aligned",
      "difficulty": "Medium",
      "tags": [
        "Array"
      ],
      "description": "You have a 1-indexed binary string of length n where all the bits are 0 initially. We will flip all the bits of this binary string (i.e., change them from 0 to 1) one by one. You are given a 1-indexed integer array flips where flips[i] indicates that the bit at index i will be flipped in the ith step. A binary string is prefix-aligned if, after the ith step, all the bits in the inclusive range [1, i] are ones and all the other bits are zeros. Return the number of times the binary string is prefix-aligned during the flipping process. &nbsp; Example 1: Input: flips = [3,2,4,1,5] Output: 2 Explanation: The binary string is initially &quot;00000&quot;. After applying step 1: The string becomes &quot;00100&quot;, which is not prefix-aligned. After applying step 2: The string becomes &quot;01100&quot;, which is not prefix-aligned. After applying step 3: The string becomes &quot;01110&quot;, which is not prefix-aligned. After applying step 4: The string becomes &quot;11110&quot;, which is prefix-aligned. After applying step 5: The string becomes &quot;11111&quot;, which is prefix-aligned. We can see that the string was prefix-aligned 2 times, so we return 2. Example 2: Input: flips = [4,1,2,3] Output: 1 Explanation: The binary string is initially &quot;0000&quot;. After applying step 1: The string becomes &quot;0001&quot;, which is not prefix-aligned. After applying step 2: The string becomes &quot;1001&quot;, which is not prefix-aligned. After applying step 3: The string becomes &quot;1101&quot;, which is not prefix-aligned. After applying step 4: The string becomes &quot;1111&quot;, which is prefix-aligned. We can see that the string was prefix-aligned 1 time, so we return 1. &nbsp; Constraints: n == flips.length 1 &lt;= n &lt;= 5 * 104 flips is a permutation of the integers in the range [1, n]."
    },
    {
      "number": 1376,
      "title": "Time Needed to Inform All Employees",
      "titleSlug": "time-needed-to-inform-all-employees",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search"
      ],
      "description": "A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company is the one with headID. Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also, it is guaranteed that the subordination relationships have a tree structure. The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news. The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news). Return the number of minutes needed to inform all the employees about the urgent news. &nbsp; Example 1: Input: n = 1, headID = 0, manager = [-1], informTime = [0] Output: 0 Explanation: The head of the company is the only employee in the company. Example 2: Input: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0] Output: 1 Explanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all. The tree structure of the employees in the company is shown. &nbsp; Constraints: 1 &lt;= n &lt;= 105 0 &lt;= headID &lt; n manager.length == n 0 &lt;= manager[i] &lt; n manager[headID] == -1 informTime.length == n 0 &lt;= informTime[i] &lt;= 1000 informTime[i] == 0 if employee i has no subordinates. It is guaranteed that all the employees can be informed."
    },
    {
      "number": 1377,
      "title": "Frog Position After T Seconds",
      "titleSlug": "frog-position-after-t-seconds",
      "difficulty": "Hard",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Graph"
      ],
      "description": "Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex. The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. Return the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted. &nbsp; Example 1: Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4 Output: 0.16666666666666666 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. Example 2: Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7 Output: 0.3333333333333333 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. &nbsp; Constraints: 1 &lt;= n &lt;= 100 edges.length == n - 1 edges[i].length == 2 1 &lt;= ai, bi &lt;= n 1 &lt;= t &lt;= 50 1 &lt;= target &lt;= n"
    },
    {
      "number": 1378,
      "title": "Replace Employee ID With The Unique Identifier",
      "titleSlug": "replace-employee-id-with-the-unique-identifier",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Employees +---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | name | varchar | +---------------+---------+ id is the primary key (column with unique values) for this table. Each row of this table contains the id and the name of an employee in a company. &nbsp; Table: EmployeeUNI +---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | unique_id | int | +---------------+---------+ (id, unique_id) is the primary key (combination of columns with unique values) for this table. Each row of this table contains the id and the corresponding unique id of an employee in the company. &nbsp; Write a solution to show the unique ID of each user, If a user does not have a unique ID replace just show null. Return the result table in any order. The result format is in the following example. &nbsp; Example 1: Input: Employees table: +----+----------+ | id | name | +----+----------+ | 1 | Alice | | 7 | Bob | | 11 | Meir | | 90 | Winston | | 3 | Jonathan | +----+----------+ EmployeeUNI table: +----+-----------+ | id | unique_id | +----+-----------+ | 3 | 1 | | 11 | 2 | | 90 | 3 | +----+-----------+ Output: +-----------+----------+ | unique_id | name | +-----------+----------+ | null | Alice | | null | Bob | | 2 | Meir | | 3 | Winston | | 1 | Jonathan | +-----------+----------+ Explanation: Alice and Bob do not have a unique ID, We will show null instead. The unique ID of Meir is 2. The unique ID of Winston is 3. The unique ID of Jonathan is 1."
    },
    {
      "number": 1379,
      "title": "Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
      "titleSlug": "find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree",
      "difficulty": "Easy",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given two binary trees original and cloned and given a reference to a node target in the original tree. The cloned tree is a copy of the original tree. Return a reference to the same node in the cloned tree. Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree. &nbsp; Example 1: Input: tree = [7,4,3,null,null,6,19], target = 3 Output: 3 Explanation: In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree. Example 2: Input: tree = [7], target = 7 Output: 7 Example 3: Input: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4 Output: 4 &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. The values of the nodes of the tree are unique. target node is a node from the original tree and is not null. &nbsp; Follow up: Could you solve the problem if repeated values on the tree are allowed?"
    },
    {
      "number": 1380,
      "title": "Lucky Numbers in a Matrix",
      "titleSlug": "lucky-numbers-in-a-matrix",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Matrix"
      ],
      "description": "Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order. A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column. &nbsp; Example 1: Input: matrix = [[3,7,8],[9,11,13],[15,16,17]] Output: [15] Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 2: Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]] Output: [12] Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 3: Input: matrix = [[7,8],[1,2]] Output: [7] Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column. &nbsp; Constraints: m == mat.length n == mat[i].length 1 &lt;= n, m &lt;= 50 1 &lt;= matrix[i][j] &lt;= 105. All elements in the matrix are distinct."
    },
    {
      "number": 1381,
      "title": "Design a Stack With Increment Operation",
      "titleSlug": "design-a-stack-with-increment-operation",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Stack",
        "Design"
      ],
      "description": "Design a stack that supports increment operations on its elements. Implement the CustomStack class: CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack. void push(int x) Adds x to the top of the stack if the stack has not reached the maxSize. int pop() Pops and returns the top of the stack or -1 if the stack is empty. void inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, increment all the elements in the stack. &nbsp; Example 1: Input [&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;] [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]] Output [null,null,null,2,null,null,null,null,null,103,202,201,-1] Explanation CustomStack stk = new CustomStack(3); // Stack is Empty [] stk.push(1); // stack becomes [1] stk.push(2); // stack becomes [1, 2] stk.pop(); // return 2 --&gt; Return top of the stack 2, stack becomes [1] stk.push(2); // stack becomes [1, 2] stk.push(3); // stack becomes [1, 2, 3] stk.push(4); // stack still [1, 2, 3], Do not add another elements as size is 4 stk.increment(5, 100); // stack becomes [101, 102, 103] stk.increment(2, 100); // stack becomes [201, 202, 103] stk.pop(); // return 103 --&gt; Return top of the stack 103, stack becomes [201, 202] stk.pop(); // return 202 --&gt; Return top of the stack 202, stack becomes [201] stk.pop(); // return 201 --&gt; Return top of the stack 201, stack becomes [] stk.pop(); // return -1 --&gt; Stack is empty return -1. &nbsp; Constraints: 1 &lt;= maxSize, x, k &lt;= 1000 0 &lt;= val &lt;= 100 At most 1000 calls will be made to each method of increment, push and pop each separately."
    },
    {
      "number": 1382,
      "title": "Balance a Binary Search Tree",
      "titleSlug": "balance-a-binary-search-tree",
      "difficulty": "Medium",
      "tags": [
        "Divide and Conquer",
        "Greedy",
        "Tree",
        "Depth-First Search",
        "Binary Search Tree",
        "Binary Tree"
      ],
      "description": "Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them. A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1. &nbsp; Example 1: Input: root = [1,null,2,null,3,null,4,null,null] Output: [2,1,3,null,null,null,4] Explanation: This is not the only correct answer, [3,1,4,null,2] is also correct. Example 2: Input: root = [2,1,3] Output: [2,1,3] &nbsp; Constraints: The number of nodes in the tree is in the range [1, 104]. 1 &lt;= Node.val &lt;= 105"
    },
    {
      "number": 1383,
      "title": "Maximum Performance of a Team",
      "titleSlug": "maximum-performance-of-a-team",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Greedy",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "You are given two integers n and k and two integer arrays speed and efficiency both of length n. There are n engineers numbered from 1 to n. speed[i] and efficiency[i] represent the speed and efficiency of the ith engineer respectively. Choose at most k different engineers out of the n engineers to form a team with the maximum performance. The performance of a team is the sum of its engineers&#39; speeds multiplied by the minimum efficiency among its engineers. Return the maximum performance of this team. Since the answer can be a huge number, return it modulo 109 + 7. &nbsp; Example 1: Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2 Output: 60 Explanation: We have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) * min(4, 7) = 60. Example 2: Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3 Output: 68 Explanation: This is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) * min(5, 4, 7) = 68. Example 3: Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4 Output: 72 &nbsp; Constraints: 1 &lt;= k &lt;= n &lt;= 105 speed.length == n efficiency.length == n 1 &lt;= speed[i] &lt;= 105 1 &lt;= efficiency[i] &lt;= 108"
    },
    {
      "number": 1385,
      "title": "Find the Distance Value Between Two Arrays",
      "titleSlug": "find-the-distance-value-between-two-arrays",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Two Pointers",
        "Binary Search",
        "Sorting"
      ],
      "description": "Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays. The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| &lt;= d. &nbsp; Example 1: Input: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2 Output: 2 Explanation: For arr1[0]=4 we have: |4-10|=6 &gt; d=2 |4-9|=5 &gt; d=2 |4-1|=3 &gt; d=2 |4-8|=4 &gt; d=2 For arr1[1]=5 we have: |5-10|=5 &gt; d=2 |5-9|=4 &gt; d=2 |5-1|=4 &gt; d=2 |5-8|=3 &gt; d=2 For arr1[2]=8 we have: |8-10|=2 &lt;= d=2 |8-9|=1 &lt;= d=2 |8-1|=7 &gt; d=2 |8-8|=0 &lt;= d=2 Example 2: Input: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3 Output: 2 Example 3: Input: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6 Output: 1 &nbsp; Constraints: 1 &lt;= arr1.length, arr2.length &lt;= 500 -1000 &lt;= arr1[i], arr2[j] &lt;= 1000 0 &lt;= d &lt;= 100"
    },
    {
      "number": 1386,
      "title": "Cinema Seat Allocation",
      "titleSlug": "cinema-seat-allocation",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Greedy",
        "Bit Manipulation"
      ],
      "description": "A cinema&nbsp;has n&nbsp;rows of seats, numbered from 1 to n&nbsp;and there are ten&nbsp;seats in each row, labelled from 1&nbsp;to 10&nbsp;as shown in the figure above. Given the array reservedSeats containing the numbers of seats already reserved, for example, reservedSeats[i] = [3,8]&nbsp;means the seat located in row 3 and labelled with 8&nbsp;is already reserved. Return the maximum number of four-person groups&nbsp;you can assign on the cinema&nbsp;seats. A four-person group&nbsp;occupies four&nbsp;adjacent seats in one single row. Seats across an aisle (such as [3,3]&nbsp;and [3,4]) are not considered to be adjacent, but there is an exceptional case&nbsp;on which an aisle split&nbsp;a four-person group, in that case, the aisle split&nbsp;a four-person group in the middle,&nbsp;which means to have two people on each side. &nbsp; Example 1: Input: n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]] Output: 4 Explanation: The figure above shows the optimal allocation for four groups, where seats mark with blue are already reserved and contiguous seats mark with orange are for one group. Example 2: Input: n = 2, reservedSeats = [[2,1],[1,8],[2,6]] Output: 2 Example 3: Input: n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]] Output: 4 &nbsp; Constraints: 1 &lt;= n &lt;= 10^9 1 &lt;=&nbsp;reservedSeats.length &lt;= min(10*n, 10^4) reservedSeats[i].length == 2 1&nbsp;&lt;=&nbsp;reservedSeats[i][0] &lt;= n 1 &lt;=&nbsp;reservedSeats[i][1] &lt;= 10 All reservedSeats[i] are distinct."
    },
    {
      "number": 1387,
      "title": "Sort Integers by The Power Value",
      "titleSlug": "sort-integers-by-the-power-value",
      "difficulty": "Medium",
      "tags": [
        "Dynamic Programming",
        "Memoization",
        "Sorting"
      ],
      "description": "The power of an integer x is defined as the number of steps needed to transform x into 1 using the following steps: if x is even then x = x / 2 if x is odd then x = 3 * x + 1 For example, the power of x = 3 is 7 because 3 needs 7 steps to become 1 (3 --&gt; 10 --&gt; 5 --&gt; 16 --&gt; 8 --&gt; 4 --&gt; 2 --&gt; 1). Given three integers lo, hi and k. The task is to sort all integers in the interval [lo, hi] by the power value in ascending order, if two or more integers have the same power value sort them by ascending order. Return the kth integer in the range [lo, hi] sorted by the power value. Notice that for any integer x (lo &lt;= x &lt;= hi) it is guaranteed that x will transform into 1 using these steps and that the power of x is will fit in a 32-bit signed integer. &nbsp; Example 1: Input: lo = 12, hi = 15, k = 2 Output: 13 Explanation: The power of 12 is 9 (12 --&gt; 6 --&gt; 3 --&gt; 10 --&gt; 5 --&gt; 16 --&gt; 8 --&gt; 4 --&gt; 2 --&gt; 1) The power of 13 is 9 The power of 14 is 17 The power of 15 is 17 The interval sorted by the power value [12,13,14,15]. For k = 2 answer is the second element which is 13. Notice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15. Example 2: Input: lo = 7, hi = 11, k = 4 Output: 7 Explanation: The power array corresponding to the interval [7, 8, 9, 10, 11] is [16, 3, 19, 6, 14]. The interval sorted by power is [8, 10, 11, 7, 9]. The fourth number in the sorted array is 7. &nbsp; Constraints: 1 &lt;= lo &lt;= hi &lt;= 1000 1 &lt;= k &lt;= hi - lo + 1"
    },
    {
      "number": 1388,
      "title": "Pizza With 3n Slices",
      "titleSlug": "pizza-with-3n-slices",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Greedy",
        "Heap (Priority Queue)"
      ],
      "description": "There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows: You will pick any pizza slice. Your friend Alice will pick the next slice in the anti-clockwise direction of your pick. Your friend Bob will pick the next slice in the clockwise direction of your pick. Repeat until there are no more slices of pizzas. Given an integer array slices that represent the sizes of the pizza slices in a clockwise direction, return the maximum possible sum of slice sizes that you can pick. &nbsp; Example 1: Input: slices = [1,2,3,4,5,6] Output: 10 Explanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6. Example 2: Input: slices = [8,9,8,6,1,1] Output: 16 Explanation: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8. &nbsp; Constraints: 3 * n == slices.length 1 &lt;= slices.length &lt;= 500 1 &lt;= slices[i] &lt;= 1000"
    },
    {
      "number": 1389,
      "title": "Create Target Array in the Given Order",
      "titleSlug": "create-target-array-in-the-given-order",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Simulation"
      ],
      "description": "Given two arrays of integers&nbsp;nums and index. Your task is to create target array under the following rules: Initially target array is empty. From left to right read nums[i] and index[i], insert at index index[i]&nbsp;the value nums[i]&nbsp;in&nbsp;target array. Repeat the previous step until there are no elements to read in nums and index. Return the target array. It is guaranteed that the insertion operations will be valid. &nbsp; Example 1: Input: nums = [0,1,2,3,4], index = [0,1,2,2,1] Output: [0,4,1,3,2] Explanation: nums index target 0 0 [0] 1 1 [0,1] 2 2 [0,1,2] 3 2 [0,1,3,2] 4 1 [0,4,1,3,2] Example 2: Input: nums = [1,2,3,4,0], index = [0,1,2,3,0] Output: [0,1,2,3,4] Explanation: nums index target 1 0 [1] 2 1 [1,2] 3 2 [1,2,3] 4 3 [1,2,3,4] 0 0 [0,1,2,3,4] Example 3: Input: nums = [1], index = [0] Output: [1] &nbsp; Constraints: 1 &lt;= nums.length, index.length &lt;= 100 nums.length == index.length 0 &lt;= nums[i] &lt;= 100 0 &lt;= index[i] &lt;= i"
    },
    {
      "number": 1390,
      "title": "Four Divisors",
      "titleSlug": "four-divisors",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Math"
      ],
      "description": "Given an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors. If there is no such integer in the array, return 0. &nbsp; Example 1: Input: nums = [21,4,7] Output: 32 Explanation: 21 has 4 divisors: 1, 3, 7, 21 4 has 3 divisors: 1, 2, 4 7 has 2 divisors: 1, 7 The answer is the sum of divisors of 21 only. Example 2: Input: nums = [21,21] Output: 64 Example 3: Input: nums = [1,2,3,4,5] Output: 0 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 104 1 &lt;= nums[i] &lt;= 105"
    },
    {
      "number": 1391,
      "title": "Check if There is a Valid Path in a Grid",
      "titleSlug": "check-if-there-is-a-valid-path-in-a-grid",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Depth-First Search",
        "Breadth-First Search",
        "Union Find",
        "Matrix"
      ],
      "description": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be: 1 which means a street connecting the left cell and the right cell. 2 which means a street connecting the upper cell and the lower cell. 3 which means a street connecting the left cell and the lower cell. 4 which means a street connecting the right cell and the lower cell. 5 which means a street connecting the left cell and the upper cell. 6 which means a street connecting the right cell and the upper cell. You will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets. Notice that you are not allowed to change any street. Return true if there is a valid path in the grid or false otherwise. &nbsp; Example 1: Input: grid = [[2,4,3],[6,5,2]] Output: true Explanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1). Example 2: Input: grid = [[1,2,1],[1,2,1]] Output: false Explanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0) Example 3: Input: grid = [[1,1,2]] Output: false Explanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2). &nbsp; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 300 1 &lt;= grid[i][j] &lt;= 6"
    },
    {
      "number": 1392,
      "title": "Longest Happy Prefix",
      "titleSlug": "longest-happy-prefix",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Rolling Hash",
        "String Matching",
        "Hash Function"
      ],
      "description": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself). Given a string s, return the longest happy prefix of s. Return an empty string &quot;&quot; if no such prefix exists. &nbsp; Example 1: Input: s = &quot;level&quot; Output: &quot;l&quot; Explanation: s contains 4 prefix excluding itself (&quot;l&quot;, &quot;le&quot;, &quot;lev&quot;, &quot;leve&quot;), and suffix (&quot;l&quot;, &quot;el&quot;, &quot;vel&quot;, &quot;evel&quot;). The largest prefix which is also suffix is given by &quot;l&quot;. Example 2: Input: s = &quot;ababab&quot; Output: &quot;abab&quot; Explanation: &quot;abab&quot; is the largest prefix which is also suffix. They can overlap in the original string. &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s contains only lowercase English letters."
    },
    {
      "number": 1393,
      "title": "Capital Gain/Loss",
      "titleSlug": "capital-gainloss",
      "difficulty": "Medium",
      "tags": [
        "Database"
      ],
      "description": "Table: Stocks +---------------+---------+ | Column Name | Type | +---------------+---------+ | stock_name | varchar | | operation | enum | | operation_day | int | | price | int | +---------------+---------+ (stock_name, operation_day) is the primary key (combination of columns with unique values) for this table. The operation column is an ENUM (category) of type (&#39;Sell&#39;, &#39;Buy&#39;) Each row of this table indicates that the stock which has stock_name had an operation on the day operation_day with the price. It is guaranteed that each &#39;Sell&#39; operation for a stock has a corresponding &#39;Buy&#39; operation in a previous day. It is also guaranteed that each &#39;Buy&#39; operation for a stock has a corresponding &#39;Sell&#39; operation in an upcoming day. &nbsp; Write a solution to report the Capital gain/loss for each stock. The Capital gain/loss of a stock is the total gain or loss after buying and selling the stock one or many times. Return the result table in any order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Stocks table: +---------------+-----------+---------------+--------+ | stock_name | operation | operation_day | price | +---------------+-----------+---------------+--------+ | Leetcode | Buy | 1 | 1000 | | Corona Masks | Buy | 2 | 10 | | Leetcode | Sell | 5 | 9000 | | Handbags | Buy | 17 | 30000 | | Corona Masks | Sell | 3 | 1010 | | Corona Masks | Buy | 4 | 1000 | | Corona Masks | Sell | 5 | 500 | | Corona Masks | Buy | 6 | 1000 | | Handbags | Sell | 29 | 7000 | | Corona Masks | Sell | 10 | 10000 | +---------------+-----------+---------------+--------+ Output: +---------------+-------------------+ | stock_name | capital_gain_loss | +---------------+-------------------+ | Corona Masks | 9500 | | Leetcode | 8000 | | Handbags | -23000 | +---------------+-------------------+ Explanation: Leetcode stock was bought at day 1 for 1000$ and was sold at day 5 for 9000$. Capital gain = 9000 - 1000 = 8000$. Handbags stock was bought at day 17 for 30000$ and was sold at day 29 for 7000$. Capital loss = 7000 - 30000 = -23000$. Corona Masks stock was bought at day 1 for 10$ and was sold at day 3 for 1010$. It was bought again at day 4 for 1000$ and was sold at day 5 for 500$. At last, it was bought at day 6 for 1000$ and was sold at day 10 for 10000$. Capital gain/loss is the sum of capital gains/losses for each (&#39;Buy&#39; --&gt; &#39;Sell&#39;) operation = (1010 - 10) + (500 - 1000) + (10000 - 1000) = 1000 - 500 + 9000 = 9500$."
    },
    {
      "number": 1394,
      "title": "Find Lucky Integer in an Array",
      "titleSlug": "find-lucky-integer-in-an-array",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Counting"
      ],
      "description": "Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value. Return the largest lucky integer in the array. If there is no lucky integer return -1. &nbsp; Example 1: Input: arr = [2,2,3,4] Output: 2 Explanation: The only lucky number in the array is 2 because frequency[2] == 2. Example 2: Input: arr = [1,2,2,3,3,3] Output: 3 Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them. Example 3: Input: arr = [2,2,2,3,3] Output: -1 Explanation: There are no lucky numbers in the array. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 500 1 &lt;= arr[i] &lt;= 500"
    },
    {
      "number": 1395,
      "title": "Count Number of Teams",
      "titleSlug": "count-number-of-teams",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Binary Indexed Tree",
        "Segment Tree"
      ],
      "description": "There are n soldiers standing in a line. Each soldier is assigned a unique rating value. You have to form a team of 3 soldiers amongst them under the following rules: Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]). A team is valid if: (rating[i] &lt; rating[j] &lt; rating[k]) or (rating[i] &gt; rating[j] &gt; rating[k]) where (0 &lt;= i &lt; j &lt; k &lt; n). Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams). &nbsp; Example 1: Input: rating = [2,5,3,4,1] Output: 3 Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). Example 2: Input: rating = [2,1,3] Output: 0 Explanation: We can&#39;t form any team given the conditions. Example 3: Input: rating = [1,2,3,4] Output: 4 &nbsp; Constraints: n == rating.length 3 &lt;= n &lt;= 1000 1 &lt;= rating[i] &lt;= 105 All the integers in rating are unique."
    },
    {
      "number": 1396,
      "title": "Design Underground System",
      "titleSlug": "design-underground-system",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Design"
      ],
      "description": "An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another. Implement the UndergroundSystem class: void checkIn(int id, string stationName, int t) A customer with a card ID equal to id, checks in at the station stationName at time t. A customer can only be checked into one place at a time. void checkOut(int id, string stationName, int t) A customer with a card ID equal to id, checks out from the station stationName at time t. double getAverageTime(string startStation, string endStation) Returns the average time it takes to travel from startStation to endStation. The average time is computed from all the previous traveling times from startStation to endStation that happened directly, meaning a check in at startStation followed by a check out from endStation. The time it takes to travel from startStation to endStation may be different from the time it takes to travel from endStation to startStation. There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called. You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 &lt; t2. All events happen in chronological order. &nbsp; Example 1: Input [&quot;UndergroundSystem&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;getAverageTime&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;] [[],[45,&quot;Leyton&quot;,3],[32,&quot;Paradise&quot;,8],[27,&quot;Leyton&quot;,10],[45,&quot;Waterloo&quot;,15],[27,&quot;Waterloo&quot;,20],[32,&quot;Cambridge&quot;,22],[&quot;Paradise&quot;,&quot;Cambridge&quot;],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Leyton&quot;,24],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Waterloo&quot;,38],[&quot;Leyton&quot;,&quot;Waterloo&quot;]] Output [null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000] Explanation UndergroundSystem undergroundSystem = new UndergroundSystem(); undergroundSystem.checkIn(45, &quot;Leyton&quot;, 3); undergroundSystem.checkIn(32, &quot;Paradise&quot;, 8); undergroundSystem.checkIn(27, &quot;Leyton&quot;, 10); undergroundSystem.checkOut(45, &quot;Waterloo&quot;, 15); // Customer 45 &quot;Leyton&quot; -&gt; &quot;Waterloo&quot; in 15-3 = 12 undergroundSystem.checkOut(27, &quot;Waterloo&quot;, 20); // Customer 27 &quot;Leyton&quot; -&gt; &quot;Waterloo&quot; in 20-10 = 10 undergroundSystem.checkOut(32, &quot;Cambridge&quot;, 22); // Customer 32 &quot;Paradise&quot; -&gt; &quot;Cambridge&quot; in 22-8 = 14 undergroundSystem.getAverageTime(&quot;Paradise&quot;, &quot;Cambridge&quot;); // return 14.00000. One trip &quot;Paradise&quot; -&gt; &quot;Cambridge&quot;, (14) / 1 = 14 undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;); // return 11.00000. Two trips &quot;Leyton&quot; -&gt; &quot;Waterloo&quot;, (10 + 12) / 2 = 11 undergroundSystem.checkIn(10, &quot;Leyton&quot;, 24); undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;); // return 11.00000 undergroundSystem.checkOut(10, &quot;Waterloo&quot;, 38); // Customer 10 &quot;Leyton&quot; -&gt; &quot;Waterloo&quot; in 38-24 = 14 undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;); // return 12.00000. Three trips &quot;Leyton&quot; -&gt; &quot;Waterloo&quot;, (10 + 12 + 14) / 3 = 12 Example 2: Input [&quot;UndergroundSystem&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;] [[],[10,&quot;Leyton&quot;,3],[10,&quot;Paradise&quot;,8],[&quot;Leyton&quot;,&quot;Paradise&quot;],[5,&quot;Leyton&quot;,10],[5,&quot;Paradise&quot;,16],[&quot;Leyton&quot;,&quot;Paradise&quot;],[2,&quot;Leyton&quot;,21],[2,&quot;Paradise&quot;,30],[&quot;Leyton&quot;,&quot;Paradise&quot;]] Output [null,null,null,5.00000,null,null,5.50000,null,null,6.66667] Explanation UndergroundSystem undergroundSystem = new UndergroundSystem(); undergroundSystem.checkIn(10, &quot;Leyton&quot;, 3); undergroundSystem.checkOut(10, &quot;Paradise&quot;, 8); // Customer 10 &quot;Leyton&quot; -&gt; &quot;Paradise&quot; in 8-3 = 5 undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Paradise&quot;); // return 5.00000, (5) / 1 = 5 undergroundSystem.checkIn(5, &quot;Leyton&quot;, 10); undergroundSystem.checkOut(5, &quot;Paradise&quot;, 16); // Customer 5 &quot;Leyton&quot; -&gt; &quot;Paradise&quot; in 16-10 = 6 undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Paradise&quot;); // return 5.50000, (5 + 6) / 2 = 5.5 undergroundSystem.checkIn(2, &quot;Leyton&quot;, 21); undergroundSystem.checkOut(2, &quot;Paradise&quot;, 30); // Customer 2 &quot;Leyton&quot; -&gt; &quot;Paradise&quot; in 30-21 = 9 undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Paradise&quot;); // return 6.66667, (5 + 6 + 9) / 3 = 6.66667 &nbsp; Constraints: 1 &lt;= id, t &lt;= 106 1 &lt;= stationName.length, startStation.length, endStation.length &lt;= 10 All strings consist of uppercase and lowercase English letters and digits. There will be at most 2 * 104 calls in total to checkIn, checkOut, and getAverageTime. Answers within 10-5 of the actual value will be accepted."
    },
    {
      "number": 1397,
      "title": "Find All Good Strings",
      "titleSlug": "find-all-good-strings",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming",
        "String Matching"
      ],
      "description": "Given the strings s1 and s2 of size n and the string evil, return the number of good strings. A good string has size n, it is alphabetically greater than or equal to s1, it is alphabetically smaller than or equal to s2, and it does not contain the string evil as a substring. Since the answer can be a huge number, return this modulo 109 + 7. &nbsp; Example 1: Input: n = 2, s1 = &quot;aa&quot;, s2 = &quot;da&quot;, evil = &quot;b&quot; Output: 51 Explanation: There are 25 good strings starting with &#39;a&#39;: &quot;aa&quot;,&quot;ac&quot;,&quot;ad&quot;,...,&quot;az&quot;. Then there are 25 good strings starting with &#39;c&#39;: &quot;ca&quot;,&quot;cc&quot;,&quot;cd&quot;,...,&quot;cz&quot; and finally there is one good string starting with &#39;d&#39;: &quot;da&quot;.&nbsp; Example 2: Input: n = 8, s1 = &quot;leetcode&quot;, s2 = &quot;leetgoes&quot;, evil = &quot;leet&quot; Output: 0 Explanation: All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix &quot;leet&quot;, therefore, there is not any good string. Example 3: Input: n = 2, s1 = &quot;gx&quot;, s2 = &quot;gz&quot;, evil = &quot;x&quot; Output: 2 &nbsp; Constraints: s1.length == n s2.length == n s1 &lt;= s2 1 &lt;= n &lt;= 500 1 &lt;= evil.length &lt;= 50 All strings consist of lowercase English letters."
    },
    {
      "number": 1399,
      "title": "Count Largest Group",
      "titleSlug": "count-largest-group",
      "difficulty": "Easy",
      "tags": [
        "Hash Table",
        "Math"
      ],
      "description": "You are given an integer n. We need to group the numbers from 1 to n according to the sum of its digits. For example, the numbers 14 and 5 belong to the same group, whereas 13 and 3 belong to different groups. Return the number of groups that have the largest size, i.e. the maximum number of elements. &nbsp; Example 1: Input: n = 13 Output: 4 Explanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13: [1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9]. There are 4 groups with largest size. Example 2: Input: n = 2 Output: 2 Explanation: There are 2 groups [1], [2] of size 1. &nbsp; Constraints: 1 &lt;= n &lt;= 104"
    },
    {
      "number": 1400,
      "title": "Construct K Palindrome Strings",
      "titleSlug": "construct-k-palindrome-strings",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Greedy",
        "Counting"
      ],
      "description": "Given a string s and an integer k, return true if you can use all the characters in s to construct non-empty k palindrome strings or false otherwise. &nbsp; Example 1: Input: s = &quot;annabelle&quot;, k = 2 Output: true Explanation: You can construct two palindromes using all characters in s. Some possible constructions &quot;anna&quot; + &quot;elble&quot;, &quot;anbna&quot; + &quot;elle&quot;, &quot;anellena&quot; + &quot;b&quot; Example 2: Input: s = &quot;leetcode&quot;, k = 3 Output: false Explanation: It is impossible to construct 3 palindromes using all the characters of s. Example 3: Input: s = &quot;true&quot;, k = 4 Output: true Explanation: The only possible solution is to put each character in a separate string. &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s consists of lowercase English letters. 1 &lt;= k &lt;= 105"
    },
    {
      "number": 1401,
      "title": "Circle and Rectangle Overlapping",
      "titleSlug": "circle-and-rectangle-overlapping",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Geometry"
      ],
      "description": "You are given a circle represented as (radius, xCenter, yCenter) and an axis-aligned rectangle represented as (x1, y1, x2, y2), where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the rectangle. Return true if the circle and rectangle are overlapped otherwise return false. In other words, check if there is any point (xi, yi) that belongs to the circle and the rectangle at the same time. &nbsp; Example 1: Input: radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1 Output: true Explanation: Circle and rectangle share the point (1,0). Example 2: Input: radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1 Output: false Example 3: Input: radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1 Output: true &nbsp; Constraints: 1 &lt;= radius &lt;= 2000 -104 &lt;= xCenter, yCenter &lt;= 104 -104 &lt;= x1 &lt; x2 &lt;= 104 -104 &lt;= y1 &lt; y2 &lt;= 104"
    },
    {
      "number": 1402,
      "title": "Reducing Dishes",
      "titleSlug": "reducing-dishes",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Greedy",
        "Sorting"
      ],
      "description": "A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 unit of time. Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. time[i] * satisfaction[i]. Return the maximum sum of like-time coefficient that the chef can obtain after preparing some amount of dishes. Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value. &nbsp; Example 1: Input: satisfaction = [-1,-8,0,5,-9] Output: 14 Explanation: After Removing the second and last dish, the maximum total like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time. Example 2: Input: satisfaction = [4,3,2] Output: 20 Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20) Example 3: Input: satisfaction = [-1,-4,-5] Output: 0 Explanation: People do not like the dishes. No dish is prepared. &nbsp; Constraints: n == satisfaction.length 1 &lt;= n &lt;= 500 -1000 &lt;= satisfaction[i] &lt;= 1000"
    },
    {
      "number": 1403,
      "title": "Minimum Subsequence in Non-Increasing Order",
      "titleSlug": "minimum-subsequence-in-non-increasing-order",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Greedy",
        "Sorting"
      ],
      "description": "Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non&nbsp;included elements in such subsequence.&nbsp; If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.&nbsp; Note that the solution with the given constraints is guaranteed to be&nbsp;unique. Also return the answer sorted in non-increasing order. &nbsp; Example 1: Input: nums = [4,3,10,9,8] Output: [10,9] Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements.&nbsp; Example 2: Input: nums = [4,4,7,6,7] Output: [7,7,6] Explanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-increasing order. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 100"
    },
    {
      "number": 1404,
      "title": "Number of Steps to Reduce a Number in Binary Representation to One",
      "titleSlug": "number-of-steps-to-reduce-a-number-in-binary-representation-to-one",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Bit Manipulation",
        "Simulation"
      ],
      "description": "Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules: If the current number is even, you have to divide it by 2. If the current number is odd, you have to add 1 to it. It is guaranteed that you can always reach one for all test cases. &nbsp; Example 1: Input: s = &quot;1101&quot; Output: 6 Explanation: &quot;1101&quot; corressponds to number 13 in their decimal representation. Step 1) 13 is odd, add 1 and obtain 14.&nbsp; Step 2) 14 is even, divide by 2 and obtain 7. Step 3) 7 is odd, add 1 and obtain 8. Step 4) 8 is even, divide by 2 and obtain 4.&nbsp; Step 5) 4 is even, divide by 2 and obtain 2.&nbsp; Step 6) 2 is even, divide by 2 and obtain 1.&nbsp; Example 2: Input: s = &quot;10&quot; Output: 1 Explanation: &quot;10&quot; corresponds to number 2 in their decimal representation. Step 1) 2 is even, divide by 2 and obtain 1.&nbsp; Example 3: Input: s = &quot;1&quot; Output: 0 &nbsp; Constraints: 1 &lt;= s.length&nbsp;&lt;= 500 s consists of characters &#39;0&#39; or &#39;1&#39; s[0] == &#39;1&#39;"
    },
    {
      "number": 1405,
      "title": "Longest Happy String",
      "titleSlug": "longest-happy-string",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Greedy",
        "Heap (Priority Queue)"
      ],
      "description": "A string s is called happy if it satisfies the following conditions: s only contains the letters &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;. s does not contain any of &quot;aaa&quot;, &quot;bbb&quot;, or &quot;ccc&quot; as a substring. s contains at most a occurrences of the letter &#39;a&#39;. s contains at most b occurrences of the letter &#39;b&#39;. s contains at most c occurrences of the letter &#39;c&#39;. Given three integers a, b, and c, return the longest possible happy string. If there are multiple longest happy strings, return any of them. If there is no such string, return the empty string &quot;&quot;. A substring is a contiguous sequence of characters within a string. &nbsp; Example 1: Input: a = 1, b = 1, c = 7 Output: &quot;ccaccbcc&quot; Explanation: &quot;ccbccacc&quot; would also be a correct answer. Example 2: Input: a = 7, b = 1, c = 0 Output: &quot;aabaa&quot; Explanation: It is the only correct answer in this case. &nbsp; Constraints: 0 &lt;= a, b, c &lt;= 100 a + b + c &gt; 0"
    },
    {
      "number": 1406,
      "title": "Stone Game III",
      "titleSlug": "stone-game-iii",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Dynamic Programming",
        "Game Theory"
      ],
      "description": "Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue. Alice and Bob take turns, with Alice starting first. On each player&#39;s turn, that player can take 1, 2, or 3 stones from the first remaining stones in the row. The score of each player is the sum of the values of the stones taken. The score of each player is 0 initially. The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken. Assume Alice and Bob play optimally. Return &quot;Alice&quot; if Alice will win, &quot;Bob&quot; if Bob will win, or &quot;Tie&quot; if they will end the game with the same score. &nbsp; Example 1: Input: stoneValue = [1,2,3,7] Output: &quot;Bob&quot; Explanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins. Example 2: Input: stoneValue = [1,2,3,-9] Output: &quot;Alice&quot; Explanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score. If Alice chooses one pile her score will be 1 and the next move Bob&#39;s score becomes 5. In the next move, Alice will take the pile with value = -9 and lose. If Alice chooses two piles her score will be 3 and the next move Bob&#39;s score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose. Remember that both play optimally so here Alice will choose the scenario that makes her win. Example 3: Input: stoneValue = [1,2,3,6] Output: &quot;Tie&quot; Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose. &nbsp; Constraints: 1 &lt;= stoneValue.length &lt;= 5 * 104 -1000 &lt;= stoneValue[i] &lt;= 1000"
    },
    {
      "number": 1407,
      "title": "Top Travellers",
      "titleSlug": "top-travellers",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table: Users +---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | name | varchar | +---------------+---------+ id is the column with unique values for this table. name is the name of the user. &nbsp; Table: Rides +---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | user_id | int | | distance | int | +---------------+---------+ id is the column with unique values for this table. user_id is the id of the user who traveled the distance &quot;distance&quot;. &nbsp; Write a solution&nbsp;to report the distance traveled by each user. Return the result table ordered by travelled_distance in descending order, if two or more users traveled the same distance, order them by their name in ascending order. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Users table: +------+-----------+ | id | name | +------+-----------+ | 1 | Alice | | 2 | Bob | | 3 | Alex | | 4 | Donald | | 7 | Lee | | 13 | Jonathan | | 19 | Elvis | +------+-----------+ Rides table: +------+----------+----------+ | id | user_id | distance | +------+----------+----------+ | 1 | 1 | 120 | | 2 | 2 | 317 | | 3 | 3 | 222 | | 4 | 7 | 100 | | 5 | 13 | 312 | | 6 | 19 | 50 | | 7 | 7 | 120 | | 8 | 19 | 400 | | 9 | 7 | 230 | +------+----------+----------+ Output: +----------+--------------------+ | name | travelled_distance | +----------+--------------------+ | Elvis | 450 | | Lee | 450 | | Bob | 317 | | Jonathan | 312 | | Alex | 222 | | Alice | 120 | | Donald | 0 | +----------+--------------------+ Explanation: Elvis and Lee traveled 450 miles, Elvis is the top traveler as his name is alphabetically smaller than Lee. Bob, Jonathan, Alex, and Alice have only one ride and we just order them by the total distances of the ride. Donald did not have any rides, the distance traveled by him is 0."
    },
    {
      "number": 1408,
      "title": "String Matching in an Array",
      "titleSlug": "string-matching-in-an-array",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "String",
        "String Matching"
      ],
      "description": "Given an array of string words, return all strings in words that are a substring of another word. You can return the answer in any order. &nbsp; Example 1: Input: words = [&quot;mass&quot;,&quot;as&quot;,&quot;hero&quot;,&quot;superhero&quot;] Output: [&quot;as&quot;,&quot;hero&quot;] Explanation: &quot;as&quot; is substring of &quot;mass&quot; and &quot;hero&quot; is substring of &quot;superhero&quot;. [&quot;hero&quot;,&quot;as&quot;] is also a valid answer. Example 2: Input: words = [&quot;leetcode&quot;,&quot;et&quot;,&quot;code&quot;] Output: [&quot;et&quot;,&quot;code&quot;] Explanation: &quot;et&quot;, &quot;code&quot; are substring of &quot;leetcode&quot;. Example 3: Input: words = [&quot;blue&quot;,&quot;green&quot;,&quot;bu&quot;] Output: [] Explanation: No string of words is substring of another string. &nbsp; Constraints: 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 30 words[i] contains only lowercase English letters. All the strings of words are unique."
    },
    {
      "number": 1409,
      "title": "Queries on a Permutation With Key",
      "titleSlug": "queries-on-a-permutation-with-key",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Indexed Tree",
        "Simulation"
      ],
      "description": "Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules: In the beginning, you have the permutation P=[1,2,3,...,m]. For the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i]. Return an array containing the result for the given queries. &nbsp; Example 1: Input: queries = [3,1,2,1], m = 5 Output: [2,1,2,1] Explanation: The queries are processed as follow: For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. Therefore, the array containing the result is [2,1,2,1]. Example 2: Input: queries = [4,1,2,2], m = 4 Output: [3,1,2,0] Example 3: Input: queries = [7,5,5,8,3], m = 8 Output: [6,5,0,7,5] &nbsp; Constraints: 1 &lt;= m &lt;= 10^3 1 &lt;= queries.length &lt;= m 1 &lt;= queries[i] &lt;= m"
    },
    {
      "number": 1410,
      "title": "HTML Entity Parser",
      "titleSlug": "html-entity-parser",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String"
      ],
      "description": "HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself. The special characters and their entities for HTML are: Quotation Mark: the entity is &amp;quot; and symbol character is &quot;. Single Quote Mark: the entity is &amp;apos; and symbol character is &#39;. Ampersand: the entity is &amp;amp; and symbol character is &amp;. Greater Than Sign: the entity is &amp;gt; and symbol character is &gt;. Less Than Sign: the entity is &amp;lt; and symbol character is &lt;. Slash: the entity is &amp;frasl; and symbol character is /. Given the input text string to the HTML parser, you have to implement the entity parser. Return the text after replacing the entities by the special characters. &nbsp; Example 1: Input: text = &quot;&amp;amp; is an HTML entity but &amp;ambassador; is not.&quot; Output: &quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot; Explanation: The parser will replace the &amp;amp; entity by &amp; Example 2: Input: text = &quot;and I quote: &amp;quot;...&amp;quot;&quot; Output: &quot;and I quote: \\&quot;...\\&quot;&quot; &nbsp; Constraints: 1 &lt;= text.length &lt;= 105 The string may contain any possible characters out of all the 256 ASCII characters."
    },
    {
      "number": 1411,
      "title": "Number of Ways to Paint N  3 Grid",
      "titleSlug": "number-of-ways-to-paint-n-3-grid",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming"
      ],
      "description": "You have a grid of size n x 3 and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, or Green while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color). Given n the number of rows of the grid, return the number of ways you can paint this grid. As the answer may grow large, the answer must be computed modulo 109 + 7. &nbsp; Example 1: Input: n = 1 Output: 12 Explanation: There are 12 possible way to paint the grid as shown. Example 2: Input: n = 5000 Output: 30228214 &nbsp; Constraints: n == grid.length 1 &lt;= n &lt;= 5000"
    },
    {
      "number": 1413,
      "title": "Minimum Value to Get Positive Step by Step Sum",
      "titleSlug": "minimum-value-to-get-positive-step-by-step-sum",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Prefix Sum"
      ],
      "description": "Given an array of integers&nbsp;nums, you start with an initial positive value startValue. In each iteration, you calculate the step by step sum of startValue&nbsp;plus&nbsp;elements in nums&nbsp;(from left to right). Return the minimum positive value of&nbsp;startValue such that the step by step sum is never less than 1. &nbsp; Example 1: Input: nums = [-3,2,-3,4,2] Output: 5 Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1. step by step sum startValue = 4 | startValue = 5 | nums (4 -3 ) = 1 | (5 -3 ) = 2 | -3 (1 +2 ) = 3 | (2 +2 ) = 4 | 2 (3 -3 ) = 0 | (4 -3 ) = 1 | -3 (0 +4 ) = 4 | (1 +4 ) = 5 | 4 (4 +2 ) = 6 | (5 +2 ) = 7 | 2 Example 2: Input: nums = [1,2] Output: 1 Explanation: Minimum start value should be positive. Example 3: Input: nums = [1,-2,-3] Output: 5 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 100 -100 &lt;= nums[i] &lt;= 100"
    },
    {
      "number": 1414,
      "title": "Find the Minimum Number of Fibonacci Numbers Whose Sum Is K",
      "titleSlug": "find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Greedy"
      ],
      "description": "Given an integer&nbsp;k, return the minimum number of Fibonacci numbers whose sum is equal to k. The same Fibonacci number can be used multiple times. The Fibonacci numbers are defined as: F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2 for n &gt; 2. It is guaranteed that for the given constraints we can always find such Fibonacci numbers that sum up to k. &nbsp; Example 1: Input: k = 7 Output: 2 Explanation: The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ... For k = 7 we can use 2 + 5 = 7. Example 2: Input: k = 10 Output: 2 Explanation: For k = 10 we can use 2 + 8 = 10. Example 3: Input: k = 19 Output: 3 Explanation: For k = 19 we can use 1 + 5 + 13 = 19. &nbsp; Constraints: 1 &lt;= k &lt;= 109"
    },
    {
      "number": 1415,
      "title": "The k-th Lexicographical String of All Happy Strings of Length n",
      "titleSlug": "the-k-th-lexicographical-string-of-all-happy-strings-of-length-n",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Backtracking"
      ],
      "description": "A happy string is a string that: consists only of letters of the set [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]. s[i] != s[i + 1] for all values of i from 1 to s.length - 1 (string is 1-indexed). For example, strings &quot;abc&quot;, &quot;ac&quot;, &quot;b&quot; and &quot;abcbabcbcb&quot; are all happy strings and strings &quot;aa&quot;, &quot;baa&quot; and &quot;ababbc&quot; are not happy strings. Given two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order. Return the kth string of this list or return an empty string if there are less than k happy strings of length n. &nbsp; Example 1: Input: n = 1, k = 3 Output: &quot;c&quot; Explanation: The list [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] contains all happy strings of length 1. The third string is &quot;c&quot;. Example 2: Input: n = 1, k = 4 Output: &quot;&quot; Explanation: There are only 3 happy strings of length 1. Example 3: Input: n = 3, k = 9 Output: &quot;cab&quot; Explanation: There are 12 different happy string of length 3 [&quot;aba&quot;, &quot;abc&quot;, &quot;aca&quot;, &quot;acb&quot;, &quot;bab&quot;, &quot;bac&quot;, &quot;bca&quot;, &quot;bcb&quot;, &quot;cab&quot;, &quot;cac&quot;, &quot;cba&quot;, &quot;cbc&quot;]. You will find the 9th string = &quot;cab&quot; &nbsp; Constraints: 1 &lt;= n &lt;= 10 1 &lt;= k &lt;= 100"
    },
    {
      "number": 1416,
      "title": "Restore The Array",
      "titleSlug": "restore-the-array",
      "difficulty": "Hard",
      "tags": [
        "String",
        "Dynamic Programming"
      ],
      "description": "A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array. Given the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7. &nbsp; Example 1: Input: s = &quot;1000&quot;, k = 10000 Output: 1 Explanation: The only possible array is [1000] Example 2: Input: s = &quot;1000&quot;, k = 10 Output: 0 Explanation: There cannot be an array that was printed this way and has all integer &gt;= 1 and &lt;= 10. Example 3: Input: s = &quot;1317&quot;, k = 2000 Output: 8 Explanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7] &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s consists of only digits and does not contain leading zeros. 1 &lt;= k &lt;= 109"
    },
    {
      "number": 1417,
      "title": "Reformat The String",
      "titleSlug": "reformat-the-string",
      "difficulty": "Easy",
      "tags": [
        "String"
      ],
      "description": "You are given an alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits). You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type. Return the reformatted string or return an empty string if it is impossible to reformat the string. &nbsp; Example 1: Input: s = &quot;a0b1c2&quot; Output: &quot;0a1b2c&quot; Explanation: No two adjacent characters have the same type in &quot;0a1b2c&quot;. &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; are also valid permutations. Example 2: Input: s = &quot;leetcode&quot; Output: &quot;&quot; Explanation: &quot;leetcode&quot; has only characters so we cannot separate them by digits. Example 3: Input: s = &quot;1229857369&quot; Output: &quot;&quot; Explanation: &quot;1229857369&quot; has only digits so we cannot separate them by characters. &nbsp; Constraints: 1 &lt;= s.length &lt;= 500 s consists of only lowercase English letters and/or digits."
    },
    {
      "number": 1418,
      "title": "Display Table of Food Orders in a Restaurant",
      "titleSlug": "display-table-of-food-orders-in-a-restaurant",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String",
        "Sorting",
        "Ordered Set"
      ],
      "description": "Given&nbsp;the array orders, which represents the orders that customers have done in a restaurant. More specifically&nbsp;orders[i]=[customerNamei,tableNumberi,foodItemi] where customerNamei is the name of the customer, tableNumberi&nbsp;is the table customer sit at, and foodItemi&nbsp;is the item customer orders. Return the restaurant&#39;s &ldquo;display table&rdquo;. The &ldquo;display table&rdquo; is a table whose row entries denote how many of each food item each table ordered. The first column is the table number and the remaining columns correspond to each food item in alphabetical order. The first row should be a header whose first column is &ldquo;Table&rdquo;, followed by the names of the food items. Note that the customer names are not part of the table. Additionally, the rows should be sorted in numerically increasing order. &nbsp; Example 1: Input: orders = [[&quot;David&quot;,&quot;3&quot;,&quot;Ceviche&quot;],[&quot;Corina&quot;,&quot;10&quot;,&quot;Beef Burrito&quot;],[&quot;David&quot;,&quot;3&quot;,&quot;Fried Chicken&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Water&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Ceviche&quot;],[&quot;Rous&quot;,&quot;3&quot;,&quot;Ceviche&quot;]] Output: [[&quot;Table&quot;,&quot;Beef Burrito&quot;,&quot;Ceviche&quot;,&quot;Fried Chicken&quot;,&quot;Water&quot;],[&quot;3&quot;,&quot;0&quot;,&quot;2&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;5&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;10&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]] Explanation: The displaying table looks like: Table,Beef Burrito,Ceviche,Fried Chicken,Water 3 ,0 ,2 ,1 ,0 5 ,0 ,1 ,0 ,1 10 ,1 ,0 ,0 ,0 For the table 3: David orders &quot;Ceviche&quot; and &quot;Fried Chicken&quot;, and Rous orders &quot;Ceviche&quot;. For the table 5: Carla orders &quot;Water&quot; and &quot;Ceviche&quot;. For the table 10: Corina orders &quot;Beef Burrito&quot;. Example 2: Input: orders = [[&quot;James&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Ratesh&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Amadeus&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Adam&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;],[&quot;Brianna&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;]] Output: [[&quot;Table&quot;,&quot;Canadian Waffles&quot;,&quot;Fried Chicken&quot;],[&quot;1&quot;,&quot;2&quot;,&quot;0&quot;],[&quot;12&quot;,&quot;0&quot;,&quot;3&quot;]] Explanation: For the table 1: Adam and Brianna order &quot;Canadian Waffles&quot;. For the table 12: James, Ratesh and Amadeus order &quot;Fried Chicken&quot;. Example 3: Input: orders = [[&quot;Laura&quot;,&quot;2&quot;,&quot;Bean Burrito&quot;],[&quot;Jhon&quot;,&quot;2&quot;,&quot;Beef Burrito&quot;],[&quot;Melissa&quot;,&quot;2&quot;,&quot;Soda&quot;]] Output: [[&quot;Table&quot;,&quot;Bean Burrito&quot;,&quot;Beef Burrito&quot;,&quot;Soda&quot;],[&quot;2&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]] &nbsp; Constraints: 1 &lt;=&nbsp;orders.length &lt;= 5 * 10^4 orders[i].length == 3 1 &lt;= customerNamei.length, foodItemi.length &lt;= 20 customerNamei and foodItemi consist of lowercase and uppercase English letters and the space character. tableNumberi&nbsp;is a valid integer between 1 and 500."
    },
    {
      "number": 1419,
      "title": "Minimum Number of Frogs Croaking",
      "titleSlug": "minimum-number-of-frogs-croaking",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Counting"
      ],
      "description": "You are given the string croakOfFrogs, which represents a combination of the string &quot;croak&quot; from different frogs, that is, multiple frogs can croak at the same time, so multiple &quot;croak&quot; are mixed. Return the minimum number of different frogs to finish all the croaks in the given string. A valid &quot;croak&quot; means a frog is printing five letters &#39;c&#39;, &#39;r&#39;, &#39;o&#39;, &#39;a&#39;, and &#39;k&#39; sequentially. The frogs have to print all five letters to finish a croak. If the given string is not a combination of a valid &quot;croak&quot; return -1. &nbsp; Example 1: Input: croakOfFrogs = &quot;croakcroak&quot; Output: 1 Explanation: One frog yelling &quot;croak&quot; twice. Example 2: Input: croakOfFrogs = &quot;crcoakroak&quot; Output: 2 Explanation: The minimum number of frogs is two. The first frog could yell &quot;crcoakroak&quot;. The second frog could yell later &quot;crcoakroak&quot;. Example 3: Input: croakOfFrogs = &quot;croakcrook&quot; Output: -1 Explanation: The given string is an invalid combination of &quot;croak&quot; from different frogs. &nbsp; Constraints: 1 &lt;= croakOfFrogs.length &lt;= 105 croakOfFrogs is either &#39;c&#39;, &#39;r&#39;, &#39;o&#39;, &#39;a&#39;, or &#39;k&#39;."
    },
    {
      "number": 1420,
      "title": "Build Array Where You Can Find The Maximum Exactly K Comparisons",
      "titleSlug": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming",
        "Prefix Sum"
      ],
      "description": "You are given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers: You should build the array arr which has the following properties: arr has exactly n integers. 1 &lt;= arr[i] &lt;= m where (0 &lt;= i &lt; n). After applying the mentioned algorithm to arr, the value search_cost is equal to k. Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 109 + 7. &nbsp; Example 1: Input: n = 2, m = 3, k = 1 Output: 6 Explanation: The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3] Example 2: Input: n = 5, m = 2, k = 3 Output: 0 Explanation: There are no possible arrays that satisfy the mentioned conditions. Example 3: Input: n = 9, m = 1, k = 1 Output: 1 Explanation: The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1] &nbsp; Constraints: 1 &lt;= n &lt;= 50 1 &lt;= m &lt;= 100 0 &lt;= k &lt;= n"
    },
    {
      "number": 1422,
      "title": "Maximum Score After Splitting a String",
      "titleSlug": "maximum-score-after-splitting-a-string",
      "difficulty": "Easy",
      "tags": [
        "String",
        "Prefix Sum"
      ],
      "description": "Given a&nbsp;string s&nbsp;of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring). The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring. &nbsp; Example 1: Input: s = &quot;011101&quot; Output: 5 Explanation: All possible ways of splitting s into two non-empty substrings are: left = &quot;0&quot; and right = &quot;11101&quot;, score = 1 + 4 = 5 left = &quot;01&quot; and right = &quot;1101&quot;, score = 1 + 3 = 4 left = &quot;011&quot; and right = &quot;101&quot;, score = 1 + 2 = 3 left = &quot;0111&quot; and right = &quot;01&quot;, score = 1 + 1 = 2 left = &quot;01110&quot; and right = &quot;1&quot;, score = 2 + 1 = 3 Example 2: Input: s = &quot;00111&quot; Output: 5 Explanation: When left = &quot;00&quot; and right = &quot;111&quot;, we get the maximum score = 2 + 3 = 5 Example 3: Input: s = &quot;1111&quot; Output: 3 &nbsp; Constraints: 2 &lt;= s.length &lt;= 500 The string s consists of characters &#39;0&#39; and &#39;1&#39; only."
    },
    {
      "number": 1423,
      "title": "Maximum Points You Can Obtain from Cards",
      "titleSlug": "maximum-points-you-can-obtain-from-cards",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Sliding Window",
        "Prefix Sum"
      ],
      "description": "There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards. Your score is the sum of the points of the cards you have taken. Given the integer array cardPoints and the integer k, return the maximum score you can obtain. &nbsp; Example 1: Input: cardPoints = [1,2,3,4,5,6,1], k = 3 Output: 12 Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12. Example 2: Input: cardPoints = [2,2,2], k = 2 Output: 4 Explanation: Regardless of which two cards you take, your score will always be 4. Example 3: Input: cardPoints = [9,7,7,9,7,7,9], k = 7 Output: 55 Explanation: You have to take all the cards. Your score is the sum of points of all cards. &nbsp; Constraints: 1 &lt;= cardPoints.length &lt;= 105 1 &lt;= cardPoints[i] &lt;= 104 1 &lt;= k &lt;= cardPoints.length"
    },
    {
      "number": 1424,
      "title": "Diagonal Traverse II",
      "titleSlug": "diagonal-traverse-ii",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images. &nbsp; Example 1: Input: nums = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,4,2,7,5,3,8,6,9] Example 2: Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]] Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16] &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i].length &lt;= 105 1 &lt;= sum(nums[i].length) &lt;= 105 1 &lt;= nums[i][j] &lt;= 105"
    },
    {
      "number": 1425,
      "title": "Constrained Subsequence Sum",
      "titleSlug": "constrained-subsequence-sum",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Queue",
        "Sliding Window",
        "Heap (Priority Queue)",
        "Monotonic Queue"
      ],
      "description": "Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i &lt; j, the condition j - i &lt;= k is satisfied. A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order. &nbsp; Example 1: Input: nums = [10,2,-10,5,20], k = 2 Output: 37 Explanation: The subsequence is [10, 2, 5, 20]. Example 2: Input: nums = [-1,-2,-3], k = 1 Output: -1 Explanation: The subsequence must be non-empty, so we choose the largest number. Example 3: Input: nums = [10,-2,-10,-5,20], k = 2 Output: 23 Explanation: The subsequence is [10, -2, -5, 20]. &nbsp; Constraints: 1 &lt;= k &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104"
    },
    {
      "number": 1431,
      "title": "Kids With the Greatest Number of Candies",
      "titleSlug": "kids-with-the-greatest-number-of-candies",
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "description": "There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have. Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies. &nbsp; Example 1: Input: candies = [2,3,5,1,3], extraCandies = 3 Output: [true,true,true,false,true] Explanation: If you give all extraCandies to: - Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids. - Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids. - Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids. - Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids. - Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids. Example 2: Input: candies = [4,2,1,1,2], extraCandies = 1 Output: [true,false,false,false,false] Explanation: There is only 1 extra candy. Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy. Example 3: Input: candies = [12,1,12], extraCandies = 10 Output: [true,false,true] &nbsp; Constraints: n == candies.length 2 &lt;= n &lt;= 100 1 &lt;= candies[i] &lt;= 100 1 &lt;= extraCandies &lt;= 50"
    },
    {
      "number": 1432,
      "title": "Max Difference You Can Get From Changing an Integer",
      "titleSlug": "max-difference-you-can-get-from-changing-an-integer",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Greedy"
      ],
      "description": "You are given an integer num. You will apply the following steps exactly two times: Pick a digit x (0 &lt;= x &lt;= 9). Pick another digit y (0 &lt;= y &lt;= 9). The digit y can be equal to x. Replace all the occurrences of x in the decimal representation of num by y. The new integer cannot have any leading zeros, also the new integer cannot be 0. Let a and b be the results of applying the operations to num the first and second times, respectively. Return the max difference between a and b. &nbsp; Example 1: Input: num = 555 Output: 888 Explanation: The first time pick x = 5 and y = 9 and store the new integer in a. The second time pick x = 5 and y = 1 and store the new integer in b. We have now a = 999 and b = 111 and max difference = 888 Example 2: Input: num = 9 Output: 8 Explanation: The first time pick x = 9 and y = 9 and store the new integer in a. The second time pick x = 9 and y = 1 and store the new integer in b. We have now a = 9 and b = 1 and max difference = 8 &nbsp; Constraints: 1 &lt;= num &lt;= 108"
    },
    {
      "number": 1433,
      "title": "Check If a String Can Break Another String",
      "titleSlug": "check-if-a-string-can-break-another-string",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Greedy",
        "Sorting"
      ],
      "description": "Given two strings: s1 and s2 with the same&nbsp;size, check if some&nbsp;permutation of string s1 can break&nbsp;some&nbsp;permutation of string s2 or vice-versa. In other words s2 can break s1&nbsp;or vice-versa. A string x&nbsp;can break&nbsp;string y&nbsp;(both of size n) if x[i] &gt;= y[i]&nbsp;(in alphabetical order)&nbsp;for all i&nbsp;between 0 and n-1. &nbsp; Example 1: Input: s1 = &quot;abc&quot;, s2 = &quot;xya&quot; Output: true Explanation: &quot;ayx&quot; is a permutation of s2=&quot;xya&quot; which can break to string &quot;abc&quot; which is a permutation of s1=&quot;abc&quot;. Example 2: Input: s1 = &quot;abe&quot;, s2 = &quot;acd&quot; Output: false Explanation: All permutations for s1=&quot;abe&quot; are: &quot;abe&quot;, &quot;aeb&quot;, &quot;bae&quot;, &quot;bea&quot;, &quot;eab&quot; and &quot;eba&quot; and all permutation for s2=&quot;acd&quot; are: &quot;acd&quot;, &quot;adc&quot;, &quot;cad&quot;, &quot;cda&quot;, &quot;dac&quot; and &quot;dca&quot;. However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa. Example 3: Input: s1 = &quot;leetcodee&quot;, s2 = &quot;interview&quot; Output: true &nbsp; Constraints: s1.length == n s2.length == n 1 &lt;= n &lt;= 10^5 All strings consist of lowercase English letters."
    },
    {
      "number": 1434,
      "title": "Number of Ways to Wear Different Hats to Each Other",
      "titleSlug": "number-of-ways-to-wear-different-hats-to-each-other",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Bit Manipulation",
        "Bitmask"
      ],
      "description": "There are n people and 40 types of hats labeled from 1 to 40. Given a 2D integer array hats, where hats[i] is a list of all hats preferred by the ith person. Return the number of ways that n people can wear different hats from each other. Since the answer may be too large, return it modulo 109 + 7. &nbsp; Example 1: Input: hats = [[3,4],[4,5],[5]] Output: 1 Explanation: There is only one way to choose hats given the conditions. First person choose hat 3, Second person choose hat 4 and last one hat 5. Example 2: Input: hats = [[3,5,1],[3,5]] Output: 4 Explanation: There are 4 ways to choose hats: (3,5), (5,3), (1,3) and (1,5) Example 3: Input: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]] Output: 24 Explanation: Each person can choose hats labeled from 1 to 4. Number of Permutations of (1,2,3,4) = 24. &nbsp; Constraints: n == hats.length 1 &lt;= n &lt;= 10 1 &lt;= hats[i].length &lt;= 40 1 &lt;= hats[i][j] &lt;= 40 hats[i] contains a list of unique integers."
    },
    {
      "number": 1436,
      "title": "Destination City",
      "titleSlug": "destination-city",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city. It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city. &nbsp; Example 1: Input: paths = [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]] Output: &quot;Sao Paulo&quot; Explanation: Starting at &quot;London&quot; city you will reach &quot;Sao Paulo&quot; city which is the destination city. Your trip consist of: &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot;. Example 2: Input: paths = [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]] Output: &quot;A&quot; Explanation: All possible trips are:&nbsp; &quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;.&nbsp; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;.&nbsp; &quot;C&quot; -&gt; &quot;A&quot;.&nbsp; &quot;A&quot;.&nbsp; Clearly the destination city is &quot;A&quot;. Example 3: Input: paths = [[&quot;A&quot;,&quot;Z&quot;]] Output: &quot;Z&quot; &nbsp; Constraints: 1 &lt;= paths.length &lt;= 100 paths[i].length == 2 1 &lt;= cityAi.length, cityBi.length &lt;= 10 cityAi != cityBi All strings consist of lowercase and uppercase English letters and the space character."
    },
    {
      "number": 1438,
      "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
      "titleSlug": "longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Queue",
        "Sliding Window",
        "Heap (Priority Queue)",
        "Ordered Set",
        "Monotonic Queue"
      ],
      "description": "Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit. &nbsp; Example 1: Input: nums = [8,2,4,7], limit = 4 Output: 2 Explanation: All subarrays are: [8] with maximum absolute diff |8-8| = 0 &lt;= 4. [8,2] with maximum absolute diff |8-2| = 6 &gt; 4. [8,2,4] with maximum absolute diff |8-2| = 6 &gt; 4. [8,2,4,7] with maximum absolute diff |8-2| = 6 &gt; 4. [2] with maximum absolute diff |2-2| = 0 &lt;= 4. [2,4] with maximum absolute diff |2-4| = 2 &lt;= 4. [2,4,7] with maximum absolute diff |2-7| = 5 &gt; 4. [4] with maximum absolute diff |4-4| = 0 &lt;= 4. [4,7] with maximum absolute diff |4-7| = 3 &lt;= 4. [7] with maximum absolute diff |7-7| = 0 &lt;= 4. Therefore, the size of the longest subarray is 2. Example 2: Input: nums = [10,1,2,4,7,2], limit = 5 Output: 4 Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 &lt;= 5. Example 3: Input: nums = [4,2,2,2,4,4,2,2], limit = 0 Output: 3 &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 109 0 &lt;= limit &lt;= 109"
    },
    {
      "number": 1439,
      "title": "Find the Kth Smallest Sum of a Matrix With Sorted Rows",
      "titleSlug": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Binary Search",
        "Heap (Priority Queue)",
        "Matrix"
      ],
      "description": "You are given an m x n matrix mat that has its rows sorted in non-decreasing order and an integer k. You are allowed to choose exactly one element from each row to form an array. Return the kth smallest array sum among all possible arrays. &nbsp; Example 1: Input: mat = [[1,3,11],[2,4,6]], k = 5 Output: 7 Explanation: Choosing one element from each row, the first k smallest sum are: [1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7. Example 2: Input: mat = [[1,3,11],[2,4,6]], k = 9 Output: 17 Example 3: Input: mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7 Output: 9 Explanation: Choosing one element from each row, the first k smallest sum are: [1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9. &nbsp; Constraints: m == mat.length n == mat.length[i] 1 &lt;= m, n &lt;= 40 1 &lt;= mat[i][j] &lt;= 5000 1 &lt;= k &lt;= min(200, nm) mat[i] is a non-decreasing array."
    },
    {
      "number": 1441,
      "title": "Build an Array With Stack Operations",
      "titleSlug": "build-an-array-with-stack-operations",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Stack",
        "Simulation"
      ],
      "description": "You are given an integer array target and an integer n. You have an empty stack with the two following operations: &quot;Push&quot;: pushes an integer to the top of the stack. &quot;Pop&quot;: removes the integer on the top of the stack. You also have a stream of the integers in the range [1, n]. Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to target. You should follow the following rules: If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack. If the stack is not empty, pop the integer at the top of the stack. If, at any moment, the elements in the stack (from the bottom to the top) are equal to target, do not read new integers from the stream and do not do more operations on the stack. Return the stack operations needed to build target following the mentioned rules. If there are multiple valid answers, return any of them. &nbsp; Example 1: Input: target = [1,3], n = 3 Output: [&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;] Explanation: Initially the stack s is empty. The last element is the top of the stack. Read 1 from the stream and push it to the stack. s = [1]. Read 2 from the stream and push it to the stack. s = [1,2]. Pop the integer on the top of the stack. s = [1]. Read 3 from the stream and push it to the stack. s = [1,3]. Example 2: Input: target = [1,2,3], n = 3 Output: [&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;] Explanation: Initially the stack s is empty. The last element is the top of the stack. Read 1 from the stream and push it to the stack. s = [1]. Read 2 from the stream and push it to the stack. s = [1,2]. Read 3 from the stream and push it to the stack. s = [1,2,3]. Example 3: Input: target = [1,2], n = 4 Output: [&quot;Push&quot;,&quot;Push&quot;] Explanation: Initially the stack s is empty. The last element is the top of the stack. Read 1 from the stream and push it to the stack. s = [1]. Read 2 from the stream and push it to the stack. s = [1,2]. Since the stack (from the bottom to the top) is equal to target, we stop the stack operations. The answers that read integer 3 from the stream are not accepted. &nbsp; Constraints: 1 &lt;= target.length &lt;= 100 1 &lt;= n &lt;= 100 1 &lt;= target[i] &lt;= n target is strictly increasing."
    },
    {
      "number": 1442,
      "title": "Count Triplets That Can Form Two Arrays of Equal XOR",
      "titleSlug": "count-triplets-that-can-form-two-arrays-of-equal-xor",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Math",
        "Bit Manipulation",
        "Prefix Sum"
      ],
      "description": "Given an array of integers arr. We want to select three indices i, j and k where (0 &lt;= i &lt; j &lt;= k &lt; arr.length). Let&#39;s define a and b as follows: a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k] Note that ^ denotes the bitwise-xor operation. Return the number of triplets (i, j and k) Where a == b. &nbsp; Example 1: Input: arr = [2,3,1,6,7] Output: 4 Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4) Example 2: Input: arr = [1,1,1,1,1] Output: 10 &nbsp; Constraints: 1 &lt;= arr.length &lt;= 300 1 &lt;= arr[i] &lt;= 108"
    },
    {
      "number": 1443,
      "title": "Minimum Time to Collect All Apples in a Tree",
      "titleSlug": "minimum-time-to-collect-all-apples-in-a-tree",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search"
      ],
      "description": "Given an undirected tree consisting of n vertices numbered from 0 to n-1, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at vertex 0 and coming back to this vertex. The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. Additionally, there is a boolean array hasApple, where hasApple[i] = true means that vertex i has an apple; otherwise, it does not have any apple. &nbsp; Example 1: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false] Output: 8 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. Example 2: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false] Output: 6 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. Example 3: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false] Output: 0 &nbsp; Constraints: 1 &lt;= n &lt;= 105 edges.length == n - 1 edges[i].length == 2 0 &lt;= ai &lt; bi &lt;= n - 1 hasApple.length == n"
    },
    {
      "number": 1444,
      "title": "Number of Ways of Cutting a Pizza",
      "titleSlug": "number-of-ways-of-cutting-a-pizza",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Memoization",
        "Matrix",
        "Prefix Sum"
      ],
      "description": "Given a rectangular pizza represented as a rows x cols&nbsp;matrix containing the following characters: &#39;A&#39; (an apple) and &#39;.&#39; (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.&nbsp; For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person. Return the number of ways of cutting the pizza such that each piece contains at least one apple.&nbsp;Since the answer can be a huge number, return this modulo 10^9 + 7. &nbsp; Example 1: Input: pizza = [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k = 3 Output: 3 Explanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple. Example 2: Input: pizza = [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k = 3 Output: 1 Example 3: Input: pizza = [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k = 1 Output: 1 &nbsp; Constraints: 1 &lt;= rows, cols &lt;= 50 rows ==&nbsp;pizza.length cols ==&nbsp;pizza[i].length 1 &lt;= k &lt;= 10 pizza consists of characters &#39;A&#39;&nbsp;and &#39;.&#39; only."
    },
    {
      "number": 1446,
      "title": "Consecutive Characters",
      "titleSlug": "consecutive-characters",
      "difficulty": "Easy",
      "tags": [
        "String"
      ],
      "description": "The power of the string is the maximum length of a non-empty substring that contains only one unique character. Given a string s, return the power of s. &nbsp; Example 1: Input: s = &quot;leetcode&quot; Output: 2 Explanation: The substring &quot;ee&quot; is of length 2 with the character &#39;e&#39; only. Example 2: Input: s = &quot;abbcccddddeeeeedcba&quot; Output: 5 Explanation: The substring &quot;eeeee&quot; is of length 5 with the character &#39;e&#39; only. &nbsp; Constraints: 1 &lt;= s.length &lt;= 500 s consists of only lowercase English letters."
    },
    {
      "number": 1447,
      "title": "Simplified Fractions",
      "titleSlug": "simplified-fractions",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "String",
        "Number Theory"
      ],
      "description": "Given an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n. You can return the answer in any order. &nbsp; Example 1: Input: n = 2 Output: [&quot;1/2&quot;] Explanation: &quot;1/2&quot; is the only unique fraction with a denominator less-than-or-equal-to 2. Example 2: Input: n = 3 Output: [&quot;1/2&quot;,&quot;1/3&quot;,&quot;2/3&quot;] Example 3: Input: n = 4 Output: [&quot;1/2&quot;,&quot;1/3&quot;,&quot;1/4&quot;,&quot;2/3&quot;,&quot;3/4&quot;] Explanation: &quot;2/4&quot; is not a simplified fraction because it can be simplified to &quot;1/2&quot;. &nbsp; Constraints: 1 &lt;= n &lt;= 100"
    },
    {
      "number": 1448,
      "title": "Count Good Nodes in Binary Tree",
      "titleSlug": "count-good-nodes-in-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given a binary tree root, a node X in the tree is named&nbsp;good if in the path from root to X there are no nodes with a value greater than X. Return the number of good nodes in the binary tree. &nbsp; Example 1: Input: root = [3,1,4,3,null,1,5] Output: 4 Explanation: Nodes in blue are good. Root Node (3) is always a good node. Node 4 -&gt; (3,4) is the maximum value in the path starting from the root. Node 5 -&gt; (3,4,5) is the maximum value in the path Node 3 -&gt; (3,1,3) is the maximum value in the path. Example 2: Input: root = [3,3,null,4,2] Output: 3 Explanation: Node 2 -&gt; (3, 3, 2) is not good, because &quot;3&quot; is higher than it. Example 3: Input: root = [1] Output: 1 Explanation: Root is considered as good. &nbsp; Constraints: The number of nodes in the binary tree is in the range&nbsp;[1, 10^5]. Each node&#39;s value is between [-10^4, 10^4]."
    },
    {
      "number": 1449,
      "title": "Form Largest Integer With Digits That Add up to Target",
      "titleSlug": "form-largest-integer-with-digits-that-add-up-to-target",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "Given an array of integers cost and an integer target, return the maximum integer you can paint under the following rules: The cost of painting a digit (i + 1) is given by cost[i] (0-indexed). The total cost used must be equal to target. The integer does not have 0 digits. Since the answer may be very large, return it as a string. If there is no way to paint any integer given the condition, return &quot;0&quot;. &nbsp; Example 1: Input: cost = [4,3,2,5,6,7,2,5,5], target = 9 Output: &quot;7772&quot; Explanation: The cost to paint the digit &#39;7&#39; is 2, and the digit &#39;2&#39; is 3. Then cost(&quot;7772&quot;) = 2*3+ 3*1 = 9. You could also paint &quot;977&quot;, but &quot;7772&quot; is the largest number. Digit cost 1 -&gt; 4 2 -&gt; 3 3 -&gt; 2 4 -&gt; 5 5 -&gt; 6 6 -&gt; 7 7 -&gt; 2 8 -&gt; 5 9 -&gt; 5 Example 2: Input: cost = [7,6,5,5,5,6,8,7,8], target = 12 Output: &quot;85&quot; Explanation: The cost to paint the digit &#39;8&#39; is 7, and the digit &#39;5&#39; is 5. Then cost(&quot;85&quot;) = 7 + 5 = 12. Example 3: Input: cost = [2,4,6,2,4,6,4,4,4], target = 5 Output: &quot;0&quot; Explanation: It is impossible to paint any integer with total cost equal to target. &nbsp; Constraints: cost.length == 9 1 &lt;= cost[i], target &lt;= 5000"
    },
    {
      "number": 1450,
      "title": "Number of Students Doing Homework at a Given Time",
      "titleSlug": "number-of-students-doing-homework-at-a-given-time",
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "description": "Given two integer arrays startTime and endTime and given an integer queryTime. The ith student started doing their homework at the time startTime[i] and finished it at time endTime[i]. Return the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive. &nbsp; Example 1: Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4 Output: 1 Explanation: We have 3 students where: The first student started doing homework at time 1 and finished at time 3 and wasn&#39;t doing anything at time 4. The second student started doing homework at time 2 and finished at time 2 and also wasn&#39;t doing anything at time 4. The third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4. Example 2: Input: startTime = [4], endTime = [4], queryTime = 4 Output: 1 Explanation: The only student was doing their homework at the queryTime. &nbsp; Constraints: startTime.length == endTime.length 1 &lt;= startTime.length &lt;= 100 1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000 1 &lt;= queryTime &lt;= 1000"
    },
    {
      "number": 1451,
      "title": "Rearrange Words in a Sentence",
      "titleSlug": "rearrange-words-in-a-sentence",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Sorting"
      ],
      "description": "Given a sentence&nbsp;text (A&nbsp;sentence&nbsp;is a string of space-separated words) in the following format: First letter is in upper case. Each word in text are separated by a single space. Your task is to rearrange the words in text such that&nbsp;all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order. Return the new text&nbsp;following the format shown above. &nbsp; Example 1: Input: text = &quot;Leetcode is cool&quot; Output: &quot;Is cool leetcode&quot; Explanation: There are 3 words, &quot;Leetcode&quot; of length 8, &quot;is&quot; of length 2 and &quot;cool&quot; of length 4. Output is ordered by length and the new first word starts with capital letter. Example 2: Input: text = &quot;Keep calm and code on&quot; Output: &quot;On and keep calm code&quot; Explanation: Output is ordered as follows: &quot;On&quot; 2 letters. &quot;and&quot; 3 letters. &quot;keep&quot; 4 letters in case of tie order by position in original text. &quot;calm&quot; 4 letters. &quot;code&quot; 4 letters. Example 3: Input: text = &quot;To be or not to be&quot; Output: &quot;To be or to be not&quot; &nbsp; Constraints: text begins with a capital letter and then contains lowercase letters and single space between words. 1 &lt;= text.length &lt;= 10^5"
    },
    {
      "number": 1452,
      "title": "People Whose List of Favorite Companies Is Not a Subset of Another List",
      "titleSlug": "people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "Given the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person (indexed from 0). Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order. &nbsp; Example 1: Input: favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;,&quot;microsoft&quot;],[&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;],[&quot;amazon&quot;]] Output: [0,1,4] Explanation: Person with index=2 has favoriteCompanies[2]=[&quot;google&quot;,&quot;facebook&quot;] which is a subset of favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] corresponding to the person with index 0. Person with index=3 has favoriteCompanies[3]=[&quot;google&quot;] which is a subset of favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] and favoriteCompanies[1]=[&quot;google&quot;,&quot;microsoft&quot;]. Other lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4]. Example 2: Input: favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;leetcode&quot;,&quot;amazon&quot;],[&quot;facebook&quot;,&quot;google&quot;]] Output: [0,1] Explanation: In this case favoriteCompanies[2]=[&quot;facebook&quot;,&quot;google&quot;] is a subset of favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;], therefore, the answer is [0,1]. Example 3: Input: favoriteCompanies = [[&quot;leetcode&quot;],[&quot;google&quot;],[&quot;facebook&quot;],[&quot;amazon&quot;]] Output: [0,1,2,3] &nbsp; Constraints: 1 &lt;= favoriteCompanies.length &lt;= 100 1 &lt;= favoriteCompanies[i].length &lt;= 500 1 &lt;= favoriteCompanies[i][j].length &lt;= 20 All strings in favoriteCompanies[i] are distinct. All lists of favorite companies are distinct, that is, If we sort alphabetically each list then favoriteCompanies[i] != favoriteCompanies[j]. All strings consist of lowercase English letters only."
    },
    {
      "number": 1453,
      "title": "Maximum Number of Darts Inside of a Circular Dartboard",
      "titleSlug": "maximum-number-of-darts-inside-of-a-circular-dartboard",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Geometry"
      ],
      "description": "Alice is throwing n darts on a very large wall. You are given an array darts where darts[i] = [xi, yi] is the position of the ith dart that Alice threw on the wall. Bob knows the positions of the n darts on the wall. He wants to place a dartboard of radius r on the wall so that the maximum number of darts that Alice throws lie&nbsp;on the dartboard. Given the integer r, return the maximum number of darts that can lie on the dartboard. &nbsp; Example 1: Input: darts = [[-2,0],[2,0],[0,2],[0,-2]], r = 2 Output: 4 Explanation: Circle dartboard with center in (0,0) and radius = 2 contain all points. Example 2: Input: darts = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5 Output: 5 Explanation: Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8). &nbsp; Constraints: 1 &lt;= darts.length &lt;= 100 darts[i].length == 2 -104 &lt;= xi, yi &lt;= 104 All the darts&nbsp;are unique 1 &lt;= r &lt;= 5000"
    },
    {
      "number": 1455,
      "title": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
      "titleSlug": "check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence",
      "difficulty": "Easy",
      "tags": [
        "Two Pointers",
        "String",
        "String Matching"
      ],
      "description": "Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence. Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1. A prefix of a string s is any leading contiguous substring of s. &nbsp; Example 1: Input: sentence = &quot;i love eating burger&quot;, searchWord = &quot;burg&quot; Output: 4 Explanation: &quot;burg&quot; is prefix of &quot;burger&quot; which is the 4th word in the sentence. Example 2: Input: sentence = &quot;this problem is an easy problem&quot;, searchWord = &quot;pro&quot; Output: 2 Explanation: &quot;pro&quot; is prefix of &quot;problem&quot; which is the 2nd and the 6th word in the sentence, but we return 2 as it&#39;s the minimal index. Example 3: Input: sentence = &quot;i am tired&quot;, searchWord = &quot;you&quot; Output: -1 Explanation: &quot;you&quot; is not a prefix of any word in the sentence. &nbsp; Constraints: 1 &lt;= sentence.length &lt;= 100 1 &lt;= searchWord.length &lt;= 10 sentence consists of lowercase English letters and spaces. searchWord consists of lowercase English letters."
    },
    {
      "number": 1456,
      "title": "Maximum Number of Vowels in a Substring of Given Length",
      "titleSlug": "maximum-number-of-vowels-in-a-substring-of-given-length",
      "difficulty": "Medium",
      "tags": [
        "String",
        "Sliding Window"
      ],
      "description": "Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k. Vowel letters in English are &#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, and &#39;u&#39;. &nbsp; Example 1: Input: s = &quot;abciiidef&quot;, k = 3 Output: 3 Explanation: The substring &quot;iii&quot; contains 3 vowel letters. Example 2: Input: s = &quot;aeiou&quot;, k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. Example 3: Input: s = &quot;leetcode&quot;, k = 3 Output: 2 Explanation: &quot;lee&quot;, &quot;eet&quot; and &quot;ode&quot; contain 2 vowels. &nbsp; Constraints: 1 &lt;= s.length &lt;= 105 s consists of lowercase English letters. 1 &lt;= k &lt;= s.length"
    },
    {
      "number": 1457,
      "title": "Pseudo-Palindromic Paths in a Binary Tree",
      "titleSlug": "pseudo-palindromic-paths-in-a-binary-tree",
      "difficulty": "Medium",
      "tags": [
        "Bit Manipulation",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Binary Tree"
      ],
      "description": "Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome. Return the number of pseudo-palindromic paths going from the root node to leaf nodes. &nbsp; Example 1: Input: root = [2,3,1,3,1,null,1] Output: 2 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome). Example 2: Input: root = [2,1,1,1,3,null,null,null,null,null,1] Output: 1 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome). Example 3: Input: root = [9] Output: 1 &nbsp; Constraints: The number of nodes in the tree is in the range [1, 105]. 1 &lt;= Node.val &lt;= 9"
    },
    {
      "number": 1458,
      "title": "Max Dot Product of Two Subsequences",
      "titleSlug": "max-dot-product-of-two-subsequences",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "Given two arrays nums1&nbsp;and nums2. Return the maximum dot product&nbsp;between&nbsp;non-empty subsequences of nums1 and nums2 with the same length. A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie,&nbsp;[2,3,5]&nbsp;is a subsequence of&nbsp;[1,2,3,4,5]&nbsp;while [1,5,3]&nbsp;is not). &nbsp; Example 1: Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6] Output: 18 Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2. Their dot product is (2*3 + (-2)*(-6)) = 18. Example 2: Input: nums1 = [3,-2], nums2 = [2,-6,7] Output: 21 Explanation: Take subsequence [3] from nums1 and subsequence [7] from nums2. Their dot product is (3*7) = 21. Example 3: Input: nums1 = [-1,-1], nums2 = [1,1] Output: -1 Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2. Their dot product is -1. &nbsp; Constraints: 1 &lt;= nums1.length, nums2.length &lt;= 500 -1000 &lt;= nums1[i], nums2[i] &lt;= 1000"
    },
    {
      "number": 1460,
      "title": "Make Two Arrays Equal by Reversing Subarrays",
      "titleSlug": "make-two-arrays-equal-by-reversing-subarrays",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Hash Table",
        "Sorting"
      ],
      "description": "You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty subarray of arr and reverse it. You are allowed to make any number of steps. Return true if you can make arr equal to target&nbsp;or false otherwise. &nbsp; Example 1: Input: target = [1,2,3,4], arr = [2,4,1,3] Output: true Explanation: You can follow the next steps to convert arr to target: 1- Reverse subarray [2,4,1], arr becomes [1,4,2,3] 2- Reverse subarray [4,2], arr becomes [1,2,4,3] 3- Reverse subarray [4,3], arr becomes [1,2,3,4] There are multiple ways to convert arr to target, this is not the only way to do so. Example 2: Input: target = [7], arr = [7] Output: true Explanation: arr is equal to target without any reverses. Example 3: Input: target = [3,7,9], arr = [3,7,11] Output: false Explanation: arr does not have value 9 and it can never be converted to target. &nbsp; Constraints: target.length == arr.length 1 &lt;= target.length &lt;= 1000 1 &lt;= target[i] &lt;= 1000 1 &lt;= arr[i] &lt;= 1000"
    },
    {
      "number": 1461,
      "title": "Check If a String Contains All Binary Codes of Size K",
      "titleSlug": "check-if-a-string-contains-all-binary-codes-of-size-k",
      "difficulty": "Medium",
      "tags": [
        "Hash Table",
        "String",
        "Bit Manipulation",
        "Rolling Hash",
        "Hash Function"
      ],
      "description": "Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false. &nbsp; Example 1: Input: s = &quot;00110110&quot;, k = 2 Output: true Explanation: The binary codes of length 2 are &quot;00&quot;, &quot;01&quot;, &quot;10&quot; and &quot;11&quot;. They can be all found as substrings at indices 0, 1, 3 and 2 respectively. Example 2: Input: s = &quot;0110&quot;, k = 1 Output: true Explanation: The binary codes of length 1 are &quot;0&quot; and &quot;1&quot;, it is clear that both exist as a substring. Example 3: Input: s = &quot;0110&quot;, k = 2 Output: false Explanation: The binary code &quot;00&quot; is of length 2 and does not exist in the array. &nbsp; Constraints: 1 &lt;= s.length &lt;= 5 * 105 s[i] is either &#39;0&#39; or &#39;1&#39;. 1 &lt;= k &lt;= 20"
    },
    {
      "number": 1462,
      "title": "Course Schedule IV",
      "titleSlug": "course-schedule-iv",
      "difficulty": "Medium",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Graph",
        "Topological Sort"
      ],
      "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course ai first if you want to take course bi. For example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1. Prerequisites can also be indirect. If course a is a prerequisite of course b, and course b is a prerequisite of course c, then course a is a prerequisite of course c. You are also given an array queries where queries[j] = [uj, vj]. For the jth query, you should answer whether course uj is a prerequisite of course vj or not. Return a boolean array answer, where answer[j] is the answer to the jth query. &nbsp; Example 1: Input: numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]] Output: [false,true] Explanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0. Course 0 is not a prerequisite of course 1, but the opposite is true. Example 2: Input: numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]] Output: [false,false] Explanation: There are no prerequisites, and each course is independent. Example 3: Input: numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]] Output: [true,true] &nbsp; Constraints: 2 &lt;= numCourses &lt;= 100 0 &lt;= prerequisites.length &lt;= (numCourses * (numCourses - 1) / 2) prerequisites[i].length == 2 0 &lt;= ai, bi &lt;= numCourses - 1 ai != bi All the pairs [ai, bi] are unique. The prerequisites graph has no cycles. 1 &lt;= queries.length &lt;= 104 0 &lt;= ui, vi &lt;= numCourses - 1 ui != vi"
    },
    {
      "number": 1463,
      "title": "Cherry Pickup II",
      "titleSlug": "cherry-pickup-ii",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Matrix"
      ],
      "description": "You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell. You have two robots that can collect cherries for you: Robot #1 is located at the top-left corner (0, 0), and Robot #2 is located at the top-right corner (0, cols - 1). Return the maximum number of cherries collection using both robots by following the rules below: From a cell (i, j), robots can move to cell (i + 1, j - 1), (i + 1, j), or (i + 1, j + 1). When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell. When both robots stay in the same cell, only one takes the cherries. Both robots cannot move outside of the grid at any moment. Both robots should reach the bottom row in grid. &nbsp; Example 1: Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]] Output: 24 Explanation: Path of robot #1 and #2 are described in color green and blue respectively. Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12. Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12. Total of cherries: 12 + 12 = 24. Example 2: Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]] Output: 28 Explanation: Path of robot #1 and #2 are described in color green and blue respectively. Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17. Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11. Total of cherries: 17 + 11 = 28. &nbsp; Constraints: rows == grid.length cols == grid[i].length 2 &lt;= rows, cols &lt;= 70 0 &lt;= grid[i][j] &lt;= 100"
    },
    {
      "number": 1464,
      "title": "Maximum Product of Two Elements in an Array",
      "titleSlug": "maximum-product-of-two-elements-in-an-array",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Sorting",
        "Heap (Priority Queue)"
      ],
      "description": "Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1). &nbsp; Example 1: Input: nums = [3,4,5,2] Output: 12 Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. Example 2: Input: nums = [1,5,4,5] Output: 16 Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16. Example 3: Input: nums = [3,7] Output: 12 &nbsp; Constraints: 2 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 10^3"
    },
    {
      "number": 1465,
      "title": "Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts",
      "titleSlug": "maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Greedy",
        "Sorting"
      ],
      "description": "You are given a rectangular cake of size h x w and two arrays of integers horizontalCuts and verticalCuts where: horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, and verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut. Return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts. Since the answer can be a large number, return this modulo 109 + 7. &nbsp; Example 1: Input: h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3] Output: 4 Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area. Example 2: Input: h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1] Output: 6 Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area. Example 3: Input: h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3] Output: 9 &nbsp; Constraints: 2 &lt;= h, w &lt;= 109 1 &lt;= horizontalCuts.length &lt;= min(h - 1, 105) 1 &lt;= verticalCuts.length &lt;= min(w - 1, 105) 1 &lt;= horizontalCuts[i] &lt; h 1 &lt;= verticalCuts[i] &lt; w All the elements in horizontalCuts are distinct. All the elements in verticalCuts are distinct."
    },
    {
      "number": 1466,
      "title": "Reorder Routes to Make All Paths Lead to the City Zero",
      "titleSlug": "reorder-routes-to-make-all-paths-lead-to-the-city-zero",
      "difficulty": "Medium",
      "tags": [
        "Depth-First Search",
        "Breadth-First Search",
        "Graph"
      ],
      "description": "There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow. Roads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi. This year, there will be a big event in the capital (city 0), and many people want to travel to this city. Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed. It&#39;s guaranteed that each city can reach city 0 after reorder. &nbsp; Example 1: Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]] Output: 3 Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital). Example 2: Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]] Output: 2 Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital). Example 3: Input: n = 3, connections = [[1,0],[2,0]] Output: 0 &nbsp; Constraints: 2 &lt;= n &lt;= 5 * 104 connections.length == n - 1 connections[i].length == 2 0 &lt;= ai, bi &lt;= n - 1 ai != bi"
    },
    {
      "number": 1467,
      "title": "Probability of a Two Boxes Having The Same Number of Distinct Balls",
      "titleSlug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Dynamic Programming",
        "Backtracking",
        "Combinatorics",
        "Probability and Statistics"
      ],
      "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i. All the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully). Please note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully). Return the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct. &nbsp; Example 1: Input: balls = [1,1] Output: 1.00000 Explanation: Only 2 ways to divide the balls equally: - A ball of color 1 to box 1 and a ball of color 2 to box 2 - A ball of color 2 to box 1 and a ball of color 1 to box 2 In both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1 Example 2: Input: balls = [2,1,1] Output: 0.66667 Explanation: We have the set of balls [1, 1, 2, 3] This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12): [1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1] After that, we add the first two balls to the first box and the second two balls to the second box. We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box. Probability is 8/12 = 0.66667 Example 3: Input: balls = [1,2,1,2] Output: 0.60000 Explanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box. Probability = 108 / 180 = 0.6 &nbsp; Constraints: 1 &lt;= balls.length &lt;= 8 1 &lt;= balls[i] &lt;= 6 sum(balls) is even."
    },
    {
      "number": 1470,
      "title": "Shuffle the Array",
      "titleSlug": "shuffle-the-array",
      "difficulty": "Easy",
      "tags": [
        "Array"
      ],
      "description": "Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn]. Return the array in the form [x1,y1,x2,y2,...,xn,yn]. &nbsp; Example 1: Input: nums = [2,5,1,3,4,7], n = 3 Output: [2,3,5,4,1,7] Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7]. Example 2: Input: nums = [1,2,3,4,4,3,2,1], n = 4 Output: [1,4,2,3,3,2,4,1] Example 3: Input: nums = [1,1,2,2], n = 2 Output: [1,2,1,2] &nbsp; Constraints: 1 &lt;= n &lt;= 500 nums.length == 2n 1 &lt;= nums[i] &lt;= 10^3"
    },
    {
      "number": 1471,
      "title": "The k Strongest Values in an Array",
      "titleSlug": "the-k-strongest-values-in-an-array",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Sorting"
      ],
      "description": "Given an array of integers arr and an integer k. A value arr[i] is said to be stronger than a value arr[j] if |arr[i] - m| &gt; |arr[j] - m| where m is the centre of the array. If |arr[i] - m| == |arr[j] - m|, then arr[i] is said to be stronger than arr[j] if arr[i] &gt; arr[j]. Return a list of the strongest k values in the array. return the answer in any arbitrary order. The centre is the middle value in an ordered integer list. More formally, if the length of the list is n, the centre is the element in position ((n - 1) / 2) in the sorted list (0-indexed). For arr = [6, -3, 7, 2, 11], n = 5 and the centre is obtained by sorting the array arr = [-3, 2, 6, 7, 11] and the centre is arr[m] where m = ((5 - 1) / 2) = 2. The centre is 6. For arr = [-7, 22, 17,&thinsp;3], n = 4 and the centre is obtained by sorting the array arr = [-7, 3, 17, 22] and the centre is arr[m] where m = ((4 - 1) / 2) = 1. The centre is 3. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Example 1: Input: arr = [1,2,3,4,5], k = 2 Output: [5,1] Explanation: Centre is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also accepted answer. Please note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 &gt; 1. Example 2: Input: arr = [1,1,3,5,5], k = 2 Output: [5,5] Explanation: Centre is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5]. Example 3: Input: arr = [6,7,11,7,6,8], k = 5 Output: [11,8,6,6,7] Explanation: Centre is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7]. Any permutation of [11,8,6,6,7] is accepted. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 105 -105 &lt;= arr[i] &lt;= 105 1 &lt;= k &lt;= arr.length"
    },
    {
      "number": 1472,
      "title": "Design Browser History",
      "titleSlug": "design-browser-history",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Linked List",
        "Stack",
        "Design",
        "Doubly-Linked List",
        "Data Stream"
      ],
      "description": "You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps. Implement the BrowserHistory class: BrowserHistory(string homepage) Initializes the object with the homepage&nbsp;of the browser. void visit(string url)&nbsp;Visits&nbsp;url from the current page. It clears up all the forward history. string back(int steps)&nbsp;Move steps back in history. If you can only return x steps in the history and steps &gt; x, you will&nbsp;return only x steps. Return the current url&nbsp;after moving back in history at most steps. string forward(int steps)&nbsp;Move steps forward in history. If you can only forward x steps in the history and steps &gt; x, you will&nbsp;forward only&nbsp;x steps. Return the current url&nbsp;after forwarding in history at most steps. &nbsp; Example: Input: [&quot;BrowserHistory&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;back&quot;,&quot;back&quot;,&quot;forward&quot;,&quot;visit&quot;,&quot;forward&quot;,&quot;back&quot;,&quot;back&quot;] [[&quot;leetcode.com&quot;],[&quot;google.com&quot;],[&quot;facebook.com&quot;],[&quot;youtube.com&quot;],[1],[1],[1],[&quot;linkedin.com&quot;],[2],[2],[7]] Output: [null,null,null,null,&quot;facebook.com&quot;,&quot;google.com&quot;,&quot;facebook.com&quot;,null,&quot;linkedin.com&quot;,&quot;google.com&quot;,&quot;leetcode.com&quot;] Explanation: BrowserHistory browserHistory = new BrowserHistory(&quot;leetcode.com&quot;); browserHistory.visit(&quot;google.com&quot;); // You are in &quot;leetcode.com&quot;. Visit &quot;google.com&quot; browserHistory.visit(&quot;facebook.com&quot;); // You are in &quot;google.com&quot;. Visit &quot;facebook.com&quot; browserHistory.visit(&quot;youtube.com&quot;); // You are in &quot;facebook.com&quot;. Visit &quot;youtube.com&quot; browserHistory.back(1); // You are in &quot;youtube.com&quot;, move back to &quot;facebook.com&quot; return &quot;facebook.com&quot; browserHistory.back(1); // You are in &quot;facebook.com&quot;, move back to &quot;google.com&quot; return &quot;google.com&quot; browserHistory.forward(1); // You are in &quot;google.com&quot;, move forward to &quot;facebook.com&quot; return &quot;facebook.com&quot; browserHistory.visit(&quot;linkedin.com&quot;); // You are in &quot;facebook.com&quot;. Visit &quot;linkedin.com&quot; browserHistory.forward(2); // You are in &quot;linkedin.com&quot;, you cannot move forward any steps. browserHistory.back(2); // You are in &quot;linkedin.com&quot;, move back two steps to &quot;facebook.com&quot; then to &quot;google.com&quot;. return &quot;google.com&quot; browserHistory.back(7); // You are in &quot;google.com&quot;, you can move back only one step to &quot;leetcode.com&quot;. return &quot;leetcode.com&quot; &nbsp; Constraints: 1 &lt;= homepage.length &lt;= 20 1 &lt;= url.length &lt;= 20 1 &lt;= steps &lt;= 100 homepage and url consist of&nbsp; &#39;.&#39; or lower case English letters. At most 5000&nbsp;calls will be made to visit, back, and forward."
    },
    {
      "number": 1473,
      "title": "Paint House III",
      "titleSlug": "paint-house-iii",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Dynamic Programming"
      ],
      "description": "There is a row of m houses in a small city, each house must be painted with one of the n colors (labeled from 1 to n), some houses that have been painted last summer should not be painted again. A neighborhood is a maximal group of continuous houses that are painted with the same color. For example: houses = [1,2,2,3,3,2,1,1] contains 5 neighborhoods [{1}, {2,2}, {3,3}, {2}, {1,1}]. Given an array houses, an m x n matrix cost and an integer target where: houses[i]: is the color of the house i, and 0 if the house is not painted yet. cost[i][j]: is the cost of paint the house i with the color j + 1. Return the minimum cost of painting all the remaining houses in such a way that there are exactly target neighborhoods. If it is not possible, return -1. &nbsp; Example 1: Input: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 Output: 9 Explanation: Paint houses of this way [1,2,2,1,1] This array contains target = 3 neighborhoods, [{1}, {2,2}, {1,1}]. Cost of paint all houses (1 + 1 + 1 + 1 + 5) = 9. Example 2: Input: houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 Output: 11 Explanation: Some houses are already painted, Paint the houses of this way [2,2,1,2,2] This array contains target = 3 neighborhoods, [{2,2}, {1}, {2,2}]. Cost of paint the first and last house (10 + 1) = 11. Example 3: Input: houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3 Output: -1 Explanation: Houses are already painted with a total of 4 neighborhoods [{3},{1},{2},{3}] different of target = 3. &nbsp; Constraints: m == houses.length == cost.length n == cost[i].length 1 &lt;= m &lt;= 100 1 &lt;= n &lt;= 20 1 &lt;= target &lt;= m 0 &lt;= houses[i] &lt;= n 1 &lt;= cost[i][j] &lt;= 104"
    },
    {
      "number": 1475,
      "title": "Final Prices With a Special Discount in a Shop",
      "titleSlug": "final-prices-with-a-special-discount-in-a-shop",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Stack",
        "Monotonic Stack"
      ],
      "description": "You are given an integer array prices where prices[i] is the price of the ith item in a shop. There is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j &gt; i and prices[j] &lt;= prices[i]. Otherwise, you will not receive any discount at all. Return an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount. &nbsp; Example 1: Input: prices = [8,4,6,2,3] Output: [4,2,4,2,3] Explanation: For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4. For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2. For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4. For items 3 and 4 you will not receive any discount at all. Example 2: Input: prices = [1,2,3,4,5] Output: [1,2,3,4,5] Explanation: In this case, for all items, you will not receive any discount at all. Example 3: Input: prices = [10,1,1,6] Output: [9,0,1,6] &nbsp; Constraints: 1 &lt;= prices.length &lt;= 500 1 &lt;= prices[i] &lt;= 1000"
    },
    {
      "number": 1476,
      "title": "Subrectangle Queries",
      "titleSlug": "subrectangle-queries",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Design",
        "Matrix"
      ],
      "description": "Implement the class SubrectangleQueries&nbsp;which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods: 1.&nbsp;updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) Updates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2). 2.&nbsp;getValue(int row, int col) Returns the current value of the coordinate (row,col) from&nbsp;the rectangle. &nbsp; Example 1: Input [&quot;SubrectangleQueries&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;] [[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]] Output [null,1,null,5,5,null,10,5] Explanation SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]); // The initial rectangle (4x3) looks like: // 1 2 1 // 4 3 4 // 3 2 1 // 1 1 1 subrectangleQueries.getValue(0, 2); // return 1 subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5); // After this update the rectangle looks like: // 5 5 5 // 5 5 5 // 5 5 5 // 5 5 5 subrectangleQueries.getValue(0, 2); // return 5 subrectangleQueries.getValue(3, 1); // return 5 subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10); // After this update the rectangle looks like: // 5 5 5 // 5 5 5 // 5 5 5 // 10 10 10 subrectangleQueries.getValue(3, 1); // return 10 subrectangleQueries.getValue(0, 2); // return 5 Example 2: Input [&quot;SubrectangleQueries&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;] [[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]] Output [null,1,null,100,100,null,20] Explanation SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]); subrectangleQueries.getValue(0, 0); // return 1 subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100); subrectangleQueries.getValue(0, 0); // return 100 subrectangleQueries.getValue(2, 2); // return 100 subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20); subrectangleQueries.getValue(2, 2); // return 20 &nbsp; Constraints: There will be at most 500&nbsp;operations considering both methods:&nbsp;updateSubrectangle and getValue. 1 &lt;= rows, cols &lt;= 100 rows ==&nbsp;rectangle.length cols == rectangle[i].length 0 &lt;= row1 &lt;= row2 &lt; rows 0 &lt;= col1 &lt;= col2 &lt; cols 1 &lt;= newValue, rectangle[i][j] &lt;= 10^9 0 &lt;= row &lt; rows 0 &lt;= col &lt; cols"
    },
    {
      "number": 1477,
      "title": "Find Two Non-overlapping Sub-arrays Each With Target Sum",
      "titleSlug": "find-two-non-overlapping-sub-arrays-each-with-target-sum",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Binary Search",
        "Dynamic Programming",
        "Sliding Window"
      ],
      "description": "You are given an array of integers arr and an integer target. You have to find two non-overlapping sub-arrays of arr each with a sum equal target. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum. Return the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays. &nbsp; Example 1: Input: arr = [3,2,2,4,3], target = 3 Output: 2 Explanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2. Example 2: Input: arr = [7,3,4,7], target = 7 Output: 2 Explanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2. Example 3: Input: arr = [4,3,2,6,2,3,4], target = 6 Output: -1 Explanation: We have only one sub-array of sum = 6. &nbsp; Constraints: 1 &lt;= arr.length &lt;= 105 1 &lt;= arr[i] &lt;= 1000 1 &lt;= target &lt;= 108"
    },
    {
      "number": 1478,
      "title": "Allocate Mailboxes",
      "titleSlug": "allocate-mailboxes",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Math",
        "Dynamic Programming",
        "Sorting"
      ],
      "description": "Given the array houses where houses[i] is the location of the ith house along a street and an integer k, allocate k mailboxes in the street. Return the minimum total distance between each house and its nearest mailbox. The test cases are generated so that the answer fits in a 32-bit integer. &nbsp; Example 1: Input: houses = [1,4,8,10,20], k = 3 Output: 5 Explanation: Allocate mailboxes in position 3, 9 and 20. Minimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 Example 2: Input: houses = [2,3,5,12,18], k = 2 Output: 9 Explanation: Allocate mailboxes in position 3 and 14. Minimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9. &nbsp; Constraints: 1 &lt;= k &lt;= houses.length &lt;= 100 1 &lt;= houses[i] &lt;= 104 All the integers of houses are unique."
    },
    {
      "number": 1480,
      "title": "Running Sum of 1d Array",
      "titleSlug": "running-sum-of-1d-array",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Prefix Sum"
      ],
      "description": "Given an array nums. We define a running sum of an array as&nbsp;runningSum[i] = sum(nums[0]&hellip;nums[i]). Return the running sum of nums. &nbsp; Example 1: Input: nums = [1,2,3,4] Output: [1,3,6,10] Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. Example 2: Input: nums = [1,1,1,1,1] Output: [1,2,3,4,5] Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]. Example 3: Input: nums = [3,1,2,10,1] Output: [3,4,6,16,17] &nbsp; Constraints: 1 &lt;= nums.length &lt;= 1000 -10^6&nbsp;&lt;= nums[i] &lt;=&nbsp;10^6"
    },
    {
      "number": 1481,
      "title": "Least Number of Unique Integers after K Removals",
      "titleSlug": "least-number-of-unique-integers-after-k-removals",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Greedy",
        "Sorting",
        "Counting"
      ],
      "description": "Given an array of integers&nbsp;arr&nbsp;and an integer k.&nbsp;Find the least number of unique integers&nbsp;after removing exactly k elements. &nbsp; Example 1: Input: arr = [5,5,4], k = 1 Output: 1 Explanation: Remove the single 4, only 5 is left. Example 2: Input: arr = [4,3,1,1,3,3,2], k = 3 Output: 2 Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left. &nbsp; Constraints: 1 &lt;= arr.length&nbsp;&lt;= 10^5 1 &lt;= arr[i] &lt;= 10^9 0 &lt;= k&nbsp;&lt;= arr.length"
    },
    {
      "number": 1482,
      "title": "Minimum Number of Days to Make m Bouquets",
      "titleSlug": "minimum-number-of-days-to-make-m-bouquets",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Binary Search"
      ],
      "description": "You are given an integer array bloomDay, an integer m and an integer k. You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden. The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet. Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1. &nbsp; Example 1: Input: bloomDay = [1,10,3,10,2], m = 3, k = 1 Output: 3 Explanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden. We need 3 bouquets each should contain 1 flower. After day 1: [x, _, _, _, _] // we can only make one bouquet. After day 2: [x, _, _, _, x] // we can only make two bouquets. After day 3: [x, _, x, _, x] // we can make 3 bouquets. The answer is 3. Example 2: Input: bloomDay = [1,10,3,10,2], m = 3, k = 2 Output: -1 Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1. Example 3: Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3 Output: 12 Explanation: We need 2 bouquets each should have 3 flowers. Here is the garden after the 7 and 12 days: After day 7: [x, x, x, x, _, x, x] We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent. After day 12: [x, x, x, x, x, x, x] It is obvious that we can make two bouquets in different ways. &nbsp; Constraints: bloomDay.length == n 1 &lt;= n &lt;= 105 1 &lt;= bloomDay[i] &lt;= 109 1 &lt;= m &lt;= 106 1 &lt;= k &lt;= n"
    },
    {
      "number": 1483,
      "title": "Kth Ancestor of a Tree Node",
      "titleSlug": "kth-ancestor-of-a-tree-node",
      "difficulty": "Hard",
      "tags": [
        "Binary Search",
        "Dynamic Programming",
        "Tree",
        "Depth-First Search",
        "Breadth-First Search",
        "Design"
      ],
      "description": "You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node. The kth ancestor of a tree node is the kth node in the path from that node to the root node. Implement the TreeAncestor class: TreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array. int getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1. &nbsp; Example 1: Input [&quot;TreeAncestor&quot;, &quot;getKthAncestor&quot;, &quot;getKthAncestor&quot;, &quot;getKthAncestor&quot;] [[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]] Output [null, 1, 0, -1] Explanation TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]); treeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3 treeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5 treeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor &nbsp; Constraints: 1 &lt;= k &lt;= n &lt;= 5 * 104 parent.length == n parent[0] == -1 0 &lt;= parent[i] &lt; n for all 0 &lt; i &lt; n 0 &lt;= node &lt; n There will be at most 5 * 104 queries."
    },
    {
      "number": 1484,
      "title": "Group Sold Products By The Date",
      "titleSlug": "group-sold-products-by-the-date",
      "difficulty": "Easy",
      "tags": [
        "Database"
      ],
      "description": "Table Activities: +-------------+---------+ | Column Name | Type | +-------------+---------+ | sell_date | date | | product | varchar | +-------------+---------+ There is no primary key (column with unique values) for this table. It may contain duplicates. Each row of this table contains the product name and the date it was sold in a market. &nbsp; Write a solution to find for each date the number of different products sold and their names. The sold products names for each date should be sorted lexicographically. Return the result table ordered by sell_date. The&nbsp;result format is in the following example. &nbsp; Example 1: Input: Activities table: +------------+------------+ | sell_date | product | +------------+------------+ | 2020-05-30 | Headphone | | 2020-06-01 | Pencil | | 2020-06-02 | Mask | | 2020-05-30 | Basketball | | 2020-06-01 | Bible | | 2020-06-02 | Mask | | 2020-05-30 | T-Shirt | +------------+------------+ Output: +------------+----------+------------------------------+ | sell_date | num_sold | products | +------------+----------+------------------------------+ | 2020-05-30 | 3 | Basketball,Headphone,T-shirt | | 2020-06-01 | 2 | Bible,Pencil | | 2020-06-02 | 1 | Mask | +------------+----------+------------------------------+ Explanation: For 2020-05-30, Sold items were (Headphone, Basketball, T-shirt), we sort them lexicographically and separate them by a comma. For 2020-06-01, Sold items were (Pencil, Bible), we sort them lexicographically and separate them by a comma. For 2020-06-02, the Sold item is (Mask), we just return it."
    },
    {
      "number": 1486,
      "title": "XOR Operation in an Array",
      "titleSlug": "xor-operation-in-an-array",
      "difficulty": "Easy",
      "tags": [
        "Math",
        "Bit Manipulation"
      ],
      "description": "You are given an integer n and an integer start. Define an array nums where nums[i] = start + 2 * i (0-indexed) and n == nums.length. Return the bitwise XOR of all elements of nums. &nbsp; Example 1: Input: n = 5, start = 0 Output: 8 Explanation: Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8. Where &quot;^&quot; corresponds to bitwise XOR operator. Example 2: Input: n = 4, start = 3 Output: 8 Explanation: Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8. &nbsp; Constraints: 1 &lt;= n &lt;= 1000 0 &lt;= start &lt;= 1000 n == nums.length"
    },
    {
      "number": 1487,
      "title": "Making File Names Unique",
      "titleSlug": "making-file-names-unique",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "String"
      ],
      "description": "Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i]. Since two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique. Return an array of strings of length n where ans[i] is the actual name the system will assign to the ith folder when you create it. &nbsp; Example 1: Input: names = [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;] Output: [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;] Explanation: Let&#39;s see how the file system creates folder names: &quot;pes&quot; --&gt; not assigned before, remains &quot;pes&quot; &quot;fifa&quot; --&gt; not assigned before, remains &quot;fifa&quot; &quot;gta&quot; --&gt; not assigned before, remains &quot;gta&quot; &quot;pes(2019)&quot; --&gt; not assigned before, remains &quot;pes(2019)&quot; Example 2: Input: names = [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta&quot;,&quot;avalon&quot;] Output: [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta(2)&quot;,&quot;avalon&quot;] Explanation: Let&#39;s see how the file system creates folder names: &quot;gta&quot; --&gt; not assigned before, remains &quot;gta&quot; &quot;gta(1)&quot; --&gt; not assigned before, remains &quot;gta(1)&quot; &quot;gta&quot; --&gt; the name is reserved, system adds (k), since &quot;gta(1)&quot; is also reserved, systems put k = 2. it becomes &quot;gta(2)&quot; &quot;avalon&quot; --&gt; not assigned before, remains &quot;avalon&quot; Example 3: Input: names = [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece&quot;] Output: [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece(4)&quot;] Explanation: When the last folder is created, the smallest positive valid k is 4, and it becomes &quot;onepiece(4)&quot;. &nbsp; Constraints: 1 &lt;= names.length &lt;= 5 * 104 1 &lt;= names[i].length &lt;= 20 names[i] consists of lowercase English letters, digits, and/or round brackets."
    },
    {
      "number": 1488,
      "title": "Avoid Flood in The City",
      "titleSlug": "avoid-flood-in-the-city",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Binary Search",
        "Greedy",
        "Heap (Priority Queue)"
      ],
      "description": "Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the nth lake, the nth lake becomes full of water. If it rains over a lake that is full of water, there will be a flood. Your goal is to avoid floods in any lake. Given an integer array rains where: rains[i] &gt; 0 means there will be rains over the rains[i] lake. rains[i] == 0 means there are no rains this day and you can choose one lake this day and dry it. Return an array ans where: ans.length == rains.length ans[i] == -1 if rains[i] &gt; 0. ans[i] is the lake you choose to dry in the ith day if rains[i] == 0. If there are multiple valid answers return any of them. If it is impossible to avoid flood return an empty array. Notice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes. &nbsp; Example 1: Input: rains = [1,2,3,4] Output: [-1,-1,-1,-1] Explanation: After the first day full lakes are [1] After the second day full lakes are [1,2] After the third day full lakes are [1,2,3] After the fourth day full lakes are [1,2,3,4] There&#39;s no day to dry any lake and there is no flood in any lake. Example 2: Input: rains = [1,2,0,0,2,1] Output: [-1,-1,2,1,-1,-1] Explanation: After the first day full lakes are [1] After the second day full lakes are [1,2] After the third day, we dry lake 2. Full lakes are [1] After the fourth day, we dry lake 1. There is no full lakes. After the fifth day, full lakes are [2]. After the sixth day, full lakes are [1,2]. It is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is another acceptable scenario. Example 3: Input: rains = [1,2,0,1,2] Output: [] Explanation: After the second day, full lakes are [1,2]. We have to dry one lake in the third day. After that, it will rain over lakes [1,2]. It&#39;s easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood. &nbsp; Constraints: 1 &lt;= rains.length &lt;= 105 0 &lt;= rains[i] &lt;= 109"
    },
    {
      "number": 1489,
      "title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
      "titleSlug": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
      "difficulty": "Hard",
      "tags": [
        "Union Find",
        "Graph",
        "Sorting",
        "Minimum Spanning Tree",
        "Strongly Connected Component"
      ],
      "description": "Given a weighted undirected connected graph with n&nbsp;vertices numbered from 0 to n - 1,&nbsp;and an array edges&nbsp;where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes&nbsp;ai&nbsp;and bi. A minimum spanning tree (MST) is a subset of the graph&#39;s edges that connects all vertices without cycles&nbsp;and with the minimum possible total edge weight. Find all the critical and pseudo-critical edges in the given graph&#39;s minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a&nbsp;critical edge. On&nbsp;the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all. Note that you can return the indices of the edges in any order. &nbsp; Example 1: Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]] Output: [[0,1],[2,3,4,5]] Explanation: The figure above describes the graph. The following figure shows all the possible MSTs: Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output. The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output. Example 2: Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]] Output: [[],[0,1,2,3]] Explanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical. &nbsp; Constraints: 2 &lt;= n &lt;= 100 1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2) edges[i].length == 3 0 &lt;= ai &lt; bi &lt; n 1 &lt;= weighti&nbsp;&lt;= 1000 All pairs (ai, bi) are distinct."
    },
    {
      "number": 1491,
      "title": "Average Salary Excluding the Minimum and Maximum Salary",
      "titleSlug": "average-salary-excluding-the-minimum-and-maximum-salary",
      "difficulty": "Easy",
      "tags": [
        "Array",
        "Sorting"
      ],
      "description": "You are given an array of unique integers salary where salary[i] is the salary of the ith employee. Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted. &nbsp; Example 1: Input: salary = [4000,3000,1000,2000] Output: 2500.00000 Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively. Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500 Example 2: Input: salary = [1000,2000,3000] Output: 2000.00000 Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively. Average salary excluding minimum and maximum salary is (2000) / 1 = 2000 &nbsp; Constraints: 3 &lt;= salary.length &lt;= 100 1000 &lt;= salary[i] &lt;= 106 All the integers of salary are unique."
    },
    {
      "number": 1492,
      "title": "The kth Factor of n",
      "titleSlug": "the-kth-factor-of-n",
      "difficulty": "Medium",
      "tags": [
        "Math",
        "Number Theory"
      ],
      "description": "You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0. Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors. &nbsp; Example 1: Input: n = 12, k = 3 Output: 3 Explanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3. Example 2: Input: n = 7, k = 2 Output: 7 Explanation: Factors list is [1, 7], the 2nd factor is 7. Example 3: Input: n = 4, k = 4 Output: -1 Explanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1. &nbsp; Constraints: 1 &lt;= k &lt;= n &lt;= 1000 &nbsp; Follow up: Could you solve this problem in less than O(n) complexity?"
    },
    {
      "number": 1493,
      "title": "Longest Subarray of 1's After Deleting One Element",
      "titleSlug": "longest-subarray-of-1s-after-deleting-one-element",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Dynamic Programming",
        "Sliding Window"
      ],
      "description": "Given a binary array nums, you should delete one element from it. Return the size of the longest non-empty subarray containing only 1&#39;s in the resulting array. Return 0 if there is no such subarray. &nbsp; Example 1: Input: nums = [1,1,0,1] Output: 3 Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1&#39;s. Example 2: Input: nums = [0,1,1,1,0,1,1,0,1] Output: 5 Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1&#39;s is [1,1,1,1,1]. Example 3: Input: nums = [1,1,1] Output: 2 Explanation: You must delete one element. &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 nums[i] is either 0 or 1."
    },
    {
      "number": 1494,
      "title": "Parallel Courses II",
      "titleSlug": "parallel-courses-ii",
      "difficulty": "Hard",
      "tags": [
        "Dynamic Programming",
        "Bit Manipulation",
        "Graph",
        "Bitmask"
      ],
      "description": "You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given an array relations where relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei: course prevCoursei has to be taken before course nextCoursei. Also, you are given the integer k. In one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semesters for the courses you are taking. Return the minimum number of semesters needed to take all courses. The testcases will be generated such that it is possible to take every course. &nbsp; Example 1: Input: n = 4, relations = [[2,1],[3,1],[1,4]], k = 2 Output: 3 Explanation: The figure above represents the given graph. In the first semester, you can take courses 2 and 3. In the second semester, you can take course 1. In the third semester, you can take course 4. Example 2: Input: n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2 Output: 4 Explanation: The figure above represents the given graph. In the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester. In the second semester, you can take course 4. In the third semester, you can take course 1. In the fourth semester, you can take course 5. &nbsp; Constraints: 1 &lt;= n &lt;= 15 1 &lt;= k &lt;= n 0 &lt;= relations.length &lt;= n * (n-1) / 2 relations[i].length == 2 1 &lt;= prevCoursei, nextCoursei &lt;= n prevCoursei != nextCoursei All the pairs [prevCoursei, nextCoursei] are unique. The given graph is a directed acyclic graph."
    },
    {
      "number": 1496,
      "title": "Path Crossing",
      "titleSlug": "path-crossing",
      "difficulty": "Easy",
      "tags": [
        "Hash Table",
        "String"
      ],
      "description": "Given a string path, where path[i] = &#39;N&#39;, &#39;S&#39;, &#39;E&#39; or &#39;W&#39;, each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path. Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise. &nbsp; Example 1: Input: path = &quot;NES&quot; Output: false Explanation: Notice that the path doesn&#39;t cross any point more than once. Example 2: Input: path = &quot;NESWW&quot; Output: true Explanation: Notice that the path visits the origin twice. &nbsp; Constraints: 1 &lt;= path.length &lt;= 104 path[i] is either &#39;N&#39;, &#39;S&#39;, &#39;E&#39;, or &#39;W&#39;."
    },
    {
      "number": 1497,
      "title": "Check If Array Pairs Are Divisible by k",
      "titleSlug": "check-if-array-pairs-are-divisible-by-k",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Hash Table",
        "Counting"
      ],
      "description": "Given an array of integers arr of even length n and an integer k. We want to divide the array into exactly n / 2 pairs such that the sum of each pair is divisible by k. Return true If you can find a way to do that or false otherwise. &nbsp; Example 1: Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5 Output: true Explanation: Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10). Example 2: Input: arr = [1,2,3,4,5,6], k = 7 Output: true Explanation: Pairs are (1,6),(2,5) and(3,4). Example 3: Input: arr = [1,2,3,4,5,6], k = 10 Output: false Explanation: You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10. &nbsp; Constraints: arr.length == n 1 &lt;= n &lt;= 105 n is even. -109 &lt;= arr[i] &lt;= 109 1 &lt;= k &lt;= 105"
    },
    {
      "number": 1498,
      "title": "Number of Subsequences That Satisfy the Given Sum Condition",
      "titleSlug": "number-of-subsequences-that-satisfy-the-given-sum-condition",
      "difficulty": "Medium",
      "tags": [
        "Array",
        "Two Pointers",
        "Binary Search",
        "Sorting"
      ],
      "description": "You are given an array of integers nums and an integer target. Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target. Since the answer may be too large, return it modulo 109 + 7. &nbsp; Example 1: Input: nums = [3,5,6,7], target = 9 Output: 4 Explanation: There are 4 subsequences that satisfy the condition. [3] -&gt; Min value + max value &lt;= target (3 + 3 &lt;= 9) [3,5] -&gt; (3 + 5 &lt;= 9) [3,5,6] -&gt; (3 + 6 &lt;= 9) [3,6] -&gt; (3 + 6 &lt;= 9) Example 2: Input: nums = [3,3,6,8], target = 10 Output: 6 Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers). [3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6] Example 3: Input: nums = [2,3,3,4,6,7], target = 12 Output: 61 Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]). Number of valid subsequences (63 - 2 = 61). &nbsp; Constraints: 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 106 1 &lt;= target &lt;= 106"
    },
    {
      "number": 1499,
      "title": "Max Value of Equation",
      "titleSlug": "max-value-of-equation",
      "difficulty": "Hard",
      "tags": [
        "Array",
        "Queue",
        "Sliding Window",
        "Heap (Priority Queue)",
        "Monotonic Queue"
      ],
      "description": "You are given an array points containing the coordinates of points on a 2D plane, sorted by the x-values, where points[i] = [xi, yi] such that xi &lt; xj for all 1 &lt;= i &lt; j &lt;= points.length. You are also given an integer k. Return the maximum value of the equation yi + yj + |xi - xj| where |xi - xj| &lt;= k and 1 &lt;= i &lt; j &lt;= points.length. It is guaranteed that there exists at least one pair of points that satisfy the constraint |xi - xj| &lt;= k. &nbsp; Example 1: Input: points = [[1,3],[2,0],[5,10],[6,-10]], k = 1 Output: 4 Explanation: The first two points satisfy the condition |xi - xj| &lt;= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1. No other pairs satisfy the condition, so we return the max of 4 and 1. Example 2: Input: points = [[0,0],[3,0],[9,2]], k = 3 Output: 3 Explanation: Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3. &nbsp; Constraints: 2 &lt;= points.length &lt;= 105 points[i].length == 2 -108 &lt;= xi, yi &lt;= 108 0 &lt;= k &lt;= 2 * 108 xi &lt; xj for all 1 &lt;= i &lt; j &lt;= points.length xi form a strictly increasing sequence."
    }
  ]
}