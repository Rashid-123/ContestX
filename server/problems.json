{
    "problems": [
        {
            "number": 101,
            "title": "Symmetric Tree",
            "tags": [
                "Tree",
                "Depth-First Search",
                "Breadth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Easy",
            "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center)."
        },
        {
            "number": 102,
            "title": "Binary Tree Level Order Traversal",
            "tags": [
                "Tree",
                "Breadth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level)."
        },
        {
            "number": 103,
            "title": "Binary Tree Zigzag Level Order Traversal",
            "tags": [
                "Tree",
                "Breadth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between)."
        },
        {
            "number": 104,
            "title": "Maximum Depth of Binary Tree",
            "tags": [
                "Tree",
                "Depth-First Search",
                "Breadth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Easy",
            "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node."
        },
        {
            "number": 105,
            "title": "Construct Binary Tree from Preorder and Inorder Traversal",
            "tags": [
                "Array",
                "Hash Table",
                "Divide and Conquer",
                "Tree",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree."
        },
        {
            "number": 106,
            "title": "Construct Binary Tree from Inorder and Postorder Traversal",
            "tags": [
                "Array",
                "Hash Table",
                "Divide and Conquer",
                "Tree",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree."
        },
        {
            "number": 107,
            "title": "Binary Tree Level Order Traversal II",
            "tags": [
                "Tree",
                "Breadth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root)."
        },
        {
            "number": 108,
            "title": "Convert Sorted Array to Binary Search Tree",
            "tags": [
                "Array",
                "Divide and Conquer",
                "Tree",
                "Binary Search Tree",
                "Binary Tree"
            ],
            "difficulty": "Easy",
            "description": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree."
        },
        {
            "number": 109,
            "title": "Convert Sorted List to Binary Search Tree",
            "tags": [
                "Linked List",
                "Divide and Conquer",
                "Tree",
                "Binary Search Tree",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree."
        },
        {
            "number": 110,
            "title": "Balanced Binary Tree",
            "tags": [
                "Tree",
                "Depth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Easy",
            "description": "Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1."
        },
        {
            "number": 111,
            "title": "Minimum Depth of Binary Tree",
            "tags": [
                "Tree",
                "Depth-First Search",
                "Breadth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Easy",
            "description": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node."
        },
        {
            "number": 112,
            "title": "Path Sum",
            "tags": [
                "Tree",
                "Depth-First Search",
                "Breadth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Easy",
            "description": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum."
        },
        {
            "number": 113,
            "title": "Path Sum II",
            "tags": [
                "Tree",
                "Depth-First Search",
                "Backtracking",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum."
        },
        {
            "number": 114,
            "title": "Flatten Binary Tree to Linked List",
            "tags": [
                "Stack",
                "Tree",
                "Depth-First Search",
                "Linked List",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "Given the root of a binary tree, flatten the tree into a linked list, where the linked list is in the same order as a pre-order traversal of the binary tree."
        },
        {
            "number": 115,
            "title": "Distinct Subsequences",
            "tags": [
                "String",
                "Dynamic Programming"
            ],
            "difficulty": "Hard",
            "description": "Given two strings s and t, return the number of distinct subsequences of s which equals t."
        },
        {
            "number": 116,
            "title": "Populating Next Right Pointers in Each Node",
            "tags": [
                "Tree",
                "Depth-First Search",
                "Breadth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL."
        },
        {
            "number": 117,
            "title": "Populating Next Right Pointers in Each Node II",
            "tags": [
                "Tree",
                "Depth-First Search",
                "Breadth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "Given a binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL."
        },
        {
            "number": 118,
            "title": "Pascal's Triangle",
            "tags": [
                "Array",
                "Dynamic Programming"
            ],
            "difficulty": "Easy",
            "description": "Given an integer numRows, return the first numRows of Pascal's triangle."
        },
        {
            "number": 119,
            "title": "Pascal's Triangle II",
            "tags": [
                "Array",
                "Dynamic Programming"
            ],
            "difficulty": "Easy",
            "description": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle."
        },
        {
            "number": 120,
            "title": "Triangle",
            "tags": [
                "Array",
                "Dynamic Programming"
            ],
            "difficulty": "Medium",
            "description": "Given a triangle array, return the minimum path sum from top to bottom."
        },
        {
            "number": 121,
            "title": "Best Time to Buy and Sell Stock",
            "tags": [
                "Array",
                "Dynamic Programming"
            ],
            "difficulty": "Easy",
            "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0."
        },
        {
            "number": 122,
            "title": "Best Time to Buy and Sell Stock II",
            "tags": [
                "Array",
                "Dynamic Programming",
                "Greedy"
            ],
            "difficulty": "Medium",
            "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve."
        },
        {
            "number": 123,
            "title": "Best Time to Buy and Sell Stock III",
            "tags": [
                "Array",
                "Dynamic Programming"
            ],
            "difficulty": "Hard",
            "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete at most two transactions."
        },
        {
            "number": 124,
            "title": "Binary Tree Maximum Path Sum",
            "tags": [
                "Tree",
                "Depth-First Search",
                "Dynamic Programming",
                "Binary Tree"
            ],
            "difficulty": "Hard",
            "description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Find the maximum path sum."
        },
        {
            "number": 125,
            "title": "Valid Palindrome",
            "tags": [
                "Two Pointers",
                "String"
            ],
            "difficulty": "Easy",
            "description": "Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases."
        },
        {
            "number": 126,
            "title": "Word Ladder II",
            "tags": [
                "Hash Table",
                "String",
                "Breadth-First Search",
                "Backtracking"
            ],
            "difficulty": "Hard",
            "description": "Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, such that: Only one letter can be changed at a time, and each transformed word must exist in the word list."
        },
        {
            "number": 127,
            "title": "Word Ladder",
            "tags": [
                "Hash Table",
                "String",
                "Breadth-First Search"
            ],
            "difficulty": "Hard",
            "description": "Given two words beginWord and endWord, and a dictionary wordList, return the length of the shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time, and each transformed word must exist in the word list."
        },
        {
            "number": 128,
            "title": "Longest Consecutive Sequence",
            "tags": [
                "Array",
                "Hash Table",
                "Union Find"
            ],
            "difficulty": "Medium",
            "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence."
        },
        {
            "number": 129,
            "title": "Sum Root to Leaf Numbers",
            "tags": [
                "Tree",
                "Depth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "You are given the root of a binary tree containing digits from 0 to 9 only. Each root-to-leaf path in the tree represents a number. Return the total sum of all root-to-leaf numbers."
        },
        {
            "number": 130,
            "title": "Surrounded Regions",
            "tags": [
                "Array",
                "Depth-First Search",
                "Breadth-First Search",
                "Union Find",
                "Matrix"
            ],
            "difficulty": "Medium",
            "description": "Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'."
        },
        {
            "number": 131,
            "title": "Palindrome Partitioning",
            "tags": [
                "String",
                "Dynamic Programming",
                "Backtracking"
            ],
            "difficulty": "Medium",
            "description": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s."
        },
        {
            "number": 132,
            "title": "Palindrome Partitioning II",
            "tags": [
                "String",
                "Dynamic Programming"
            ],
            "difficulty": "Hard",
            "description": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s."
        },
        {
            "number": 133,
            "title": "Clone Graph",
            "tags": [
                "Hash Table",
                "Depth-First Search",
                "Breadth-First Search",
                "Graph"
            ],
            "difficulty": "Medium",
            "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph."
        },
        {
            "number": 134,
            "title": "Gas Station",
            "tags": [
                "Array",
                "Greedy"
            ],
            "difficulty": "Medium",
            "description": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1."
        },
        {
            "number": 135,
            "title": "Candy",
            "tags": [
                "Array",
                "Greedy"
            ],
            "difficulty": "Hard",
            "description": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children."
        },
        {
            "number": 136,
            "title": "Single Number",
            "tags": [
                "Array",
                "Bit Manipulation"
            ],
            "difficulty": "Easy",
            "description": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one."
        },
        {
            "number": 137,
            "title": "Single Number II",
            "tags": [
                "Array",
                "Bit Manipulation"
            ],
            "difficulty": "Medium",
            "description": "Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it."
        },
        {
            "number": 138,
            "title": "Copy List with Random Pointer",
            "tags": [
                "Hash Table",
                "Linked List"
            ],
            "difficulty": "Medium",
            "description": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list."
        },
        {
            "number": 139,
            "title": "Word Break",
            "tags": [
                "Hash Table",
                "String",
                "Dynamic Programming",
                "Trie",
                "Memoization"
            ],
            "difficulty": "Medium",
            "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words."
        },
        {
            "number": 140,
            "title": "Word Break II",
            "tags": [
                "Hash Table",
                "String",
                "Dynamic Programming",
                "Backtracking",
                "Trie",
                "Memoization"
            ],
            "difficulty": "Hard",
            "description": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order."
        },
        {
            "number": 141,
            "title": "Linked List Cycle",
            "tags": [
                "Hash Table",
                "Linked List",
                "Two Pointers"
            ],
            "difficulty": "Easy",
            "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it."
        },
        {
            "number": 142,
            "title": "Linked List Cycle II",
            "tags": [
                "Hash Table",
                "Linked List",
                "Two Pointers"
            ],
            "difficulty": "Medium",
            "description": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null."
        },
        {
            "number": 143,
            "title": "Reorder List",
            "tags": [
                "Linked List",
                "Two Pointers",
                "Stack",
                "Recursion"
            ],
            "difficulty": "Medium",
            "description": "You are given the head of a singly linked-list. The list can be represented as: L0 → L1 → … → Ln - 1 → Ln. Reorder the list to be on the following form: L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …"
        },
        {
            "number": 144,
            "title": "Binary Tree Preorder Traversal",
            "tags": [
                "Stack",
                "Tree",
                "Depth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Easy",
            "description": "Given the root of a binary tree, return the preorder traversal of its nodes' values."
        },
        {
            "number": 145,
            "title": "Binary Tree Postorder Traversal",
            "tags": [
                "Stack",
                "Tree",
                "Depth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Easy",
            "description": "Given the root of a binary tree, return the postorder traversal of its nodes' values."
        },
        {
            "number": 146,
            "title": "LRU Cache",
            "tags": [
                "Hash Table",
                "Linked List",
                "Design",
                "Doubly-Linked List"
            ],
            "difficulty": "Medium",
            "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache."
        },
        {
            "number": 147,
            "title": "Insertion Sort List",
            "tags": [
                "Linked List",
                "Sorting"
            ],
            "difficulty": "Medium",
            "description": "Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head."
        },
        {
            "number": 148,
            "title": "Sort List",
            "tags": [
                "Linked List",
                "Two Pointers",
                "Divide and Conquer",
                "Sorting",
                "Merge Sort"
            ],
            "difficulty": "Medium",
            "description": "Given the head of a linked list, return the list after sorting it in ascending order."
        },
        {
            "number": 149,
            "title": "Max Points on a Line",
            "tags": [
                "Array",
                "Hash Table",
                "Math",
                "Geometry"
            ],
            "difficulty": "Hard",
            "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line."
        },
        {
            "number": 150,
            "title": "Evaluate Reverse Polish Notation",
            "tags": [
                "Array",
                "Math",
                "Stack"
            ],
            "difficulty": "Medium",
            "description": "Evaluate the value of an arithmetic expression in Reverse Polish Notation."
        },
        {
            "number": 151,
            "title": "Reverse Words in a String",
            "tags": [
                "Two Pointers",
                "String"
            ],
            "difficulty": "Medium",
            "description": "Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space."
        },
        {
            "number": 152,
            "title": "Maximum Product Subarray",
            "tags": [
                "Array",
                "Dynamic Programming"
            ],
            "difficulty": "Medium",
            "description": "Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product."
        },
        {
            "number": 153,
            "title": "Find Minimum in Rotated Sorted Array",
            "tags": [
                "Array",
                "Binary Search"
            ],
            "difficulty": "Medium",
            "description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. Given the sorted rotated array nums, return the minimum element of this array."
        },
        {
            "number": 154,
            "title": "Find Minimum in Rotated Sorted Array II",
            "tags": [
                "Array",
                "Binary Search"
            ],
            "difficulty": "Hard",
            "description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array."
        },
        {
            "number": 155,
            "title": "Min Stack",
            "tags": [
                "Stack",
                "Design"
            ],
            "difficulty": "Medium",
            "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time."
        },
        {
            "number": 156,
            "title": "Binary Tree Upside Down",
            "tags": [
                "Tree",
                "Depth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "Given the root of a binary tree, turn the tree upside down and return the new root. You can turn a binary tree upside down with the following steps: The original left child becomes the new root. The original root becomes the new right child. The original right child becomes the new left child."
        },
        {
            "number": 157,
            "title": "Read N Characters Given Read4",
            "tags": [
                "String",
                "Interactive",
                "Simulation"
            ],
            "difficulty": "Easy",
            "description": "Given a file and assume that you can only read the file using a given method read4, implement a method to read n characters."
        },
        {
            "number": 158,
            "title": "Read N Characters Given Read4 II - Call Multiple Times",
            "tags": [
                "String",
                "Interactive",
                "Simulation"
            ],
            "difficulty": "Hard",
            "description": "Given a file and assume that you can only read the file using a given method read4, implement a method read to read n characters. Your method read may be called multiple times."
        },
        {
            "number": 159,
            "title": "Longest Substring with At Most Two Distinct Characters",
            "tags": [
                "Hash Table",
                "String",
                "Sliding Window"
            ],
            "difficulty": "Medium",
            "description": "Given a string s, return the length of the longest substring that contains at most two distinct characters."
        },
        {
            "number": 160,
            "title": "Intersection of Two Linked Lists",
            "tags": [
                "Hash Table",
                "Linked List",
                "Two Pointers"
            ],
            "difficulty": "Easy",
            "description": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null."
        },
        {
            "number": 161,
            "title": "One Edit Distance",
            "tags": [
                "String",
                "Two Pointers"
            ],
            "difficulty": "Medium",
            "description": "Given two strings s and t, return true if they are both one edit distance apart, otherwise return false. One edit distance means inserting, deleting, or replacing exactly one character."
        },
        {
            "number": 162,
            "title": "Find Peak Element",
            "tags": [
                "Array",
                "Binary Search"
            ],
            "difficulty": "Medium",
            "description": "A peak element is an element that is strictly greater than its neighbors. Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks."
        },
        {
            "number": 163,
            "title": "Missing Ranges",
            "tags": [
                "Array"
            ],
            "difficulty": "Easy",
            "description": "You are given an inclusive range [lower, upper] and a sorted unique integer array nums, where all elements are in the inclusive range. Return the shortest sorted list of ranges that covers all the numbers in the array exactly."
        },
        {
            "number": 164,
            "title": "Maximum Gap",
            "tags": [
                "Array",
                "Sorting",
                "Bucket Sort",
                "Radix Sort"
            ],
            "difficulty": "Hard",
            "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0."
        },
        {
            "number": 165,
            "title": "Compare Version Numbers",
            "tags": [
                "Two Pointers",
                "String"
            ],
            "difficulty": "Medium",
            "description": "Given two version numbers, version1 and version2, compare them. Version numbers consist of one or more revisions joined by a dot '.'. Each revision consists of digits and may contain leading zeros."
        },
        {
            "number": 166,
            "title": "Fraction to Recurring Decimal",
            "tags": [
                "Hash Table",
                "Math",
                "String"
            ],
            "difficulty": "Medium",
            "description": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses."
        },
        {
            "number": 167,
            "title": "Two Sum II - Input Array Is Sorted",
            "tags": [
                "Array",
                "Two Pointers",
                "Binary Search"
            ],
            "difficulty": "Medium",
            "description": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number."
        },
        {
            "number": 168,
            "title": "Excel Sheet Column Title",
            "tags": [
                "Math",
                "String"
            ],
            "difficulty": "Easy",
            "description": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet."
        },
        {
            "number": 169,
            "title": "Majority Element",
            "tags": [
                "Array",
                "Hash Table",
                "Divide and Conquer",
                "Sorting",
                "Counting"
            ],
            "difficulty": "Easy",
            "description": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times."
        },
        {
            "number": 170,
            "title": "Two Sum III - Data structure design",
            "tags": [
                "Array",
                "Hash Table",
                "Design",
                "Two Pointers"
            ],
            "difficulty": "Easy",
            "description": "Design and implement a TwoSum class. It should support the following operations: add and find."
        },
        {
            "number": 171,
            "title": "Excel Sheet Column Number",
            "tags": [
                "Math",
                "String"
            ],
            "difficulty": "Easy",
            "description": "Given a string columnTitle that represents the column title as appear in an Excel sheet, return its corresponding column number."
        },
        {
            "number": 172,
            "title": "Factorial Trailing Zeroes",
            "tags": [
                "Math"
            ],
            "difficulty": "Medium",
            "description": "Given an integer n, return the number of trailing zeroes in n!."
        },
        {
            "number": 173,
            "title": "Binary Search Tree Iterator",
            "tags": [
                "Stack",
                "Tree",
                "Design",
                "Binary Search Tree",
                "Binary Tree",
                "Iterator"
            ],
            "difficulty": "Medium",
            "description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST)."
        },
        {
            "number": 174,
            "title": "Dungeon Game",
            "tags": [
                "Array",
                "Dynamic Programming",
                "Matrix"
            ],
            "difficulty": "Hard",
            "description": "The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess."
        },
        {
            "number": 175,
            "title": "Combine Two Tables",
            "tags": [
                "Database"
            ],
            "difficulty": "Easy",
            "description": "Write an SQL query to report the first name, last name, city, and state of each person in the Person table. If the address of a personId is not present in the Address table, report null instead."
        },
        {
            "number": 176,
            "title": "Second Highest Salary",
            "tags": [
                "Database"
            ],
            "difficulty": "Medium",
            "description": "Write an SQL query to report the second highest salary from the Employee table. If there is no second highest salary, the query should report null."
        },
        {
            "number": 177,
            "title": "Nth Highest Salary",
            "tags": [
                "Database"
            ],
            "difficulty": "Medium",
            "description": "Write an SQL query to report the nth highest salary from the Employee table. If there is no nth highest salary, the query should report null."
        },
        {
            "number": 178,
            "title": "Rank Scores",
            "tags": [
                "Database"
            ],
            "difficulty": "Medium",
            "description": "Write an SQL query to rank the scores. The ranking should be calculated according to the following rules: The scores should be ranked from the highest to the lowest. If there is a tie between two scores, both should have the same ranking."
        },
        {
            "number": 179,
            "title": "Largest Number",
            "tags": [
                "Array",
                "String",
                "Greedy",
                "Sorting"
            ],
            "difficulty": "Medium",
            "description": "Given a list of non-negative integers nums, arrange them such that they form the largest number."
        },
        {
            "number": 180,
            "title": "Consecutive Numbers",
            "tags": [
                "Database"
            ],
            "difficulty": "Medium",
            "description": "Write an SQL query to find all numbers that appear at least three times consecutively."
        },
        {
            "number": 181,
            "title": "Employees Earning More Than Their Managers",
            "tags": [
                "Database"
            ],
            "difficulty": "Easy",
            "description": "Write an SQL query to find the employees who earn more than their managers."
        },
        {
            "number": 182,
            "title": "Duplicate Emails",
            "tags": [
                "Database"
            ],
            "difficulty": "Easy",
            "description": "Write an SQL query to report all the duplicate emails."
        },
        {
            "number": 183,
            "title": "Customers Who Never Order",
            "tags": [
                "Database"
            ],
            "difficulty": "Easy",
            "description": "Write an SQL query to report all customers who never order anything."
        },
        {
            "number": 184,
            "title": "Department Highest Salary",
            "tags": [
                "Database"
            ],
            "difficulty": "Medium",
            "description": "Write an SQL query to find employees who have the highest salary in each of the departments."
        },
        {
            "number": 185,
            "title": "Department Top Three Salaries",
            "tags": [
                "Database"
            ],
            "difficulty": "Hard",
            "description": "Write an SQL query to find the employees who are high earners in each of the departments."
        },
        {
            "number": 186,
            "title": "Reverse Words in a String II",
            "tags": [
                "Two Pointers",
                "String"
            ],
            "difficulty": "Medium",
            "description": "Given a character array s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by a single space."
        },
        {
            "number": 187,
            "title": "Repeated DNA Sequences",
            "tags": [
                "Hash Table",
                "String",
                "Bit Manipulation",
                "Sliding Window",
                "Rolling Hash",
                "Hash Function"
            ],
            "difficulty": "Medium",
            "description": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule."
        },
        {
            "number": 188,
            "title": "Best Time to Buy and Sell Stock IV",
            "tags": [
                "Array",
                "Dynamic Programming"
            ],
            "difficulty": "Hard",
            "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions."
        },
        {
            "number": 189,
            "title": "Rotate Array",
            "tags": [
                "Array",
                "Math",
                "Two Pointers"
            ],
            "difficulty": "Medium",
            "description": "Given an array, rotate the array to the right by k steps, where k is non-negative."
        },
        {
            "number": 190,
            "title": "Reverse Bits",
            "tags": [
                "Divide and Conquer",
                "Bit Manipulation"
            ],
            "difficulty": "Easy",
            "description": "Reverse bits of a given 32 bits unsigned integer."
        },
        {
            "number": 191,
            "title": "Number of 1 Bits",
            "tags": [
                "Bit Manipulation"
            ],
            "difficulty": "Easy",
            "description": "Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight)."
        },
        {
            "number": 192,
            "title": "Word Frequency",
            "tags": [
                "Shell"
            ],
            "difficulty": "Medium",
            "description": "Write a bash script to calculate the frequency of each word in a text file words.txt."
        },
        {
            "number": 193,
            "title": "Valid Phone Numbers",
            "tags": [
                "Shell"
            ],
            "difficulty": "Easy",
            "description": "Given a text file file.txt that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers."
        },
        {
            "number": 194,
            "title": "Transpose File",
            "tags": [
                "Shell"
            ],
            "difficulty": "Medium",
            "description": "Given a text file file.txt, transpose its content."
        },
        {
            "number": 195,
            "title": "Tenth Line",
            "tags": [
                "Shell"
            ],
            "difficulty": "Easy",
            "description": "Given a text file file.txt, print just the 10th line of the file."
        },
        {
            "number": 196,
            "title": "Delete Duplicate Emails",
            "tags": [
                "Database"
            ],
            "difficulty": "Easy",
            "description": "Write an SQL query to delete all the duplicate emails, keeping only one unique email with the smallest id."
        },
        {
            "number": 197,
            "title": "Rising Temperature",
            "tags": [
                "Database"
            ],
            "difficulty": "Easy",
            "description": "Write an SQL query to find all dates' Id with higher temperatures compared to its previous dates (yesterday)."
        },
        {
            "number": 198,
            "title": "House Robber",
            "tags": [
                "Array",
                "Dynamic Programming"
            ],
            "difficulty": "Medium",
            "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night."
        },
        {
            "number": 199,
            "title": "Binary Tree Right Side View",
            "tags": [
                "Tree",
                "Depth-First Search",
                "Breadth-First Search",
                "Binary Tree"
            ],
            "difficulty": "Medium",
            "description": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom."
        },
        {
            "number": 200,
            "title": "Number of Islands",
            "tags": [
                "Array",
                "Depth-First Search",
                "Breadth-First Search",
                "Union Find",
                "Matrix"
            ],
            "difficulty": "Medium",
            "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands."
        }
    ]
}